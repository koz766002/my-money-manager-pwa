// --- Translations Object ---
        const translations = {
            en: {
                my_pay_agent: 'My Pay Agent',
                lock_screen_message: 'Your application has been locked due to inactivity.',
                mkt_computer_mobile_services: 'MKT Computer & Mobile Services',
                trusted_companion: 'MKT Computer & Mobile Services',
                opening: 'Opening',
                transactions: 'Transactions',
                daily_money: 'Daily Money',
                expenses: 'Expenses',
                debts_credits: 'Debts/Credits',
                transaction_type_distribution: 'Transaction Type Distribution',
                transaction_action_distribution: 'Transaction Action Distribution',
                daily_money_flow_actions: 'Daily Money Flow Actions',
                daily_money_flow_types: 'Daily Money Flow Types',
                expense_category_distribution: 'Expense Category Distribution',
                debts_credits_summary: 'Debts/Credits Summary',
                total_payable: 'Total Payable:',
                total_receivable: 'Total Receivable:',
                set_opening_balances: 'Set Opening Balances',
                date: 'Date',
                e_money_balance: 'E-Money Balance',
                cash_balance: 'Cash Balance',
                enter_e_money_amount: 'Enter E-Money amount',
                enter_cash_amount: 'Enter Cash amount',
                save_opening_balances: 'Save Opening Balances',
                data_backup_restore: 'Data Backup & Restore',
                backup_data_placeholder: 'Your backup data will appear here...',
                generate_backup: 'Generate Backup',
                restore: 'Restore',
                export_file: 'Export File',
                import_file: 'Import File',
                export_your_data: 'Export Your Data',
                export_to_excel: 'Export to Excel',
                export_to_pdf: 'Export to PDF',
                security_settings: 'Security Settings',
                enable_screen_lock: 'Enable Screen Lock',
                current_pin: 'Current PIN:',
                new_pin: 'New PIN:',
                confirm_new_pin: 'Confirm New PIN:',
                change_pin: 'Change PIN',
                pin_forget_note: 'Note: If you forget your PIN, all application data will be wiped.',
                appearance: 'Appearance',
                dark_mode: 'Dark Mode',
                language: 'Language',
                e_money_balance_today_in: 'E-Money Balance (Today) [IN]:',
                cash_balance_today_in: 'Cash Balance (Today) [IN]:',
                total_commission_earned_today: 'Total Commission Earned (Today):',
                total_fees_charged_today: 'Total Fees Charged (Today):',
                net_balance_change_today: 'Net Balance Change (Today):',
                add_new_transaction: 'Add New Transaction',
                transaction_id: 'Transaction ID',
                date_time: 'Date/Time',
                transaction_type: 'Transaction Type',
                wave_money: 'Wave Money',
                wave_pay: 'Wave Pay',
                kbz_pay: 'KBZ Pay',
                aya_pay: 'Aya Pay',
                other: 'Other (Manual)',
                specify_other_type: 'Specify other type',
                remove_custom_type: 'Remove Custom Type',
                action: 'Action',
                cash_in: 'Cash In',
                cash_out: 'Cash Out',
                send_money: 'Send Money',
                received_money: 'Received Money',
                payment: 'Payment',
                phone_bill: 'Phone Bill',
                amount: 'Amount',
                enter_amount: 'Enter amount',
                commission: 'Commission',
                fee: 'Fee',
                enter_fee: 'Enter fee',
                phone_number: 'Phone Number',
                phone_example: '0912345678',
                note: 'Note',
                optional_note: 'Optional: customer name, details',
                add_transaction: 'Add Transaction',
                cancel: 'Cancel',
                all_types: 'All Types',
                all_actions: 'All Actions',
                filter: 'Filter',
                reset: 'Reset',
                transaction_history: 'Transaction History',
                daily_summary: 'Daily Summary',
                record_daily_money_flow: 'Record Daily Money Flow',
                emoney_in: 'E-Money In',
                emoney_out: 'E-Money Out',
                type: 'Type',
                commission_percentage: 'Commission (%)',
                enter_commission_percentage: 'Enter commission percentage',
                optional_money_note: 'Optional: source of funds, purpose',
                add_record: 'Add Record',
                money_records_flow: 'Money Records Flow',
                e_money_in: 'E-Money In:',
                e_money_out: 'E-Money Out:',
                cash_in: 'Cash In:',
                cash_out: 'Cash Out:',
                e_money_cash_today_in: 'E-Money+ Cash (Today) [IN]:',
                net_balance_today: 'Net Balance (Today):',
                commission_earned: 'Commission Earned:',
                total_amount_flow_today: 'Total Amount Flow (Today):',
                add_new_expense_income_entry: 'Add New Expense/Income Entry',
                expense: 'Expense',
                income: 'Income',
                category: 'Category',
                rent: 'Rent',
                sales: 'Sales',
                specify_other_category: 'Specify other category',
                remove_custom_category: 'Remove Custom Category',
                payment_method: 'Payment Method',
                e_money: 'E-Money',
                cash: 'Cash',
                specify_other_method: 'Specify other method',
                remove_custom_method: 'Remove Custom Method',
                optional_expense_note: 'Optional: purpose of expense, source of income',
                add_entry: 'Add Entry',
                filter_by_category: 'Filter by Category',
                expense_income_records: 'Expense/Income Records',
                total_income_today: 'Total Income (Today):',
                total_expenses_today: 'Total Expenses (Today):',
                net_balance_today: 'Net Balance (Today):',
                select_period: 'Select Period:',
                this_week: 'This Week',
                this_month: 'This Month',
                this_year: 'This Year',
                total_income_period: 'Total Income (Period):',
                total_expenses_period: 'Total Expenses (Period):',
                net_balance_period: 'Net Balance (Period):',
                add_new_debt_credit_entry: 'Add New Debt/Credit Entry',
                name: 'Name',
                enter_persons_name: "Enter person's name",
                you_owe_payable: 'You Owe (Payable)',
                others_owe_you_receivable: 'Others Owe You (Receivable)',
                optional_debt_note: 'Optional: reason for debt, repayment terms',
                add_debt_credit: 'Add Debt/Credit',
                search_by_name: 'Search by Name...',
                search: 'Search',
                payable_debts: 'Payable Debts',
                receivable_credits: 'Receivable Credits'
            },
            my: {
                my_pay_agent: 'ငွေသွင်း - ငွေလွှဲ - ငွေထုတ်',
                lock_screen_message: 'လုပ်ဆောင်မှုမရှိခြင်းကြောင့် သင့်အက်ပလီကေးရှင်းကို လော့ခ်ချထားပါသည်။',
                mkt_computer_mobile_services: 'အမ်ကေတီ ကွန်ပျူတာ နှင့် မိုဘိုင်း ဝန်ဆောင်မှုများ',
                trusted_companion: 'အမ်ကေတီ ကွန်ပျူတာ နှင့် မိုဘိုင်း ဝန်ဆောင်မှုများ',
                opening: 'ဖွင့်လှစ်ခြင်း',
                transactions: 'ငွေလွှဲမှုများ',
                daily_money: 'နေ့စဉ်ငွေ',
                expenses: 'အသုံးစရိတ်များ',
                debts_credits: 'ကြွေးမြီများ/ချေးငွေများ',
                transaction_type_distribution: 'ငွေလွှဲမှုအမျိုးအစား ဖြန့်ဖြူးမှု',
                transaction_action_distribution: 'ငွေလွှဲမှုလုပ်ဆောင်ချက် ဖြန့်ဖြူးမှု',
                daily_money_flow_actions: 'နေ့စဉ်ငွေစီးဆင်းမှုလုပ်ဆောင်ချက်များ',
                daily_money_flow_types: 'နေ့စဉ်ငွေစီးဆင်းမှုအမျိုးအစားများ',
                expense_category_distribution: 'အသုံးစရိတ်အမျိုးအစား ဖြန့်ဖြူးမှု',
                debts_credits_summary: 'ကြွေးမြီများ/ချေးငွေများ အကျဉ်းချုပ်',
                total_payable: 'စုစုပေါင်း ပေးချေရမည်:',
                total_receivable: 'စုစုပေါင်း လက်ခံရမည်:',
                set_opening_balances: 'အဖွင့်‌ငွေများကို သတ်မှတ်ခြင်း',
                date: 'နေ့စွဲ',
                e_money_balance: 'ဒီဂျစ်တယ်ငွေ',
                cash_balance: 'ငွေသားလက်ကျန်',
                enter_e_money_amount: 'ဒီဂျစ်တယ်ငွေ ပမာဏကို ထည့်ပါ',
                enter_cash_amount: 'ငွေသား ပမာဏကို ထည့်ပါ',
                save_opening_balances: 'အဖွင့်‌ငွေများကို ထည့်မည်',
                data_backup_restore: 'ဒေတာ ကူးယူခြင်း နှင့် ရယူခြင်း',
                backup_data_placeholder: 'သင့်အရန်ကူးယူဒေတာ ဤနေရာတွင် ပေါ်လာမည်...',
                generate_backup: 'အရန်ကူးယူ ဖန်တီးပါ',
                restore: 'ပြန်လည်ရယူပါ',
                export_file: 'ဖိုင်ထုတ်ယူပါ',
                import_file: 'ဖိုင်တင်သွင်းပါ',
                export_your_data: 'သင့်ဒေတာကို ထုတ်ယူပါ',
                export_to_excel: 'Excel သို့ ထုတ်ယူပါ',
                export_to_pdf: 'PDF သို့ ထုတ်ယူပါ',
                security_settings: 'လုံခြုံရေး ဆက်တင်များ',
                enable_screen_lock: 'မျက်နှာပြင် လော့ချ ဖွင့်ပါ',
                current_pin: 'လက်ရှိ PIN:',
                new_pin: 'PIN အသစ်:',
                confirm_new_pin: 'PIN အသစ်ကို အတည်ပြုပါ:',
                change_pin: 'PIN ပြောင်းပါ',
                pin_forget_note: 'မှတ်ချက်: သင့် PIN ကို မေ့သွားပါက၊ အက်ပလီကေးရှင်း ဒေတာ အားလုံးကို ဖျက်ပစ်မည်။',
                appearance: 'အသွင်အပြင်',
                dark_mode: 'အမှောင်မုဒ်',
                language: 'ဘာသာစကား',
                e_money_balance_today_in: 'ဒီဂျစ်တယ်ငွေ လက်ကျန် (ယနေ့) [IN]:',
                cash_balance_today_in: 'ငွေသား လက်ကျန် (ယနေ့) [IN]:',
                total_commission_earned_today: 'စုစုပေါင်း ကော်မရှင်ရရှိမှု (ယနေ့):',
                total_fees_charged_today: 'စုစုပေါင်း ဝန်ဆောင်ခရရှိမှု (ယနေ့):',
                net_balance_change_today: 'လက်ကျန် ပြောင်းလဲမှု (ယနေ့):',
                add_new_transaction: 'ငွေလွှဲမှု အသစ်ထည့်ပါ',
                transaction_id: 'ငွေလွှဲမှု ID',
                date_time: 'နေ့စွဲ/အချိန်',
                transaction_type: 'ငွေလွှဲမှုအမျိုးအစား',
                wave_money: 'Wave Money',
                wave_pay: 'Wave Pay',
                kbz_pay: 'KBZ Pay',
                aya_pay: 'AYA Pay',
                other: 'အခြား (ကိုယ်တိုင်ထည့်ပါ)',
                specify_other_type: 'အခြားအမျိုးအစားကို သတ်မှတ်ပါ',
                remove_custom_type: 'ကိုယ်တိုင်အမျိုးအစားကို ဖယ်ရှားပါ',
                action: 'လုပ်ဆောင်ချက်',
                cash_in: 'ငွေသွင်း',
                cash_out: 'ငွေထုတ်',
                send_money: 'ငွေလွှဲ',
                received_money: 'ငွေလက်ခံ',
                payment: '‌‌ဘေလ်ပေးချေမှု',
                phone_bill: 'ဖုန်း‌ငွေ‌ဖြည့်',
                amount: 'ပမာဏ',
                enter_amount: 'ပမာဏ ထည့်ပါ',
                commission: 'ကော်မရှင်',
                fee: 'ဝန်‌ဆောင်‌ခ',
                enter_fee: 'ဝန်‌ဆောင်‌ခ ထည့်ပါ',
                phone_number: 'ဖုန်းနံပါတ်',
                phone_example: '၀၉၁၂၃၄၅၆၇၈',
                note: 'မှတ်ချက်',
                optional_note: 'ရွေးချယ်ရန်: ဖောက်သည်အမည်၊ အသေးစိတ်',
                add_transaction: 'ငွေလွှဲမှု ထည့်ပါ',
                cancel: 'ပယ်ဖျက်ပါ',
                all_types: 'အမျိုးအစားအားလုံး',
                all_actions: 'လုပ်ဆောင်ချက်အားလုံး',
                filter: 'စစ်ထုတ်ပါ',
                reset: 'ပြန်စပါ',
                transaction_history: 'ငွေလွှဲမှု မှတ်တမ်း',
                daily_summary: 'နေ့စဉ်အကျဉ်းချုပ်',
                record_daily_money_flow: 'နေ့စဉ်ငွေစီးဆင်းမှု မှတ်တမ်းတင်ပါ',
                emoney_in: 'ဒီဂျစ်တယ်ငွေ ဝင်',
                emoney_out: 'ဒီဂျစ်တယ်ငွေ ထွက်',
                type: 'အမျိုးအစား',
                commission_percentage: 'ကော်မရှင် (%)',
                enter_commission_percentage: 'ကော်မရှင် ရာခိုင်နှုန်း ထည့်ပါ',
                optional_money_note: 'ရွေးချယ်ရန်: ငွေရင်းမြစ်၊ ရည်ရွယ်ချက်',
                add_record: 'မှတ်တမ်း ထည့်ပါ',
                money_records_flow: 'ငွေ မှတ်တမ်းစီးဆင်းမှု',
                e_money_in: 'ဒီဂျစ်တယ်ငွေ ဝင်:',
                e_money_out: 'ဒီဂျစ်တယ်ငွေ ထွက်:',
                cash_in: 'ငွေ‌သွင်း',
                cash_out: 'ငွေထုတ်',
                e_money_cash_today_in: 'ဒီဂျစ်တယ်ငွေ+ ငွေသား (ယနေ့) [IN]:',
                net_balance_today: 'လက်ကျန် (ယနေ့):',
                commission_earned: 'ကော်မရှင် ရရှိမှု:',
                total_amount_flow_today: 'စုစုပေါင်း ငွေစီးဆင်းမှု (ယနေ့):',
                add_new_expense_income_entry: 'အသုံးစရိတ်/ဝင်ငွေ မှတ်တမ်း အသစ်ထည့်ပါ',
                expense: 'အသုံးစရိတ်',
                income: 'ဝင်ငွေ',
                category: 'အမျိုးအစား',
                rent: 'ငှားရမ်းခ',
                sales: 'ရောင်းချမှု',
                specify_other_category: 'အခြားအမျိုးအစားကို သတ်မှတ်ပါ',
                remove_custom_category: 'ကိုယ်တိုင်အမျိုးအစားကို ဖယ်ရှားပါ',
                payment_method: 'ပေးချေမှုနည်းလမ်း',
                e_money: 'ဒီဂျစ်တယ်ငွေ',
                cash: 'ငွေသား',
                specify_other_method: 'အခြားနည်းလမ်းကို သတ်မှတ်ပါ',
                remove_custom_method: 'ကိုယ်တိုင်နည်းလမ်းကို ဖယ်ရှားပါ',
                optional_expense_note: 'ရွေးချယ်ရန်: အသုံးစရိတ်ရည်ရွယ်ချက်၊ ဝင်ငွေရင်းမြစ်',
                add_entry: 'မှတ်တမ်း ထည့်ပါ',
                filter_by_category: 'အမျိုးအစားအလိုက် စစ်ထုတ်ပါ',
                expense_income_records: 'အသုံးစရိတ်/ဝင်ငွေ မှတ်တမ်းများ',
                total_income_today: 'စုစုပေါင်း ဝင်ငွေ (ယနေ့):',
                total_expenses_today: 'စုစုပေါင်း အသုံးစရိတ်များ (ယနေ့):',
                net_balance_today: 'လက်ကျန် (ယနေ့):',
                select_period: 'ကာလကို ရွေးပါ:',
                this_week: 'ယခုအပတ်',
                this_month: 'ယခုလ',
                this_year: 'ယခုနှစ်',
                total_income_period: 'စုစုပေါင်း ဝင်ငွေ (ကာလ):',
                total_expenses_period: 'စုစုပေါင်း အသုံးစရိတ်များ (ကာလ):',
                net_balance_period: 'လက်ကျန် (ကာလ):',
                add_new_debt_credit_entry: 'ကြွေးမြီ/ချေးငွေ မှတ်တမ်း အသစ်ထည့်ပါ',
                name: 'အမည်',
                enter_persons_name: 'အမည်ကို ထည့်ပါ',
                you_owe_payable: 'သင်ကြွေးဆပ်ရမည် (ပေးရမည်) ',
                others_owe_you_receivable: 'သင့်ကို ကြွေးဆပ်ရမည် (လက်ခံရမည်)',
                optional_debt_note: 'ရွေးချယ်ရန်: ကြွေးမြီ၏ အကြောင်းအရင်း၊ ဆပ်ရန်အချက်များ',
                add_debt_credit: 'ကြွေးမြီ/ချေးငွေ ထည့်ပါ',
                search_by_name: 'အမည်အလိုက် ရှာဖွေပါ...',
                search: 'ရှာဖွေပါ',
                payable_debts: 'ပေးချေရမည့် ကြွေးမြီများ',
                receivable_credits: 'လက်ခံရမည့် ချေးငွေများ'
            }
        };

        let currentLanguage = localStorage.getItem('moneyManager_language') || 'en';

        function setLanguage(lang) {
            currentLanguage = lang;
            localStorage.setItem('moneyManager_language', lang);

            document.querySelectorAll('[data-i18n]').forEach(el => {
                const key = el.getAttribute('data-i18n');
                if (translations[currentLanguage][key]) {
                    el.textContent = translations[currentLanguage][key];
                }
            });

            document.querySelectorAll('[data-i18n-placeholder]').forEach(el => {
                const key = el.getAttribute('data-i18n-placeholder');
                if (translations[currentLanguage][key]) {
                    el.placeholder = translations[currentLanguage][key];
                }
            });

            // Update dynamic elements if needed, like buttons with icons
            const languageButton = document.getElementById('appearance-language-button');
            if (languageButton) {
                languageButton.innerHTML = '<i class="fas fa-language"></i> ' + translations[currentLanguage]['language'];
            }

            // Update dark mode button text as well, since it might have changed
            const darkModeButton = document.getElementById('appearance-dark-mode-button');
            if (darkModeButton) {
                const icon = darkModeButton.querySelector('i');
                darkModeButton.innerHTML = icon.outerHTML + ' ' + translations[currentLanguage][isDarkMode ? 'light_mode' : 'dark_mode'];
            }

            // Re-render lists to update any dynamic text
            updateTransactionList();
            updateMoneyList();
            renderExpenseEntries();
            renderDebts();
        }

        function toggleLanguage() {
            const newLang = currentLanguage === 'en' ? 'my' : 'en';
            setLanguage(newLang);
            showToast(translations[newLang]['language_switched']);
        }

        // Add 'light_mode' to translations if needed
        translations.en.light_mode = 'Light Mode';
        translations.my.light_mode = 'အလင်းမုဒ်';
        translations.en.language_switched = 'Language switched.';
        translations.my.language_switched = 'ဘာသာစကားပြောင်းလဲပြီး။';

        // --- GLOBAL STATE VARIABLES ---
        let transactions = [];
        let moneyRecords = [];
        let debts = [];
        let dailyOpeningBalances = {};
        let savedOtherTransactionTypes = {};
        let savedOtherMoneyTypes = {};
        let tempCommissionData = {};
        let expenseEntries = [];
        let savedExpenseCategories = {};
        let savedExpensePaymentMethods = {}; // Added for payment methods

        let existingDebtNames = [];
        // Store the currently edited item's context for each tab
        let transactionBeingEdited = null; // Context for transaction being edited
        let moneyRecordBeingEdited = null; // Context for money record being edited
        let expenseEntryBeingEdited = null; // Context for expense entry being edited
        // --- NEW CONTEXT FOR DEBT EDIT ---
        let editingDebtEntry = null; // Context for debt entry being edited: { id, type, groupType, groupIdx, entryIdx }

        // --- EDIT MODE FLAGS ---
        let isEditingTransaction = false;
        let isEditingMoneyRecord = false;
        let isEditingExpenseEntry = false;

        // Charting variables
        let transactionTypeChart = null;
        let transactionActionChart = null;
        let moneyFlowActionChart = null;
        let moneyFlowTypeChart = null;
        let expenseCategoryChart = null;

        // --- SCREEN LOCK VARIABLES ---
        let isLocked = false;
        let lockAttempts = 0;
        const MAX_LOCK_ATTEMPTS = 10;
        let lockScreenTimer = null;
        const AUTO_LOCK_DELAY = 5 * 60 * 1000; // 5 minutes
        let pinInputBuffer = '';
        let settingsPIN = '0000'; // Default initial PIN
        let isScreenLockEnabled = false;
        let permanentlyLocked = false;
        let hideSuggestionsOnClickOutside = null; // Handler for closing debt name suggestions
        let currentFilteredTransactions = []; // To store transactions filtered by the UI
        let isDarkMode = false; // Dark mode state

        // --- INITIALIZATION FUNCTIONS ---

        // Initializes the lock screen state by loading settings from localStorage.
        function initializeLockScreen() {
            const storedPIN = localStorage.getItem('moneyManager_appPIN');
            settingsPIN = storedPIN ? storedPIN : '0000'; // Set stored PIN or default

            isScreenLockEnabled = localStorage.getItem('moneyManager_isScreenLockEnabled') === 'true';
            document.getElementById('enable-screen-lock').checked = isScreenLockEnabled;

            permanentlyLocked = localStorage.getItem('moneyManager_permanentlyLocked') === 'true';

            if (permanentlyLocked) {
                showLockScreen(translations[currentLanguage]["permanent_lock_message"]);
                document.getElementById('lock-screen-keyboard').style.display = 'none';
            } else if (isScreenLockEnabled && !isLocked) {
                showLockScreen(translations[currentLanguage]["lock_screen_message"]);
                lockAttempts = 0;
                pinInputBuffer = '';
            } else {
                hideLockScreen();
            }
        }

        // Add to translations
        translations.en.permanent_lock_message = "This application has been permanently locked due to too many failed attempts. All data has been wiped.";
        translations.my.permanent_lock_message = "မှားယွင်းသော ကြိုးစားမှုများ များပြားခြင်းကြောင့် ဤအက်ပလီကေးရှင်းကို အပြီးတိုင် လော့ချထားပါသည်။ ဒေတာ အားလုံး ဖျက်ပစ်ပြီး။";

        // Saves the screen lock enable/disable setting to localStorage.
        function saveLockSetting() {
            isScreenLockEnabled = document.getElementById('enable-screen-lock').checked;
            localStorage.setItem('moneyManager_isScreenLockEnabled', isScreenLockEnabled);

            if (isScreenLockEnabled) {
                if (!isLocked && !permanentlyLocked) {
                    showLockScreen(translations[currentLanguage]["lock_screen_message"]);
                    lockAttempts = 0; pinInputBuffer = '';
                }
            } else {
                if (isLocked) hideLockScreen();
                isLocked = false;
                clearTimeout(lockScreenTimer);
            }
        }

        // Displays the lock screen overlay with an optional message.
        function showLockScreen(message = null) {
            const overlay = document.getElementById('lock-screen-overlay');
            if (overlay) overlay.classList.add('visible');
            isLocked = true;
            pinInputBuffer = '';
            document.getElementById('lock-screen-pin-input').value = '';
            document.getElementById('lock-screen-error-message').textContent = '';
            document.getElementById('lock-screen-message').textContent = message || translations[currentLanguage]["lock_screen_message"];
            document.getElementById('lock-screen-keyboard').style.display = permanentlyLocked ? 'none' : 'block';
        }

        // Hides the lock screen overlay and resumes application functionality.
        function hideLockScreen() {
            const overlay = document.getElementById('lock-screen-overlay');
            if (overlay) overlay.classList.remove('visible');
            isLocked = false;
            pinInputBuffer = '';
            document.getElementById('lock-screen-pin-input').value = '';
            document.getElementById('lock-screen-error-message').textContent = '';

            if (isScreenLockEnabled && !permanentlyLocked) startLockTimer();
        }

        // Handles input from the lock screen numeric keyboard (digits and delete).
        function handleLockScreenInput(input) {
            if (permanentlyLocked) return;

            if (input === 'delete') {
                pinInputBuffer = pinInputBuffer.slice(0, -1);
            } else {
                if (pinInputBuffer.length < 4) pinInputBuffer += input;
            }
            document.getElementById('lock-screen-pin-input').value = '*'.repeat(pinInputBuffer.length);

            if (pinInputBuffer.length === 4) checkPIN(pinInputBuffer);
        }

        // Checks the entered PIN against the stored settings PIN.
        function checkPIN(enteredPIN) {
            if (permanentlyLocked) return;

            if (enteredPIN === settingsPIN) {
                document.getElementById('lock-screen-error-message').textContent = '';
                hideLockScreen();
                return;
            } else {
                lockAttempts++;
                pinInputBuffer = '';
                document.getElementById('lock-screen-pin-input').value = '';

                if (lockAttempts >= MAX_LOCK_ATTEMPTS) {
                    permanentlyLocked = true;
                    localStorage.setItem('moneyManager_permanentlyLocked', 'true');
                    wipeAllData();
                    showLockScreen(translations[currentLanguage]["permanent_lock_message"]);
                    document.getElementById('lock-screen-keyboard').style.display = 'none';
                    return;
                } else {
                    document.getElementById('lock-screen-error-message').textContent = `${translations[currentLanguage]["incorrect_pin"]} ${MAX_LOCK_ATTEMPTS - lockAttempts} ${translations[currentLanguage]["attempts_remaining"]}.`;
                    document.getElementById('lock-screen-message').textContent = translations[currentLanguage]["incorrect_pin_try_again"];
                }
            }
        }

        // Add to translations
        translations.en.incorrect_pin = 'Incorrect PIN.';
        translations.my.incorrect_pin = 'မှားယွင်းသော PIN။';
        translations.en.attempts_remaining = 'attempts remaining';
        translations.my.attempts_remaining = 'ကြိုးစားမှု ကျန်ရှိပါသည်';
        translations.en.incorrect_pin_try_again = 'Incorrect PIN. Please try again.';
        translations.my.incorrect_pin_try_again = 'မှားယွင်းသော PIN။ ထပ်မံကြိုးစားပါ။';

        // Wipes all application data from localStorage and resets global state.
        function wipeAllData() {
            const keysToRemove = [
                'moneyManager_transactions', 'moneyManager_moneyRecords', 'moneyManager_dailyOpeningBalances',
                'moneyManager_savedOtherTransactionTypes', 'moneyManager_savedOtherMoneyTypes',
                'moneyManager_tempCommissionData', 'moneyManager_debts', 'moneyManager_expenseEntries',
                'moneyManager_savedExpenseCategories', 'moneyManager_savedExpensePaymentMethods',
                'moneyManager_appPIN',
                'moneyManager_isScreenLockEnabled', 'moneyManager_permanentlyLocked', 'moneyManager_darkMode',
                'moneyManager_language'
            ];
            keysToRemove.forEach(key => localStorage.removeItem(key));

            transactions = []; moneyRecords = []; debts = []; dailyOpeningBalances = {};
            savedOtherTransactionTypes = {}; savedOtherMoneyTypes = {};
            tempCommissionData = {};
            expenseEntries = []; savedExpenseCategories = {}; savedExpensePaymentMethods = {};
            isDarkMode = false; // Reset dark mode

            // Reset charts
            destroyAllCharts();

            // Reset UI elements
            updateSummariesBasedOnCurrentView(); renderDebts(); populateCustomTypes();
            populateExpenseCategories(); populatePaymentMethods(); renderExpenseEntries();
            document.getElementById('opening-emoney').value = ''; document.getElementById('opening-cash').value = '';
            document.body.classList.remove('dark-mode');

            showToast(translations[currentLanguage]["all_data_wiped"]);
        }

        // Add to translations
        translations.en.all_data_wiped = "All application data has been wiped due to security measures.";
        translations.my.all_data_wiped = "လုံခြုံရေး အစီအမံကြောင့် အက်ပလီကေးရှင်း ဒေတာ အားလုံး ဖျက်ပစ်ပြီး။";

        // Starts the timer for automatic screen locking after a period of inactivity.
        function startLockTimer() {
            clearTimeout(lockScreenTimer);
            lockScreenTimer = setTimeout(() => {
                if (!isLocked && isScreenLockEnabled && !permanentlyLocked) {
                    showLockScreen(translations[currentLanguage]["session_timed_out"]);
                    lockAttempts = 0; pinInputBuffer = '';
                }
            }, AUTO_LOCK_DELAY);
        }

        // Add to translations
        translations.en.session_timed_out = "Your session has timed out and the application has been locked.";
        translations.my.session_timed_out = "သင့်ဆက်ရှင်က အချိန်ကုန်သွားပြီ ဖြစ်ပြီး အက်ပလီကေးရှင်းကို လော့ချထားပါသည်။";

        // Resets the inactivity timer when the user performs an action.
        function resetLockTimer() {
            if (!isLocked && isScreenLockEnabled && !permanentlyLocked) startLockTimer();
        }

        // --- SETTINGS: PIN CHANGE FUNCTIONALITY ---
        function handleChangePIN() {
            const currentPinInput = document.getElementById('current-pin');
            const newPinInput = document.getElementById('new-pin');
            const confirmNewPinInput = document.getElementById('confirm-new-pin');

            const currentPin = currentPinInput.value;
            const newPin = newPinInput.value;
            const confirmNewPin = confirmNewPinInput.value;

            if (!currentPin || !newPin || !confirmNewPin) {
                showToast(translations[currentLanguage]["fill_all_pin_fields"], "error"); return;
            }
            if (newPin.length !== 4 || !/^\d+$/.test(newPin)) {
                showToast(translations[currentLanguage]["new_pin_4_digits"], "error"); return;
            }
            if (newPin !== confirmNewPin) {
                showToast(translations[currentLanguage]["pins_do_not_match"], "error"); return;
            }
            if (currentPin !== settingsPIN) {
                showToast(translations[currentLanguage]["incorrect_current_pin"], "error"); return;
            }

            settingsPIN = newPin;
            localStorage.setItem('moneyManager_appPIN', settingsPIN);
            currentPinInput.value = ''; newPinInput.value = ''; confirmNewPinInput.value = '';

            showToast(translations[currentLanguage]["pin_changed_success"], "success");
        }

        // Add to translations
        translations.en.fill_all_pin_fields = "Please fill in all PIN fields.";
        translations.my.fill_all_pin_fields = "PIN အကွက်များအားလုံးကို ဖြည့်ပါ။";
        translations.en.new_pin_4_digits = "New PIN must be exactly 4 digits.";
        translations.my.new_pin_4_digits = "PIN အသစ်သည် အတိအကျ ၄ ဂဏန်း ရှိရမည်။";
        translations.en.pins_do_not_match = "New PIN and Confirm New PIN do not match.";
        translations.my.pins_do_not_match = "PIN အသစ်နှင့် အတည်ပြု PIN အသစ်တို့ မကိုက်ညီပါ။";
        translations.en.incorrect_current_pin = "Incorrect current PIN.";
        translations.my.incorrect_current_pin = "မှားယွင်းသော လက်ရှိ PIN။";
        translations.en.pin_changed_success = "PIN changed successfully!";
        translations.my.pin_changed_success = "PIN ကို အောင်မြင်စွာ ပြောင်းလဲပြီး!";

        // --- APPEARANCE: DARK MODE TOGGLE ---
        function toggleDarkMode() {
            isDarkMode = !isDarkMode;
            document.body.classList.toggle('dark-mode', isDarkMode);
            localStorage.setItem('moneyManager_darkMode', isDarkMode);

            const darkModeButton = document.getElementById('appearance-dark-mode-button');
            if (darkModeButton) {
                const icon = darkModeButton.querySelector('i');
                if (isDarkMode) {
                    icon.classList.remove('fa-moon');
                    icon.classList.add('fa-sun');
                    darkModeButton.innerHTML = '<i class="fas fa-sun"></i> ' + translations[currentLanguage]['light_mode'];
                } else {
                    icon.classList.remove('fa-sun');
                    icon.classList.add('fa-moon');
                    darkModeButton.innerHTML = '<i class="fas fa-moon"></i> ' + translations[currentLanguage]['dark_mode'];
                }
            }
            showToast(isDarkMode ? translations[currentLanguage]["dark_mode_enabled"] : translations[currentLanguage]["light_mode_enabled"]);
            // Update chart colors after mode change
            updateChartColors();
        }

        // Add to translations
        translations.en.dark_mode_enabled = "Dark mode enabled.";
        translations.my.dark_mode_enabled = "အမှောင်မုဒ် ဖွင့်ထားပါသည်။";
        translations.en.light_mode_enabled = "Light mode enabled.";
        translations.my.light_mode_enabled = "အလင်းမုဒ် ဖွင့်ထားပါသည်။";

        function initializeDarkMode() {
            isDarkMode = localStorage.getItem('moneyManager_darkMode') === 'true';
            document.body.classList.toggle('dark-mode', isDarkMode);

            const darkModeButton = document.getElementById('appearance-dark-mode-button');
            if (darkModeButton) {
                const icon = darkModeButton.querySelector('i');
                if (isDarkMode) {
                    icon.classList.remove('fa-moon');
                    icon.classList.add('fa-sun');
                    darkModeButton.innerHTML = '<i class="fas fa-sun"></i> ' + translations[currentLanguage]['light_mode'];
                } else {
                    icon.classList.remove('fa-sun');
                    icon.classList.add('fa-moon');
                    darkModeButton.innerHTML = '<i class="fas fa-moon"></i> ' + translations[currentLanguage]['dark_mode'];
                }
            }
        }

        // --- UTILITY FUNCTIONS ---

        // Formats a number for display with comma separators and two decimal places.
        function formatNumber(num) {
            if (num === null || num === undefined) return '0.00';
            const n = parseFloat(num);
            if (isNaN(n)) return '0.00';

            if (Number.isInteger(n)) {
                return n.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
            } else {
                let parts = n.toFixed(2).split('.');
                parts[0] = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, ",");
                return parts.join('.');
            }
        }

        // Formats an input field value to have comma separators and at most two decimal places.
        function formatInputAmount(inputElement) {
            let value = inputElement.value.replace(/,/g, '');
            let cleanedValue = '';
            let decimalFound = false;

            for (let i = 0; i < value.length; i++) {
                const char = value[i];
                if (char >= '0' && char <= '9') {
                    cleanedValue += char;
                } else if (char === '.' && !decimalFound) {
                    cleanedValue += '.';
                    decimalFound = true;
                }
            }
            if (cleanedValue.includes('.')) {
                const decimalPart = cleanedValue.split('.')[1];
                if (decimalPart && decimalPart.length > 2) {
                    cleanedValue = cleanedValue.substring(0, cleanedValue.indexOf('.') + 3);
                }
            }

            let formattedValue = '';
            let commaIndex = cleanedValue.indexOf('.');
            let integerPart = commaIndex === -1 ? cleanedValue : cleanedValue.substring(0, commaIndex);
            let decimalPart = commaIndex === -1 ? '' : '.' + cleanedValue.substring(commaIndex + 1);

            for (let i = integerPart.length - 1; i >= 0; i--) {
                formattedValue = integerPart[i] + formattedValue;
                if ((integerPart.length - i) % 3 === 0 && i !== 0) {
                    formattedValue = ',' + formattedValue;
                }
            }
            inputElement.value = formattedValue + decimalPart;
        }

        // Sets the current date and time to relevant input fields if they are empty.
        function updateDateTimeFields() {
            const now = new Date();
            const year = now.getFullYear();
            const month = (now.getMonth() + 1).toString().padStart(2, '0');
            const day = now.getDate().toString().padStart(2, '0');
            const hours = now.getHours().toString().padStart(2, '0');
            const minutes = now.getMinutes().toString().padStart(2, '0');

            const currentDateTime = `${year}-${month}-${day}T${hours}:${minutes}`;

            if (!document.getElementById('transaction-date').value) document.getElementById('transaction-date').value = currentDateTime;
            if (!document.getElementById('money-date').value) document.getElementById('money-date').value = currentDateTime;
            if (!document.getElementById('debt-date').value) document.getElementById('debt-date').value = currentDateTime;
            if (!document.getElementById('expense-date').value) document.getElementById('expense-date').value = currentDateTime;
        }

        // Displays a temporary notification message (toast) at the bottom of the screen.
        function showToast(message, type = 'success') {
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.textContent = message;
            document.body.appendChild(toast);

            void toast.offsetWidth; // Trigger reflow for transition
            toast.classList.add('show');

            setTimeout(() => {
                toast.classList.remove('show');
                setTimeout(() => toast.remove(), 300); // Match transition duration
            }, 3000);
        }

        // Adds a new option to a specified select element dynamically.
        function addOptionToSelect(selectId, optionValue) {
            const selectElement = document.getElementById(selectId);
            // Normalize values for comparison (lowercase and trim)
            const normalizedOptionValue = optionValue ? optionValue.trim().toLowerCase() : '';
            const optionExists = Array.from(selectElement.options).some(opt => opt.value.trim().toLowerCase() === normalizedOptionValue);

            if (!optionExists && normalizedOptionValue && normalizedOptionValue !== 'other') {
                const newOption = document.createElement('option');
                newOption.value = optionValue.trim(); // Keep original casing for display
                newOption.textContent = optionValue.trim();

                const otherOption = selectElement.querySelector('option[value="other"]');
                if (otherOption) {
                    selectElement.insertBefore(newOption, otherOption);
                } else {
                    selectElement.appendChild(newOption);
                }
                return true; // Indicate that an option was added
            }
            return false; // Indicate no option was added
        }

        // Removes a custom option from a select element and updates saved data.
        function removeCustomOption(selectId, optionValue, savedDataStorageKey) {
            const selectElement = document.getElementById(selectId);
            const normalizedOptionValue = optionValue.trim().toLowerCase();

            // Find the option to remove, ignoring case and 'other'
            const optionToRemove = Array.from(selectElement.options).find(opt =>
                opt.value.trim().toLowerCase() === normalizedOptionValue &&
                opt.value.trim().toLowerCase() !== 'other'
            );

            if (optionToRemove) {
                selectElement.removeChild(optionToRemove);
                const savedData = JSON.parse(localStorage.getItem(savedDataStorageKey) || '{}');
                delete savedData[optionValue]; // Use original casing key to delete
                localStorage.setItem(savedDataStorageKey, JSON.stringify(savedData));
                showToast(`${translations[currentLanguage]["custom_removed"]} '${optionValue}' ${translations[currentLanguage]["removed_from_list"]} ${selectId.replace('transaction-', '').replace('money-', '').replace('expense-', '')} list.`);
                return true;
            }
            return false;
        }

        // Add to translations
        translations.en.custom_removed = "Custom";
        translations.my.custom_removed = "ကိုယ်တိုင်";
        translations.en.removed_from_list = "removed from";
        translations.my.removed_from_list = "ကို ဖယ်ရှားပြီး";

        // --- DATA PERSISTENCE (SAVE/LOAD TO LOCALSTORAGE) ---

        // Saves all application data to localStorage.
        function saveData() {
            try {
                localStorage.setItem('moneyManager_transactions', JSON.stringify(transactions));
                localStorage.setItem('moneyManager_moneyRecords', JSON.stringify(moneyRecords));
                localStorage.setItem('moneyManager_dailyOpeningBalances', JSON.stringify(dailyOpeningBalances));
                localStorage.setItem('moneyManager_savedOtherTransactionTypes', JSON.stringify(savedOtherTransactionTypes));
                localStorage.setItem('moneyManager_savedOtherMoneyTypes', JSON.stringify(savedOtherMoneyTypes));
                localStorage.setItem('moneyManager_tempCommissionData', JSON.stringify(tempCommissionData));
                localStorage.setItem('moneyManager_debts', JSON.stringify(debts));
                localStorage.setItem('moneyManager_expenseEntries', JSON.stringify(expenseEntries));
                localStorage.setItem('moneyManager_savedExpenseCategories', JSON.stringify(savedExpenseCategories));
                localStorage.setItem('moneyManager_savedExpensePaymentMethods', JSON.stringify(savedExpensePaymentMethods)); // Save payment methods
            } catch (e) {
                console.error("Error saving data to localStorage:", e);
                if (e.name === 'QuotaExceededError') showToast(translations[currentLanguage]["local_storage_full"], "error");
                else showToast(translations[currentLanguage]["error_saving_data"], "error");
            }
        }

        // Add to translations
        translations.en.local_storage_full = "Local storage is full. Cannot save data.";
        translations.my.local_storage_full = "လိုကယ်စတိုးရှင်း ပြည့်နေပါသည်။ ဒေတာ မသိမ်းဆည်းနိုင်ပါ။";
        translations.en.error_saving_data = "An error occurred while saving data.";
        translations.my.error_saving_data = "ဒေတာ သိမ်းဆည်းရာတွင် အမှားတစ်ခု ဖြစ်ပွားပါသည်။";

        // Loads data from localStorage into the application's global variables.
        function loadData() {
            const savedTransactions = localStorage.getItem('moneyManager_transactions');
            const savedMoneyRecords = localStorage.getItem('moneyManager_moneyRecords');
            const savedDailyOpeningBalances = localStorage.getItem('moneyManager_dailyOpeningBalances');
            const savedOtherTransactionTypesData = localStorage.getItem('moneyManager_savedOtherTransactionTypes');
            const savedOtherMoneyTypesData = localStorage.getItem('moneyManager_savedOtherMoneyTypes');
            const savedTempCommissionData = localStorage.getItem('moneyManager_tempCommissionData');
            const savedDebts = localStorage.getItem('moneyManager_debts');
            const savedExpenseEntries = localStorage.getItem('moneyManager_expenseEntries');
            const savedExpenseCategoriesData = localStorage.getItem('moneyManager_savedExpenseCategories');
            const savedExpensePaymentMethodsData = localStorage.getItem('moneyManager_savedExpensePaymentMethods'); // Load payment methods

            try {
                transactions = savedTransactions ? JSON.parse(savedTransactions) : [];
                moneyRecords = savedMoneyRecords ? JSON.parse(savedMoneyRecords) : [];
                dailyOpeningBalances = savedDailyOpeningBalances ? JSON.parse(savedDailyOpeningBalances) : {};
                savedOtherTransactionTypes = savedOtherTransactionTypesData ? JSON.parse(savedOtherTransactionTypesData) : {};
                savedOtherMoneyTypes = savedOtherMoneyTypesData ? JSON.parse(savedOtherMoneyTypesData) : {};
                tempCommissionData = savedTempCommissionData ? JSON.parse(savedTempCommissionData) : {};
                debts = savedDebts ? JSON.parse(savedDebts) : [];
                expenseEntries = savedExpenseEntries ? JSON.parse(savedExpenseEntries) : [];
                savedExpenseCategories = savedExpenseCategoriesData ? JSON.parse(savedExpenseCategoriesData) : {};
                savedExpensePaymentMethods = savedExpensePaymentMethodsData ? JSON.parse(savedExpensePaymentMethodsData) : {}; // Parse payment methods

            } catch (e) {
                console.error("Error parsing data from localStorage:", e);
                showToast(translations[currentLanguage]["error_reading_data"], "error");
                // Reset all data to defaults on error
                transactions = []; moneyRecords = []; debts = []; dailyOpeningBalances = {};
                savedOtherTransactionTypes = {}; savedOtherMoneyTypes = {}; tempCommissionData = {};
                expenseEntries = []; savedExpenseCategories = {}; savedExpensePaymentMethods = {};
                return;
            }

            // Data validation and cleanup
            if (!Array.isArray(transactions)) transactions = [];
            if (!Array.isArray(moneyRecords)) moneyRecords = [];
            if (typeof dailyOpeningBalances !== 'object' || dailyOpeningBalances === null) dailyOpeningBalances = {};

            if (typeof savedOtherTransactionTypes !== 'object' || savedOtherTransactionTypes === null) savedOtherTransactionTypes = {};
            if (typeof savedOtherMoneyTypes !== 'object' || savedOtherMoneyTypes === null) savedOtherMoneyTypes = {};
            if (typeof tempCommissionData !== 'object' || tempCommissionData === null) tempCommissionData = {};
            if (!Array.isArray(debts)) debts = [];
            if (!Array.isArray(expenseEntries)) expenseEntries = [];
            if (typeof savedExpenseCategories !== 'object' || savedExpenseCategories === null) savedExpenseCategories = {};
            if (typeof savedExpensePaymentMethods !== 'object' || savedExpensePaymentMethods === null) savedExpensePaymentMethods = {}; // Validate payment methods

            updateExistingDebtNames();
            populateCustomTypes();
            populateExpenseCategories();
            populatePaymentMethods();
        }

        // Add to translations
        translations.en.error_reading_data = "Error reading data from local storage";
        translations.my.error_reading_data = "လိုကယ်စတိုးရှင်းမှ ဒေတာ ဖတ်ရာတွင် အမှားဖြစ်ပွားပါသည်";

        // Populates the custom transaction and money record type select dropdowns.
        function populateCustomTypes() {
            const transactionTypeSelect = document.getElementById('transaction-type');
            const moneyTypeSelect = document.getElementById('money-type');

            const existingTransactionTypes = Array.from(transactionTypeSelect.options).map(opt => opt.value.toLowerCase().trim());
            for (const type in savedOtherTransactionTypes) {
                if (Object.hasOwnProperty.call(savedOtherTransactionTypes, type) && type.trim() !== '' && type.toLowerCase().trim() !== 'other' && !existingTransactionTypes.includes(type.toLowerCase().trim())) {
                    addOptionToSelect('transaction-type', type);
                }
            }

            const existingMoneyTypes = Array.from(moneyTypeSelect.options).map(opt => opt.value.toLowerCase().trim());
            for (const type in savedOtherMoneyTypes) {
                if (Object.hasOwnProperty.call(savedOtherMoneyTypes, type) && type.trim() !== '' && type.toLowerCase().trim() !== 'other' && !existingMoneyTypes.includes(type.toLowerCase().trim())) {
                    addOptionToSelect('money-type', type);
                }
            }
        }

        // Populates the expense category select dropdown with saved custom categories.
        function populateExpenseCategories() {
            const expenseCategorySelect = document.getElementById('expense-category');
            const existingCategories = Array.from(expenseCategorySelect.options).map(opt => opt.value.toLowerCase().trim());
            for (const category in savedExpenseCategories) {
                if (Object.hasOwnProperty.call(savedExpenseCategories, category) && category.trim() !== '' && category.toLowerCase().trim() !== 'other' && !existingCategories.includes(category.toLowerCase().trim())) {
                    addOptionToSelect('expense-category', category);
                }
            }
        }

        // Populates the expense payment method select dropdown with saved custom methods.
        function populatePaymentMethods() {
            const paymentMethodSelect = document.getElementById('expense-payment-method');
            const existingMethods = Array.from(paymentMethodSelect.options).map(opt => opt.value.toLowerCase().trim());
            for (const method in savedExpensePaymentMethods) {
                if (Object.hasOwnProperty.call(savedExpensePaymentMethods, method) && method.trim() !== '' && method.toLowerCase().trim() !== 'other' && !existingMethods.includes(method.toLowerCase().trim())) {
                    addOptionToSelect('expense-payment-method', method);
                }
            }
        }

        // --- CHART HELPER FUNCTIONS ---
        function destroyAllCharts() {
            if (transactionTypeChart) transactionTypeChart.destroy();
            if (transactionActionChart) transactionActionChart.destroy();
            if (moneyFlowActionChart) moneyFlowActionChart.destroy();
            if (moneyFlowTypeChart) moneyFlowTypeChart.destroy();
            if (expenseCategoryChart) expenseCategoryChart.destroy();

            transactionTypeChart = null;
            transactionActionChart = null;
            moneyFlowActionChart = null;
            moneyFlowTypeChart = null;
            expenseCategoryChart = null;
        }

        function updateChartColors() {
            const chartTextColor = isDarkMode ? getComputedStyle(document.documentElement).getPropertyValue('--dark-mode-text') : getComputedStyle(document.documentElement).getPropertyValue('--text');
            const chartPrimaryColor = isDarkMode ? getComputedStyle(document.documentElement).getPropertyValue('--dark-mode-primary') : getComputedStyle(document.documentElement).getPropertyValue('--primary');
            const chartDangerColor = getComputedStyle(document.documentElement).getPropertyValue('--danger');
            const chartPositiveColor = getComputedStyle(document.documentElement).getPropertyValue('--positive');
            const chartLightGray = getComputedStyle(document.documentElement).getPropertyValue('--light-gray');
            const chartBgColor = isDarkMode ? getComputedStyle(document.documentElement).getPropertyValue('--dark-mode-card-bg') : getComputedStyle(document.documentElement).getPropertyValue('--card-background');
            const chartBorderColor = isDarkMode ? getComputedStyle(document.documentElement).getPropertyValue('--dark-mode-border-color') : getComputedStyle(document.documentElement).getPropertyValue('--medium-gray');

            // Update existing charts if they exist
            if (transactionTypeChart) {
                transactionTypeChart.options.plugins.title.color = chartTextColor;
                transactionTypeChart.options.plugins.legend.labels.color = chartTextColor;
                // Set dataset background colors for consistency
                transactionTypeChart.data.datasets[0].backgroundColor = [
                    chartPrimaryColor,
                    'rgba(108, 117, 125, 0.8)', // Secondary gray
                    chartDangerColor,
                    chartPositiveColor
                ];
                transactionTypeChart.update();
            }
            if (transactionActionChart) {
                transactionActionChart.options.plugins.title.color = chartTextColor;
                transactionActionChart.options.plugins.legend.labels.color = chartTextColor;
                transactionActionChart.data.datasets[0].backgroundColor = [
                    chartPositiveColor, chartDangerColor, chartPrimaryColor,
                    chartPrimaryColor, chartLightGray, chartLightGray
                ];
                transactionActionChart.data.datasets[0].borderColor = [
                    chartPositiveColor, chartDangerColor, chartPrimaryColor,
                    chartPrimaryColor, chartLightGray, chartLightGray
                ];
                transactionActionChart.update();
            }
            if (moneyFlowActionChart) {
                moneyFlowActionChart.options.plugins.title.color = chartTextColor;
                moneyFlowActionChart.options.plugins.legend.labels.color = chartTextColor;
                moneyFlowActionChart.data.datasets[0].backgroundColor = [
                    chartPositiveColor, chartDangerColor, chartPrimaryColor,
                    chartLightGray
                ];
                moneyFlowActionChart.update();
            }
            if (moneyFlowTypeChart) {
                moneyFlowTypeChart.options.plugins.title.color = chartTextColor;
                moneyFlowTypeChart.options.plugins.legend.labels.color = chartTextColor;
                moneyFlowTypeChart.data.datasets[0].backgroundColor = [
                    chartPrimaryColor, 'rgba(108, 117, 125, 0.8)', chartPositiveColor
                ];
                moneyFlowTypeChart.update();
            }
            if (expenseCategoryChart) {
                expenseCategoryChart.options.plugins.title.color = chartTextColor;
                expenseCategoryChart.options.plugins.legend.labels.color = chartTextColor;
                expenseCategoryChart.data.datasets[0].backgroundColor = [
                    chartDangerColor, // Expense red
                    chartPrimaryColor, // Income blue (example)
                    chartLightGray, // Other
                    'rgba(108, 117, 125, 0.8)', // Secondary gray
                    'rgba(255, 193, 7, 0.8)' // Yellow
                ];
                expenseCategoryChart.data.datasets[0].borderColor = [
                    chartDangerColor, chartPrimaryColor, chartLightGray,
                    'rgba(108, 117, 125, 1)', 'rgba(255, 193, 7, 1)'
                ];
                expenseCategoryChart.update();
            }
        }

        function drawTransactionCharts() {
            // Transaction Type Distribution (Total Amount)
            const transactionTypes = {};
            const currentTransactions = Array.isArray(transactions) ? transactions : []; // Ensure it's an array

            currentTransactions.forEach(t => {
                const type = t.type || translations[currentLanguage]["unknown_type"];
                transactionTypes[type] = (transactionTypes[type] || 0) + parseFloat(t.amount || 0);
            });
            const typeLabels = Object.keys(transactionTypes);
            const typeData = Object.values(transactionTypes);

            const transactionTypeCtx = document.getElementById('transaction-type-chart')?.getContext('2d');
            if (!transactionTypeCtx) {
                console.error("Canvas context for transaction-type-chart not found.");
                return;
            }
            if (transactionTypeChart) transactionTypeChart.destroy();
            transactionTypeChart = new Chart(transactionTypeCtx, {
                type: 'bar', // Changed to Bar chart
                data: {
                    labels: typeData.length > 0 ? typeLabels : [translations[currentLanguage]["no_transaction_data"]],
                    datasets: [{
                        label: translations[currentLanguage]["total_amount"],
                        data: typeData.length > 0 ? typeData : [0],
                        backgroundColor: typeData.length > 0
                            ? [
                                '#007bff', // Primary
                                'rgba(108, 117, 125, 0.8)', // Secondary gray
                                'rgba(220, 53, 69, 0.8)', // Danger red
                                'rgba(40, 167, 69, 0.8)' // Success green
                              ]
                            : ['#cccccc'],
                        borderColor: typeData.length > 0
                            ? [
                                '#007bff',
                                'rgba(108, 117, 125, 1)',
                                'rgba(220, 53, 69, 1)',
                                'rgba(40, 167, 69, 1)'
                              ]
                            : ['#cccccc'],
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false, // Crucial for filling the container correctly
                    plugins: {
                        title: { display: true, text: translations[currentLanguage]["transaction_type_distribution_total"], color: isDarkMode ? 'white' : '#495057', font: { size: 14 } },
                        legend: { display: false }, // Hide legend for bar charts if labels are clear
                    },
                    scales: {
                        y: { beginAtZero: true, ticks: { color: isDarkMode ? 'white' : '#495057' } },
                        x: { ticks: { color: isDarkMode ? 'white' : '#495057' } }
                    }
                }
            });
            // Add to translations if needed
            translations.en.transaction_type_distribution_total = 'Transaction Type Distribution (Total Amount)';
            translations.my.transaction_type_distribution_total = 'ငွေလွှဲမှုအမျိုးအစား ဖြန့်ဖြူးမှု (စုစုပေါင်း ပမာဏ)';
            translations.en.unknown_type = 'Unknown Type';
            translations.my.unknown_type = 'မသိရှိသော အမျိုးအစား';
            translations.en.total_amount = 'Total Amount';
            translations.my.total_amount = 'စုစုပေါင်း ပမာဏ';
            translations.en.no_transaction_data = 'No Transaction Data';
            translations.my.no_transaction_data = 'ငွေလွှဲမှု ဒေတာ မရှိပါ';

            // Transaction Action Distribution (Total Amount)
            const transactionActions = {};
            currentTransactions.forEach(t => {
                const action = t.action || translations[currentLanguage]["unknown_action"];
                transactionActions[action] = (transactionActions[action] || 0) + parseFloat(t.amount || 0);
            });
            const actionLabels = Object.keys(transactionActions);
            const actionData = Object.values(transactionActions);

            const transactionActionCtx = document.getElementById('transaction-action-chart')?.getContext('2d');
            if (!transactionActionCtx) {
                console.error("Canvas context for transaction-action-chart not found.");
                return;
            }
            if (transactionActionChart) transactionActionChart.destroy();
            transactionActionChart = new Chart(transactionActionCtx, {
                type: 'bar', // Use Bar chart for distribution
                data: {
                    labels: actionData.length > 0 ? actionLabels : [translations[currentLanguage]["no_transaction_data"]],
                    datasets: [{
                        label: translations[currentLanguage]["total_amount"],
                        data: actionData.length > 0 ? actionData : [0],
                        backgroundColor: actionData.length > 0
                            ? ['#28a745', '#dc3545', '#007bff', '#007bff', '#6c757d', '#6c757d']
                            : ['#cccccc'],
                        borderColor: actionData.length > 0
                            ? ['#28a745', '#dc3545', '#007bff', '#007bff', '#6c757d', '#6c757d']
                            : ['#cccccc'],
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false, // Allows chart to fill container height
                    plugins: {
                        title: { display: true, text: translations[currentLanguage]["transaction_action_distribution_total"], color: isDarkMode ? 'white' : '#495057', font: { size: 14 } },
                        legend: { display: false },
                    },
                    scales: {
                        y: { beginAtZero: true, ticks: { color: isDarkMode ? 'white' : '#495057' } },
                        x: { ticks: { color: isDarkMode ? 'white' : '#495057' } }
                    }
                }
            });

            // Add to translations
            translations.en.transaction_action_distribution_total = 'Transaction Action Distribution (Total Amount)';
            translations.my.transaction_action_distribution_total = 'ငွေလွှဲမှုလုပ်ဆောင်ချက် ဖြန့်ဖြူးမှု (စုစုပေါင်း ပမာဏ)';
            translations.en.unknown_action = 'Unknown Action';
            translations.my.unknown_action = 'မသိရှိသော လုပ်ဆောင်ချက်';
        }

        function drawDailyMoneyCharts() {
            // Daily Money Flow Actions (Total Amount)
            const moneyActions = {};
            const currentMoneyRecords = Array.isArray(moneyRecords) ? moneyRecords : [];

            currentMoneyRecords.forEach(r => {
                const action = r.action || translations[currentLanguage]["unknown_action"];
                moneyActions[action] = (moneyActions[action] || 0) + parseFloat(r.amount || 0);
            });
            const moneyActionLabels = Object.keys(moneyActions);
            const moneyActionData = Object.values(moneyActions);

            const moneyFlowActionCtx = document.getElementById('money-flow-action-chart')?.getContext('2d');
            if (!moneyFlowActionCtx) {
                console.error("Canvas context for money-flow-action-chart not found.");
                return;
            }
            if (moneyFlowActionChart) moneyFlowActionChart.destroy();
            moneyFlowActionChart = new Chart(moneyFlowActionCtx, {
                type: 'bar', // Changed to Bar chart
                data: {
                    labels: moneyActionLabels.length > 0 ? moneyActionLabels : [translations[currentLanguage]["no_money_flow_data"]],
                    datasets: [{
                        label: translations[currentLanguage]["total_amount"],
                        data: moneyActionData.length > 0 ? moneyActionData : [0],
                        backgroundColor: moneyActionData.length > 0
                            ? ['#28a745', '#dc3545', '#007bff', '#6c757d']
                            : ['#cccccc'],
                        borderColor: moneyActionData.length > 0
                            ? ['#28a745', '#dc3545', '#007bff', '#6c757d']
                            : ['#cccccc'],
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false, // Crucial for filling the container correctly
                    plugins: {
                        title: { display: true, text: translations[currentLanguage]["daily_money_flow_actions_total"], color: isDarkMode ? 'white' : '#495057', font: { size: 14 } },
                        legend: { display: false },
                    },
                    scales: {
                        y: { beginAtZero: true, ticks: { color: isDarkMode ? 'white' : '#495057' } },
                        x: { ticks: { color: isDarkMode ? 'white' : '#495057' } }
                    }
                }
            });

            // Add to translations
            translations.en.daily_money_flow_actions_total = 'Daily Money Flow Actions (Total Amount)';
            translations.my.daily_money_flow_actions_total = 'နေ့စဉ်ငွေစီးဆင်းမှုလုပ်ဆောင်ချက်များ (စုစုပေါင်း ပမာဏ)';
            translations.en.no_money_flow_data = 'No Money Flow Data';
            translations.my.no_money_flow_data = 'ငွေစီးဆင်းမှု ဒေတာ မရှိပါ';

            // Daily Money Flow Types (Total Amount)
            const moneyTypes = {};
            currentMoneyRecords.forEach(r => {
                const type = r.type || translations[currentLanguage]["unknown_type"];
                moneyTypes[type] = (moneyTypes[type] || 0) + parseFloat(r.amount || 0);
            });
            const moneyTypeLabels = Object.keys(moneyTypes);
            const moneyTypeData = Object.values(moneyTypes);

            const moneyFlowTypeCtx = document.getElementById('money-flow-type-chart')?.getContext('2d');
            if (!moneyFlowTypeCtx) {
                console.error("Canvas context for money-flow-type-chart not found.");
                return;
            }
            if (moneyFlowTypeChart) moneyFlowTypeChart.destroy();
            moneyFlowTypeChart = new Chart(moneyFlowTypeCtx, {
                type: 'bar', // Changed to Bar chart
                data: {
                    labels: moneyTypeLabels.length > 0 ? moneyTypeLabels : [translations[currentLanguage]["no_money_flow_data"]],
                    datasets: [{
                        label: translations[currentLanguage]["total_amount"],
                        data: moneyTypeData.length > 0 ? moneyTypeData : [0],
                        backgroundColor: moneyTypeData.length > 0
                            ? ['#007bff', 'rgba(108, 117, 125, 0.8)', '#28a745']
                            : ['#cccccc'],
                        borderColor: moneyTypeData.length > 0
                            ? ['#007bff', 'rgba(108, 117, 125, 1)', '#28a745']
                            : ['#cccccc'],
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false, // Crucial for filling the container correctly
                    plugins: {
                        title: { display: true, text: translations[currentLanguage]["daily_money_flow_types_total"], color: isDarkMode ? 'white' : '#495057', font: { size: 14 } },
                        legend: { display: false },
                    },
                    scales: {
                        y: { beginAtZero: true, ticks: { color: isDarkMode ? 'white' : '#495057' } },
                        x: { ticks: { color: isDarkMode ? 'white' : '#495057' } }
                    }
                }
            });

            // Add to translations
            translations.en.daily_money_flow_types_total = 'Daily Money Flow Types (Total Amount)';
            translations.my.daily_money_flow_types_total = 'နေ့စဉ်ငွေစီးဆင်းမှုအမျိုးအစားများ (စုစုပေါင်း ပမာဏ)';
        }

        function drawExpenseCharts() {
            // Expense Category Distribution (Total Amount)
            const expenseCategoriesData = {};
            const currentExpenseEntries = Array.isArray(expenseEntries) ? expenseEntries : [];

            currentExpenseEntries.forEach(entry => {
                const category = entry.category || translations[currentLanguage]["unknown_category"];
                expenseCategoriesData[category] = (expenseCategoriesData[category] || 0) + parseFloat(entry.amount || 0);
            });
            const expenseCatLabels = Object.keys(expenseCategoriesData);
            const expenseCatData = Object.values(expenseCategoriesData);

            const expenseCategoryCtx = document.getElementById('expense-category-chart')?.getContext('2d');
            if (!expenseCategoryCtx) {
                console.error("Canvas context for expense-category-chart not found.");
                return;
            }
            if (expenseCategoryChart) expenseCategoryChart.destroy();
            expenseCategoryChart = new Chart(expenseCategoryCtx, {
                type: 'bar', // Use Bar chart for distribution
                data: {
                    labels: expenseCatData.length > 0 ? expenseCatLabels : [translations[currentLanguage]["no_expense_data"]],
                    datasets: [{
                        label: translations[currentLanguage]["total_amount"],
                        data: expenseCatData.length > 0 ? expenseCatData : [0],
                        backgroundColor: expenseCatData.length > 0
                            ? ['rgba(220, 53, 69, 0.8)', 'rgba(28, 28, 28, 0.8)', 'rgba(0, 123, 255, 0.8)', 'rgba(108, 117, 125, 0.8)', 'rgba(255, 193, 7, 0.8)']
                            : ['#cccccc'],
                        borderColor: expenseCatData.length > 0
                            ? ['rgba(220, 53, 69, 1)', 'rgba(28, 28, 28, 1)', 'rgba(0, 123, 255, 1)', 'rgba(108, 117, 125, 1)', 'rgba(255, 193, 7, 1)']
                            : ['#cccccc'],
                        borderWidth: 1
                    }]
                },
                options: {
                    indexAxis: 'y', // Horizontal bar chart
                    responsive: true,
                    maintainAspectRatio: false, // Allows chart to fill container height
                    plugins: {
                        title: { display: true, text: translations[currentLanguage]["expense_category_distribution_total"], color: isDarkMode ? 'white' : '#495057', font: { size: 14 } },
                        legend: { display: false },
                    },
                    scales: {
                        y: { ticks: { color: isDarkMode ? 'white' : '#495057' }, grid: { color: isDarkMode ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)' } },
                        x: { ticks: { color: isDarkMode ? 'white' : '#495057' }, grid: { color: isDarkMode ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)' } }
                    }
                }
            });

            // Add to translations
            translations.en.expense_category_distribution_total = 'Expense Category Distribution (Total Amount)';
            translations.my.expense_category_distribution_total = 'အသုံးစရိတ်အမျိုးအစား ဖြန့်ဖြူးမှု (စုစုပေါင်း ပမာဏ)';
            translations.en.unknown_category = 'Unknown Category';
            translations.my.unknown_category = 'မသိရှိသော အမျိုးအစား';
            translations.en.no_expense_data = 'No Expense Data';
            translations.my.no_expense_data = 'အသုံးစရိတ် ဒေတာ မရှိပါ';
        }

        // --- OPENING BALANCE TAB FUNCTIONS ---
        function saveOpeningBalances() {
            const date = document.getElementById('opening-date').value;
            if (!date) {
                showToast(translations[currentLanguage]["select_date_opening_balance"], 'error');
                return;
            }
            const eMoney = parseFloat(document.getElementById('opening-emoney').value.replace(/,/g, '')) || 0;
            const cash = parseFloat(document.getElementById('opening-cash').value.replace(/,/g, '')) || 0;

            dailyOpeningBalances[date] = { eMoney, cash };
            try {
                localStorage.setItem('moneyManager_dailyOpeningBalances', JSON.stringify(dailyOpeningBalances));
                showToast(`${translations[currentLanguage]["opening_balances_saved_for"]} ${date}!`, 'success');
            } catch (e) {
                console.error("Error saving daily opening balances:", e);
                showToast(translations[currentLanguage]["error_saving_opening_balances"], 'error');
            }
            document.getElementById('opening-emoney').value = '';
            document.getElementById('opening-cash').value = '';
            updateTransactionTabBalances();
        }

        // Add to translations
        translations.en.select_date_opening_balance = 'Please select a date for the opening balance.';
        translations.my.select_date_opening_balance = 'ဖွင့်လှစ်ချင်း လက်ကျန်အတွက် နေ့စွဲကို ရွေးပါ။';
        translations.en.opening_balances_saved_for = 'Opening balances saved for';
        translations.my.opening_balances_saved_for = 'ဖွင့်လှစ်ချင်း လက်ကျန်များကို သိမ်းဆည်းပြီး';
        translations.en.error_saving_opening_balances = 'Error saving opening balances';
        translations.my.error_saving_opening_balances = 'ဖွင့်လှစ်ချင်း လက်ကျန်များကို သိမ်းဆည်းရာတွင် အမှားဖြစ်ပွားပါသည်';

        // --- BACKUP FUNCTIONS ---
        function generateBackup() {
            const backupData = {
                transactions: transactions, moneyRecords: moneyRecords, dailyOpeningBalances: dailyOpeningBalances,
                savedOtherTransactionTypes: savedOtherTransactionTypes, savedOtherMoneyTypes: savedOtherMoneyTypes,
                tempCommissionData: tempCommissionData, debts: debts, expenseEntries: expenseEntries,
                savedExpenseCategories: savedExpenseCategories, isScreenLockEnabled: isScreenLockEnabled,
                appPIN: settingsPIN, permanentlyLocked: permanentlyLocked
            };
            document.getElementById('backup-data').value = JSON.stringify(backupData, null, 2);
            showToast(translations[currentLanguage]["backup_generated"]);
        }

        // Add to translations
        translations.en.backup_generated = 'Backup data generated!';
        translations.my.backup_generated = 'အရန်ကူးယူ ဒေတာ ဖန်တီးပြီး!';

        function restoreBackup() {
            if (!confirm(translations[currentLanguage]["confirm_restore_backup"])) return;

            try {
                const backupText = document.getElementById('backup-data').value;
                if (!backupText.trim()) { showToast(translations[currentLanguage]["no_backup_data"], "error"); return; }

                let backupData = JSON.parse(backupText);
                if (!backupData.transactions || !backupData.moneyRecords || !backupData.dailyOpeningBalances || !backupData.debts || !backupData.expenseEntries || !backupData.savedExpenseCategories) {
                    showToast(translations[currentLanguage]["invalid_backup_format"], "error"); return;
                }

                // Merge Data
                transactions = [...backupData.transactions.filter(bt => !transactions.some(at => at.id === bt.id)), ...transactions];
                moneyRecords = [...backupData.moneyRecords.filter(bmr => !moneyRecords.some(amr => amr.date === bmr.date && amr.amount === bmr.amount && amr.action === bmr.action)), ...moneyRecords];
                dailyOpeningBalances = { ...backupData.dailyOpeningBalances, ...dailyOpeningBalances };
                savedOtherTransactionTypes = { ...backupData.savedOtherTransactionTypes, ...savedOtherTransactionTypes };
                savedOtherMoneyTypes = { ...backupData.savedOtherMoneyTypes, ...savedOtherMoneyTypes };
                tempCommissionData = { ...backupData.tempCommissionData, ...tempCommissionData };
                debts = [...backupData.debts.filter(bd => !debts.some(ad => ad.id === bd.id)), ...debts];
                expenseEntries = [...backupData.expenseEntries.filter(be => !expenseEntries.some(ae => ae.id === be.id)), ...expenseEntries];
                savedExpenseCategories = { ...backupData.savedExpenseCategories, ...savedExpenseCategories };

                // Restore security settings
                if (backupData.isScreenLockEnabled !== undefined) {
                    isScreenLockEnabled = backupData.isScreenLockEnabled;
                    localStorage.setItem('moneyManager_isScreenLockEnabled', isScreenLockEnabled);
                    document.getElementById('enable-screen-lock').checked = isScreenLockEnabled;
                }
                if (backupData.appPIN) { settingsPIN = backupData.appPIN; localStorage.setItem('moneyManager_appPIN', settingsPIN); }
                if (backupData.permanentlyLocked === true) {
                    permanentlyLocked = true; localStorage.setItem('moneyManager_permanentlyLocked', 'true');
                }

                // Re-save all merged data
                saveData();
                updateSummariesBasedOnCurrentView(); updateTransactionList(); updateMoneyList();
                renderDebts(); populateCustomTypes(); populateExpenseCategories();
                renderExpenseEntries();
                document.getElementById('opening-emoney').value = '';
                document.getElementById('opening-cash').value = '';
                initializeLockScreen(); // Re-initialize lock screen

                showToast(translations[currentLanguage]["data_merged_success"], 'success');
            } catch (e) {
                console.error("Error restoring backup:", e);
                showToast(translations[currentLanguage]["invalid_backup_or_error"], 'error');
            }
        }

        // Add to translations
        translations.en.confirm_restore_backup = 'This action will merge your existing data with the data from the text area. Continue?';
        translations.my.confirm_restore_backup = 'ဤလုပ်ဆောင်ချက်သည် သင့်ရှိပြီးသားဒေတာကို စာသားဧရိယာမှ ဒေတာနှင့် ပေါင်းစည်းမည်။ ဆက်လက်ပါမလား?';
        translations.en.no_backup_data = 'No backup data found in the text area';
        translations.my.no_backup_data = 'စာသားဧရိယာတွင် အရန်ကူးယူ ဒေတာ မတွေ့ပါ';
        translations.en.invalid_backup_format = 'Invalid backup data format (missing essential fields)';
        translations.my.invalid_backup_format = 'မမှန်ကန်သော အရန်ကူးယူ ဒေတာ ပုံစံ (အဓိက အကွက်များ မရှိပါ)';
        translations.en.data_merged_success = 'Data merged successfully from text!';
        translations.my.data_merged_success = 'စာသားမှ ဒေတာ အောင်မြင်စွာ ပေါင်းစည်းပြီး!';
        translations.en.invalid_backup_or_error = 'Invalid backup data format or error during restore';
        translations.my.invalid_backup_or_error = 'မမှန်ကန်သော အရန်ကူးယူ ဒေတာ ပုံစံ သို့မဟုတ် ပြန်လည်ရယူရာတွင် အမှားဖြစ်ပွားပါသည်';

        function generateBackupFile() {
            const backupData = {
                transactions: transactions, moneyRecords: moneyRecords, dailyOpeningBalances: dailyOpeningBalances,
                savedOtherTransactionTypes: savedOtherTransactionTypes, savedOtherMoneyTypes: savedOtherMoneyTypes,
                tempCommissionData: tempCommissionData, debts: debts, expenseEntries: expenseEntries,
                savedExpenseCategories: savedExpenseCategories, isScreenLockEnabled: isScreenLockEnabled,
                appPIN: settingsPIN, permanentlyLocked: permanentlyLocked
            };

            const dataStr = JSON.stringify(backupData, null, 2);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);

            const link = document.createElement('a');
            link.href = url;
            link.download = `MoneyManager_Backup_${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(link);
            link.click();

            URL.revokeObjectURL(url);
            link.remove();
            showToast(translations[currentLanguage]["backup_file_generated"]);
        }

        // Add to translations
        translations.en.backup_file_generated = 'Backup file generated!';
        translations.my.backup_file_generated = 'အရန်ကူးယူ ဖိုင် ဖန်တီးပြီး!';

        function restoreFromFile(event) {
            const file = event.target.files[0];
            if (!file) return;
            if (file.type !== 'application/json' && !file.name.toLowerCase().endsWith('.json')) {
                showToast(translations[currentLanguage]["invalid_file_type"], 'error');
                event.target.value = ''; return;
            }
            if (!confirm(`${translations[currentLanguage]["confirm_merge_from_file"]} "${file.name}". ${translations[currentLanguage]["continue"]} ?`)) {
                event.target.value = ''; return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const backupData = JSON.parse(e.target.result);
                    if (!backupData.transactions || !backupData.moneyRecords || !backupData.dailyOpeningBalances || !backupData.debts || !backupData.expenseEntries || !backupData.savedExpenseCategories) {
                        showToast(translations[currentLanguage]["invalid_backup_file_format"], 'error'); return;
                    }

                    // Merge Data
                    transactions = [...backupData.transactions.filter(bt => !transactions.some(at => at.id === bt.id)), ...transactions];
                    moneyRecords = [...backupData.moneyRecords.filter(bmr => !moneyRecords.some(amr => amr.date === bmr.date && amr.amount === bmr.amount && amr.action === bmr.action)), ...moneyRecords];
                    dailyOpeningBalances = { ...backupData.dailyOpeningBalances, ...dailyOpeningBalances };
                    savedOtherTransactionTypes = { ...backupData.savedOtherTransactionTypes, ...savedOtherTransactionTypes };
                    savedOtherMoneyTypes = { ...backupData.savedOtherMoneyTypes, ...savedOtherMoneyTypes };
                    tempCommissionData = { ...backupData.tempCommissionData, ...tempCommissionData };
                    debts = [...backupData.debts.filter(bd => !debts.some(ad => ad.id === bd.id)), ...debts];
                    expenseEntries = [...backupData.expenseEntries.filter(be => !expenseEntries.some(ae => ae.id === be.id)), ...expenseEntries];
                    savedExpenseCategories = { ...backupData.savedExpenseCategories, ...savedExpenseCategories };

                    // Restore security settings
                    if (backupData.isScreenLockEnabled !== undefined) {
                        isScreenLockEnabled = backupData.isScreenLockEnabled;
                        localStorage.setItem('moneyManager_isScreenLockEnabled', isScreenLockEnabled);
                        document.getElementById('enable-screen-lock').checked = isScreenLockEnabled;
                    }
                    if (backupData.appPIN) { settingsPIN = backupData.appPIN; localStorage.setItem('moneyManager_appPIN', settingsPIN); }
                    if (backupData.permanentlyLocked === true) {
                        permanentlyLocked = true; localStorage.setItem('moneyManager_permanentlyLocked', 'true');
                    }

                    saveData(); // Re-save all merged data
                    updateSummariesBasedOnCurrentView(); updateTransactionList(); updateMoneyList();
                    renderDebts(); populateCustomTypes(); populateExpenseCategories();
                    renderExpenseEntries();
                    document.getElementById('opening-emoney').value = '';
                    document.getElementById('opening-cash').value = '';
                    initializeLockScreen(); // Re-initialize lock screen

                    showToast(translations[currentLanguage]["data_merged_from_file"], 'success');
                } catch (e) {
                    console.error("Error parsing backup file:", e);
                    showToast(translations[currentLanguage]["error_parsing_backup"], 'error');
                } finally {
                    event.target.value = ''; // Clear file input
                }
            };
            reader.onerror = function() {
                console.error("Error reading file:", reader.error);
                showToast(translations[currentLanguage]["error_reading_file"], 'error');
                event.target.value = '';
            };
            reader.readAsText(file);
        }

        // Add to translations
        translations.en.invalid_file_type = 'Invalid file type. Please select a .json file.';
        translations.my.invalid_file_type = 'မမှန်ကန်သော ဖိုင်အမျိုးအစား။ .json ဖိုင်ကို ရွေးပါ။';
        translations.en.confirm_merge_from_file = 'This action will merge your existing data with the data from';
        translations.my.confirm_merge_from_file = 'ဤလုပ်ဆောင်ချက်သည် သင့်ရှိပြီးသားဒေတာကို ဒေတာမှ';
        translations.en.continue = 'Continue';
        translations.my.continue = 'ဆက်လုပ်ပါ';
        translations.en.invalid_backup_file_format = 'Invalid backup file format (missing essential fields)';
        translations.my.invalid_backup_file_format = 'မမှန်ကန်သော အရန်ကူးယူ ဖိုင်ပုံစံ (အဓိက အကွက်များ မရှိပါ)';
        translations.en.data_merged_from_file = 'Data merged successfully from file!';
        translations.my.data_merged_from_file = 'ဖိုင်မှ ဒေတာ အောင်မြင်စွာ ပေါင်းစည်းပြီး!';
        translations.en.error_parsing_backup = 'Error reading or parsing backup file';
        translations.my.error_parsing_backup = 'အရန်ကူးယူ ဖိုင်ကို ဖတ်ရန် သို့မဟုတ် ခွဲခြမ်းရန် အမှားဖြစ်ပွားပါသည်';
        translations.en.error_reading_file = 'Error reading file';
        translations.my.error_reading_file = 'ဖိုင်ဖတ်ရန် အမှားဖြစ်ပွားပါသည်';

        // --- TRANSACTION TAB FUNCTIONS ---
        function updateTransactionType() {
            const typeSelect = document.getElementById('transaction-type');
            const otherInput = document.getElementById('transaction-type-other');
            const removeButton = document.querySelector('#transaction-type + input[type="text"] + button');

            otherInput.style.display = typeSelect.value === 'other' ? 'block' : 'none';
            if (removeButton) removeButton.style.display = typeSelect.value === 'other' ? 'inline-block' : 'none';

            if (typeSelect.value === 'other') {
                if (otherInput.style.display === 'block' && document.activeElement !== otherInput) otherInput.focus();
            } else {
                otherInput.value = '';
            }
            updateSavedCommissionAndFee();
        }

        function removeCustomTransactionType() {
            const typeSelect = document.getElementById('transaction-type');
            const otherInput = document.getElementById('transaction-type-other');
            const customTypeValue = otherInput.value.trim();

            if (customTypeValue && removeCustomOption('transaction-type', customTypeValue, 'moneyManager_savedOtherTransactionTypes')) {
                typeSelect.value = 'Wave Money'; // Reset to default
                updateTransactionType();
            } else if (!customTypeValue) {
                showToast(translations[currentLanguage]["no_custom_type_to_remove"], "warning");
            } else {
                showToast(translations[currentLanguage]["failed_remove_custom_type"], "error");
            }
        }

        // Add to translations
        translations.en.no_custom_type_to_remove = "No custom type entered to remove.";
        translations.my.no_custom_type_to_remove = "ဖယ်ရှားရန် ကိုယ်တိုင်အမျိုးအစားကို မထည့်ရသေးပါ။";
        translations.en.failed_remove_custom_type = "Failed to remove custom type.";
        translations.my.failed_remove_custom_type = "ကိုယ်တိုင်အမျိုးအစားကို ဖယ်ရှားရန် မအောင်မြင်ပါ။";

        function updateSavedCommissionAndFee() {
            const type = document.getElementById('transaction-type').value;
            const typeOtherInput = document.getElementById('transaction-type-other');
            const typeOther = typeOtherInput.value.trim();
            const effectiveType = (type === 'other' && typeOther) ? typeOther : type;

            const action = document.getElementById('transaction-action').value;
            const amountStr = document.getElementById('transaction-amount').value.replace(/,/g, '');
            const amount = parseFloat(amountStr) || 0;

            const commissionInput = document.getElementById('transaction-commission');
            const feeInput = document.getElementById('transaction-fee');

            if (effectiveType && action && amount > 0) {
                const key = `${effectiveType}-${action}-${amount}`;
                const savedData = tempCommissionData[key];

                if (savedData) {
                    if (commissionInput.value === '' || parseFloat(commissionInput.value.replace(/,/g, '')) === 0) {
                        commissionInput.value = savedData.commission !== undefined && savedData.commission !== null ? formatNumber(savedData.commission) : '';
                    }
                    if (feeInput.value === '' || parseFloat(feeInput.value.replace(/,/g, '')) === 0) {
                         feeInput.value = savedData.fee !== undefined && savedData.fee !== null ? formatNumber(savedData.fee) : '';
                    }
                } else {
                    // Clear if no saved data and input is empty or zero
                    if (commissionInput.value === '' || parseFloat(commissionInput.value.replace(/,/g, '')) === 0) commissionInput.value = '';
                    if (feeInput.value === '' || parseFloat(feeInput.value.replace(/,/g, '')) === 0) feeInput.value = '';
                }
            } else {
                // Clear inputs if criteria not met
                if (commissionInput.value === '' || parseFloat(commissionInput.value.replace(/,/g, '')) === 0) commissionInput.value = '';
                if (feeInput.value === '' || parseFloat(feeInput.value.replace(/,/g, '')) === 0) feeInput.value = '';
            }
        }

        function saveCommissionAndFee(type, action, amount, commission, fee) {
            if (type && action && !isNaN(amount) && amount > 0 && !isNaN(commission) && !isNaN(fee)) {
                const key = `${type}-${action}-${amount}`;
                if (!tempCommissionData[key] || tempCommissionData[key].commission !== commission || tempCommissionData[key].fee !== fee) {
                    tempCommissionData[key] = { commission, fee };
                    try { localStorage.setItem('moneyManager_tempCommissionData', JSON.stringify(tempCommissionData)); } catch (e) { console.error("Error saving tempCommissionData:", e); }
                }
            }
        }

        function saveFeeTemporarily() {
            const type = document.getElementById('transaction-type').value;
            const typeOtherInput = document.getElementById('transaction-type-other');
            const typeOther = typeOtherInput.value.trim();
            const effectiveType = (type === 'other' && typeOther) ? typeOther : type;

            const action = document.getElementById('transaction-action').value;
            const amountStr = document.getElementById('transaction-amount').value;
            const amount = parseFloat(amountStr.replace(/,/g, ''));

            const commissionStr = document.getElementById('transaction-commission').value;
            const commission = commissionStr ? parseFloat(commissionStr.replace(/,/g, '')) : 0;

            const feeStr = document.getElementById('transaction-fee').value;
            const fee = feeStr ? parseFloat(feeStr.replace(/,/g, '')) : 0;

            if (effectiveType && action && !isNaN(amount) && amount > 0 && !isNaN(commission) && !isNaN(fee)) {
                saveCommissionAndFee(effectiveType, action, amount, commission, fee);
            }
        }

        function addTransaction() {
            const id = document.getElementById('transaction-id').value.trim();
            const date = document.getElementById('transaction-date').value;
            let type = document.getElementById('transaction-type').value;
            const otherInput = document.getElementById('transaction-type-other');
            let finalType = type;

            if (type === 'other') {
                const customType = otherInput.value.trim();
                if (!customType) { showToast(translations[currentLanguage]["specify_other_transaction_type"], 'error'); return; }
                finalType = customType;
                if (!savedOtherTransactionTypes[finalType]) {
                    savedOtherTransactionTypes[finalType] = finalType;
                    try { localStorage.setItem('moneyManager_savedOtherTransactionTypes', JSON.stringify(savedOtherTransactionTypes)); } catch (e) { console.error("Error saving custom transaction type:", e); }
                    addOptionToSelect('transaction-type', finalType);
                }
            }

            const action = document.getElementById('transaction-action').value;
            const amount = parseFloat(document.getElementById('transaction-amount').value.replace(/,/g, ''));
            const commission = document.getElementById('transaction-commission').value ? parseFloat(document.getElementById('transaction-commission').value.replace(/,/g, '')) : 0;
            const fee = document.getElementById('transaction-fee').value ? parseFloat(document.getElementById('transaction-fee').value.replace(/,/g, '')) : 0;
            let phone = document.getElementById('transaction-phone').value.trim();
            if (phone) phone = '09' + phone.replace(/^09/, ''); // Ensure it starts with 09 and doesn't have duplicates
            const note = document.getElementById('transaction-note').value.trim();

            // Validation
            if (!id) { showToast(translations[currentLanguage]["transaction_id_required"], 'error'); return; }
            if (!date) { showToast(translations[currentLanguage]["date_time_required"], 'error'); return; }
            if (!finalType) { showToast(translations[currentLanguage]["transaction_type_required"], 'error'); return; }
            if (!action) { showToast(translations[currentLanguage]["action_required"], 'error'); return; }
            if (isNaN(amount) || amount <= 0) { showToast(translations[currentLanguage]["amount_positive"], 'error'); return; }
            if (isNaN(commission) || commission < 0) { showToast(translations[currentLanguage]["commission_non_negative"], 'error'); return; }
            if (isNaN(fee) || fee < 0) { showToast(translations[currentLanguage]["fee_non_negative"], 'error'); return; }

            // Check for ID conflict BEFORE adding, only if we are not editing
            if (!isEditingTransaction && transactions.some(t => t.id === id)) {
                showToast(translations[currentLanguage]["transaction_id_exists"], 'error');
                return;
            }

            const effectiveTypeForSave = (type === 'other' && otherInput.value.trim()) ? otherInput.value.trim() : type;
            saveCommissionAndFee(effectiveTypeForSave, action, amount, commission, fee);

            const transaction = { id, date, type: finalType, action, amount, commission, fee, phone, note };

            // If we were editing, the original transaction was removed in editTransaction().
            // Now we add the updated one. If not editing, we just add a new one.
            transactions.unshift(transaction); // Add to beginning for chronological order or recent display

            try {
                localStorage.setItem('moneyManager_transactions', JSON.stringify(transactions));
                showToast(translations[currentLanguage]["transaction_added_success"], 'success');
            } catch (e) {
                console.error("Error saving transactions:", e);
                showToast(translations[currentLanguage]["error_saving_transaction"], 'error');
            }

            // Reset the editing state after successful addition
            isEditingTransaction = false;
            transactionBeingEdited = null;

            updateSummariesBasedOnCurrentView(); updateTransactionList(); clearTransactionForm();
            // Redraw charts if transaction tab is active
            if (document.getElementById('transaction').classList.contains('active')) {
                drawTransactionCharts();
            }
        }

        // Add to translations
        translations.en.specify_other_transaction_type = 'Please specify the other transaction type';
        translations.my.specify_other_transaction_type = 'အခြားငွေလွှဲမှုအမျိုးအစားကို သတ်မှတ်ပါ';
        translations.en.transaction_id_required = 'Transaction ID is required.';
        translations.my.transaction_id_required = 'ငွေလွှဲမှု ID လိုအပ်ပါသည်။';
        translations.en.date_time_required = 'Date/Time is required.';
        translations.my.date_time_required = 'နေ့စွဲ/အချိန် လိုအပ်ပါသည်။';
        translations.en.transaction_type_required = 'Transaction Type is required.';
        translations.my.transaction_type_required = 'ငွေလွှဲမှုအမျိုးအစား လိုအပ်ပါသည်။';
        translations.en.action_required = 'Action is required.';
        translations.my.action_required = 'လုပ်ဆောင်ချက် လိုအပ်ပါသည်။';
        translations.en.amount_positive = 'Amount must be a positive number.';
        translations.my.amount_positive = 'ပမာဏသည် အပေါင်းဂဏန်း ဖြစ်ရမည်။';
        translations.en.commission_non_negative = 'Commission must be a non-negative number.';
        translations.my.commission_non_negative = 'ကော်မရှင်သည် အပျက်မဟုတ်သော ဂဏန်း ဖြစ်ရမည်။';
        translations.en.fee_non_negative = 'Fee must be a non-negative number.';
        translations.my.fee_non_negative = 'ကောက်ခံသည် အပျက်မဟုတ်သော ဂဏန်း ဖြစ်ရမည်။';
        translations.en.transaction_id_exists = 'Transaction ID already exists. Please use a unique ID.';
        translations.my.transaction_id_exists = 'ငွေလွှဲမှု ID ရှိနေပါပြီ။ ထူးခြားသော ID ကို အသုံးပြုပါ။';
        translations.en.transaction_added_success = 'Transaction added successfully!';
        translations.my.transaction_added_success = 'ငွေလွှဲမှု အောင်မြင်စွာ ထည့်ပြီး!';
        translations.en.error_saving_transaction = 'Error saving transaction';
        translations.my.error_saving_transaction = 'ငွေလွှဲမှုကို သိမ်းဆည်းရာတွင် အမှားဖြစ်ပွားပါသည်';

        // Function to handle "Cancel" action during editing or clearing the form
        function cancelEditTransaction() {
            if (isEditingTransaction) {
                // If we are in edit mode, we need to restore the transaction that was removed.
                if (transactionBeingEdited) {
                    // Re-add the transaction to the transactions array.
                    // We add it to the beginning for simplicity. A more robust solution would re-insert at original index.
                    transactions.unshift(transactionBeingEdited);
                    try {
                        localStorage.setItem('moneyManager_transactions', JSON.stringify(transactions));
                    } catch (e) { console.error("Error saving transactions after cancel edit:", e); }

                    showToast(translations[currentLanguage]["edit_cancelled"], 'warning');
                } else {
                    // Fallback if transactionBeingEdited is somehow null but editing was true
                    showToast(translations[currentLanguage]["edit_cancelled_error"], 'warning');
                }

                // Reset all relevant states
                isEditingTransaction = false;
                transactionBeingEdited = null; // Clear the stored transaction
                updateSummariesBasedOnCurrentView(); // Update summaries to reflect the restored transaction
                updateTransactionList(); // Re-render the list with the restored transaction
                clearTransactionForm(); // Clear the form fields
            } else {
                // If not editing, this acts like a regular clear form.
                clearTransactionForm();
            }
        }

        // Add to translations
        translations.en.edit_cancelled = 'Edit cancelled. Changes discarded.';
        translations.my.edit_cancelled = 'တည်းဖြတ်မှု ပယ်ဖျက်ပြီး။ ပြောင်းလဲမှုများကို မလုပ်တော့ပါ။';
        translations.en.edit_cancelled_error = 'Edit cancelled, but an error occurred restoring data.';
        translations.my.edit_cancelled_error = 'တည်းဖြတ်မှု ပယ်ဖျက်ပြီး၊ ဒေတာ ပြန်လည်ရယူရာတွင် အမှားဖြစ်ပွားပါသည်။';

        function getBalanceAtEndOfDay(targetDateStr) {
            const allDatesSet = new Set();
            Object.keys(dailyOpeningBalances).forEach(d => {
                if (d <= targetDateStr) allDatesSet.add(d);
            });
            transactions.forEach(t => {
                const d = new Date(t.date).toISOString().split('T')[0];
                if (d <= targetDateStr) allDatesSet.add(d);
            });
            moneyRecords.forEach(r => {
                const d = new Date(r.date).toISOString().split('T')[0];
                if (d <= targetDateStr) allDatesSet.add(d);
            });
            expenseEntries.forEach(e => {
                const d = new Date(e.date).toISOString().split('T')[0];
                if (d <= targetDateStr) allDatesSet.add(d);
            });

            const sortedDates = Array.from(allDatesSet).sort((a, b) => a.localeCompare(b));

            let currentEMoney = 0;
            let currentCash = 0;

            sortedDates.forEach(day => {
                if (dailyOpeningBalances[day]) {
                    currentEMoney = dailyOpeningBalances[day].eMoney;
                    currentCash = dailyOpeningBalances[day].cash;
                }

                // Apply transactions on that day
                transactions.forEach(t => {
                    const tDay = new Date(t.date).toISOString().split('T')[0];
                    if (tDay === day) {
                        const amount = parseFloat(t.amount);
                        const commission = parseFloat(t.commission) || 0;
                        const fee = parseFloat(t.fee) || 0;

                        if (t.action === 'Cash In') {
                            currentEMoney -= amount;
                            currentCash += amount;
                        } else if (t.action === 'Cash Out') {
                            currentEMoney += amount;
                            currentCash -= amount;
                        } else if (['Send Money', 'Payment', 'Phone Bill'].includes(t.action)) {
                            currentEMoney -= amount;
                            currentCash += amount;
                        } else if (t.action === 'Received Money') {
                            currentEMoney += amount;
                            currentCash -= amount;
                        }
                        currentEMoney += commission;
                        currentCash += fee;
                    }
                });

                // Apply money records on that day
                moneyRecords.forEach(r => {
                    const rDay = new Date(r.date).toISOString().split('T')[0];
                    if (rDay === day) {
                        const amount = parseFloat(r.amount);
                        const commission = parseFloat(r.commission) || 0;
                        if (r.action === 'Emoney In') {
                            currentEMoney += amount;
                            currentCash += commission; // Assuming commission goes to cash
                        } else if (r.action === 'Emoney Out') {
                            currentEMoney -= amount;
                        } else if (r.action === 'Cash In') {
                            currentCash += amount;
                        } else if (r.action === 'Cash Out') {
                            currentCash -= amount;
                        }
                    }
                });

                // Apply expense entries on that day
                expenseEntries.forEach(e => {
                    const eDay = new Date(e.date).toISOString().split('T')[0];
                    if (eDay === day) {
                        const amount = parseFloat(e.amount);
                        const sign = e.type === 'Expense' ? -1 : 1;
                        if (e.paymentMethod === 'E-Money') {
                            currentEMoney += sign * amount;
                        } else if (e.paymentMethod === 'Cash') {
                            currentCash += sign * amount;
                        } // Ignore 'Other'
                    }
                });
            });

            return { eMoney: currentEMoney, cash: currentCash };
        }

        function updateTransactionTabBalances() {
            const dateFilterValue = document.getElementById('transaction-filter-date').value;
            const selectedDay = dateFilterValue || new Date().toISOString().split('T')[0];
            const balances = getBalanceAtEndOfDay(selectedDay);
            document.getElementById('e-money-balance').innerHTML = formatNumber(balances.eMoney) + getIndicatorEmoji(balances.eMoney);
            document.getElementById('cash-balance').innerHTML = formatNumber(balances.cash) + getIndicatorEmoji(balances.cash);
            document.getElementById('total-balance').textContent = formatNumber(balances.eMoney + balances.cash);
            document.getElementById('profit').textContent = formatNumber(calculateTotalProfit());
        }

        function calculateTotalProfit() {
            let totalProfit = 0;
            transactions.forEach(t => {
                totalProfit += (parseFloat(t.commission) || 0) + (parseFloat(t.fee) || 0);
            });
            return totalProfit;
        }

        function getIndicatorEmoji(amount) {
            if (amount > 1000000) return ' ⚪';
            else if (amount >= 500000) return ' 🟢';
            else if (amount >= 300000) return ' 🟡';
            else return ' 🔴';
        }

        function updateTransactionList(filteredTransactions = null) {
            const listContainer = document.querySelector('#transaction-list .transaction-list-items');
            const transactionsToShow = filteredTransactions !== null ? filteredTransactions : transactions;

            listContainer.innerHTML = '';
            if (transactionsToShow.length === 0) { listContainer.innerHTML += `<p class="no-data" data-i18n="no_transactions_found">ငွေလွှဲမှုများ မတွေ့ပါ။</p>`; return; }

            const groupedTransactions = {};
            transactionsToShow.forEach((transaction) => {
                // Find original index in the main transactions array for editing/deleting
                const originalIndex = transactions.findIndex(t => t.id === transaction.id && t.date === transaction.date);
                const dateKey = new Date(transaction.date).toISOString().split('T')[0];

                if (!groupedTransactions[dateKey]) {
                    groupedTransactions[dateKey] = {
                        items: [],
                        details: { emoneyChange: 0, cashChange: 0, totalCommission: 0, totalFee: 0 }
                    };
                }
                groupedTransactions[dateKey].items.push({ ...transaction, originalIndex: originalIndex });

                const amount = parseFloat(transaction.amount);
                const commission = parseFloat(transaction.commission);
                const fee = parseFloat(transaction.fee);

                if (transaction.action === 'Cash In') { groupedTransactions[dateKey].details.emoneyChange -= amount; groupedTransactions[dateKey].details.cashChange += amount; }
                else if (transaction.action === 'Cash Out') { groupedTransactions[dateKey].details.emoneyChange += amount; groupedTransactions[dateKey].details.cashChange -= amount; }
                else if (['Send Money', 'Payment', 'Phone Bill'].includes(transaction.action)) {
                    groupedTransactions[dateKey].details.emoneyChange -= amount; groupedTransactions[dateKey].details.cashChange += amount;
                } else if (transaction.action === 'Received Money') {
                    groupedTransactions[dateKey].details.emoneyChange += amount; groupedTransactions[dateKey].details.cashChange -= amount;
                }
                groupedTransactions[dateKey].details.totalCommission += commission;
                groupedTransactions[dateKey].details.totalFee += fee;
            });

            const sortedDates = Object.keys(groupedTransactions).sort().reverse();

            for (const dateKey of sortedDates) {
                const groupData = groupedTransactions[dateKey];
                const displayDate = new Date(dateKey).toDateString();
                const summary = groupData.details;

                const groupElement = document.createElement('div');
                groupElement.className = 'grouped-transaction';

                groupElement.innerHTML = `
                    <div class="group-header" onclick="toggleGroup(this.parentElement)">
                        <span>${displayDate}</span>
                        <span>E-Chg: ${formatNumber(summary.emoneyChange)} | C-Chg: ${formatNumber(summary.cashChange)} | Comm: ${formatNumber(summary.totalCommission)} | Fee: ${formatNumber(summary.totalFee)}</span>
                    </div>
                    <div class="group-details">
                        ${groupData.items.map(item => {
                            const amountClass = (item.action === 'Cash In' || item.action === 'Received Money') ? 'positive' : 'negative';
                            let detailsHtml = '';
                            if (item.commission > 0) detailsHtml += `<span class="transaction-info-item"><strong data-i18n="comm">Comm:</strong> ${formatNumber(item.commission)}</span>`;
                            if (item.fee > 0) detailsHtml += `<span class="transaction-info-item"><strong data-i18n="fee">Fee:</strong> ${formatNumber(item.fee)}</span>`;
                            if (item.phone) detailsHtml += `<span class="transaction-info-item"><strong data-i18n="phone">Phone:</strong> ${item.phone}</span>`;
                            if (item.note) {
                                const truncatedNote = item.note.length > 50 ? item.note.substring(0, 50) + '...' : item.note;
                                detailsHtml += `<span class="transaction-info-item"><strong data-i18n="note">Note:</strong> ${truncatedNote}</span>`;
                            }

                            return `
                                <div class="transaction-item" onclick="handleItemClick(event, this)">
                                    <div class="transaction-header">
                                        <span class="transaction-type">${item.type} - ${item.action}</span>
                                        <span class="transaction-amount ${amountClass}">${formatNumber(item.amount)}</span>
                                    </div>
                                    <div class="transaction-details-mobile">
                                        <span class="transaction-date">${new Date(item.date).toLocaleTimeString()}</span>
                                        <span class="transaction-info-item"><strong data-i18n="id">ID:</strong> ${item.id}</span>
                                        ${detailsHtml}
                                    </div>
                                    <div class="transaction-actions">
                                        <button class="action-button-text edit" onclick="editTransaction(${item.originalIndex})"><i class="fas fa-edit"></i></button>
                                        <button class="action-button-text delete" onclick="deleteTransaction(${item.originalIndex})"><i class="fas fa-trash-alt"></i></button>
                                    </div>
                                </div>
                            `;
                        }).join('')}
                    </div>
                `;
                listContainer.appendChild(groupElement);
            }
        }

        // Add to translations
        translations.en.no_transactions_found = 'No transactions found.';
        translations.my.no_transactions_found = 'ငွေလွှဲမှုများ မတွေ့ပါ။';
        translations.en.comm = 'Comm:';
        translations.my.comm = 'ကော်:';
        translations.en.id = 'ID:';
        translations.my.id = 'ID:';

        // Handles click events on list items to manage the 'hovered' state and show/hide actions
        function handleItemClick(event, itemElement) {
            // Prevent event bubbling to parent if clicking on an action button
            if (event.target.closest('.transaction-actions')) {
                event.stopPropagation();
                return;
            }

            // Toggle 'hovered' class on the clicked item
            itemElement.classList.toggle('hovered');

            // Remove 'hovered' class from all other transaction items within the same list
            const listContainer = itemElement.closest('.transaction-list-items');
            if (listContainer) {
                listContainer.querySelectorAll('.transaction-item').forEach(otherItem => {
                    if (otherItem !== itemElement && otherItem.classList.contains('hovered')) {
                        otherItem.classList.remove('hovered');
                    }
                });
            }
        }

        function editTransaction(index) {
            if (index < 0 || index >= transactions.length) { console.error("Invalid index for editTransaction:", index); showToast(translations[currentLanguage]["error_loading_transaction"], "error"); return; }
            const transaction = transactions[index];

            // Store the transaction being edited before removing it from the array
            transactionBeingEdited = { ...transaction, originalIndex: index };

            // Set the form values
            document.getElementById('transaction-id').value = transaction.id;
            document.getElementById('transaction-date').value = transaction.date;

            const typeSelect = document.getElementById('transaction-type');
            const otherInput = document.getElementById('transaction-type-other');
            const removeButton = document.querySelector('#transaction-type + input[type="text"] + button');

            // Handle custom transaction types
            if (transaction.type && (savedOtherTransactionTypes[transaction.type] || !['Wave Money', 'Wave Pay', 'KBZ Pay', 'Aya Pay'].includes(transaction.type))) {
                typeSelect.value = 'other';
                otherInput.value = transaction.type;
                otherInput.style.display = 'block';
                if (removeButton) removeButton.style.display = 'inline-block';
                if (!savedOtherTransactionTypes[transaction.type]) {
                    savedOtherTransactionTypes[transaction.type] = transaction.type;
                    try { localStorage.setItem('moneyManager_savedOtherTransactionTypes', JSON.stringify(savedOtherTransactionTypes)); } catch (e) { console.error("Error saving custom transaction type during edit:", e); }
                    addOptionToSelect('transaction-type', transaction.type);
                }
            } else if (transaction.type) {
                typeSelect.value = transaction.type;
                otherInput.style.display = 'none'; otherInput.value = '';
                if (removeButton) removeButton.style.display = 'none';
            } else {
                typeSelect.value = 'Wave Money'; // Default if type is missing
                otherInput.style.display = 'none'; otherInput.value = '';
                if (removeButton) removeButton.style.display = 'none';
            }

            document.getElementById('transaction-action').value = transaction.action;
            document.getElementById('transaction-amount').value = formatNumber(transaction.amount);
            document.getElementById('transaction-commission').value = transaction.commission ? formatNumber(transaction.commission) : '';
            document.getElementById('transaction-fee').value = transaction.fee ? formatNumber(transaction.fee) : '';

            if (transaction.phone && transaction.phone.startsWith('09')) document.getElementById('transaction-phone').value = transaction.phone.substring(2);
            else document.getElementById('transaction-phone').value = transaction.phone || '';

            document.getElementById('transaction-note').value = transaction.note || '';

            // Set the editing flag
            isEditingTransaction = true;

            // Temporarily remove the transaction from the array so it doesn't show in the list
            // while being edited.
            transactions.splice(index, 1);
            try {
                localStorage.setItem('moneyManager_transactions', JSON.stringify(transactions));
            } catch (e) { console.error("Error saving transactions after removing for edit:", e); }

            updateSummariesBasedOnCurrentView();
            updateTransactionList(); // Re-render the list without the item being edited
            showToast(translations[currentLanguage]["editing_transaction"]);
            window.scrollTo(0, 0); // Scroll to the top to see the form
        }

        // Add to translations
        translations.en.error_loading_transaction = 'Error loading transaction for editing.';
        translations.my.error_loading_transaction = 'ငွေလွှဲမှုကို တည်းဖြတ်ရန် ဖွင့်ရာတွင် အမှားဖြစ်ပွားပါသည်။';
        translations.en.editing_transaction = 'Editing transaction. Click Add to save or Cancel to discard.';
        translations.my.editing_transaction = 'ငွေလွှဲမှုကို တည်းဖြတ်နေပါသည်။ သိမ်းရန် ထည့်ပါ ကို နှိပ်ပါ သို့မဟုတ် ပယ်ဖျက်ရန် ပယ်ဖျက်ပါ ကို နှိပ်ပါ။';

        function deleteTransaction(index) {
            if (index < 0 || index >= transactions.length) { console.error("Invalid index for deleteTransaction:", index); showToast(translations[currentLanguage]["error_deleting_transaction"], "error"); return; }
            if (confirm(translations[currentLanguage]["confirm_delete_transaction"])) {
                transactions.splice(index, 1);
                try {
                    localStorage.setItem('moneyManager_transactions', JSON.stringify(transactions));
                    showToast(translations[currentLanguage]["transaction_deleted_success"], 'success');
                } catch (e) {
                    console.error("Error saving transactions after delete:", e);
                    showToast(translations[currentLanguage]["error_saving_after_deletion"], 'error');
                }
                updateSummariesBasedOnCurrentView(); updateTransactionList();
                // Redraw charts if transaction tab is active
                if (document.getElementById('transaction').classList.contains('active')) {
                    drawTransactionCharts();
                }
            }
        }

        // Add to translations
        translations.en.confirm_delete_transaction = 'Are you sure you want to delete this transaction?';
        translations.my.confirm_delete_transaction = 'ဤငွေလွှဲမှုကို ဖျက်ရန် သေချာပါသလား?';
        translations.en.transaction_deleted_success = 'Transaction deleted successfully';
        translations.my.transaction_deleted_success = 'ငွေလွှဲမှု ဖျက်ပြီး အောင်မြင်ပါသည်';
        translations.en.error_deleting_transaction = 'Error deleting transaction.';
        translations.my.error_deleting_transaction = 'ငွေလွှဲမှုကို ဖျက်ရန် အမှားဖြစ်ပွားပါသည်။';
        translations.en.error_saving_after_deletion = 'Error saving changes after deletion';
        translations.my.error_saving_after_deletion = 'ဖျက်ပြီးနောက် ပြောင်းလဲမှုများကို သိမ်းဆည်းရာတွင် အမှားဖြစ်ပွားပါသည်';

        function filterTransactions() {
            const typeFilter = document.getElementById('transaction-filter-type').value;
            const actionFilter = document.getElementById('transaction-filter-action').value;
            const dateFilterValue = document.getElementById('transaction-filter-date').value;

            let filtered = transactions;

            if (typeFilter !== 'all') filtered = filtered.filter(t => t.type === typeFilter);
            if (actionFilter !== 'all') filtered = filtered.filter(t => t.action === actionFilter);

            if (dateFilterValue) {
                try {
                    const filterDate = new Date(dateFilterValue);
                    filterDate.setHours(0, 0, 0, 0);
                    filtered = filtered.filter(t => {
                        const transactionDateTime = new Date(t.date);
                        if (isNaN(transactionDateTime.getTime())) return false;
                        return transactionDateTime.getFullYear() === filterDate.getFullYear() &&
                               transactionDateTime.getMonth() === filterDate.getMonth() &&
                               transactionDateTime.getDate() === filterDate.getDate();
                    });
                } catch (e) {
                    console.error("Error applying date filter:", e);
                    showToast(translations[currentLanguage]["error_applying_date_filter"], "error");
                    filtered = [];
                }
            }

            currentFilteredTransactions = filtered; // Store for summary updates
            updateTransactionList(filtered);
            updateSummariesBasedOnCurrentView();
        }

        // Add to translations
        translations.en.error_applying_date_filter = "Error applying date filter.";
        translations.my.error_applying_date_filter = 'နေ့စွဲ စစ်ထုတ်မှု အသုံးပြုရာတွင် အမှားဖြစ်ပွားပါသည်။';

        function resetTransactionFilters() {
            document.getElementById('transaction-filter-type').value = 'all';
            document.getElementById('transaction-filter-action').value = 'all';
            document.getElementById('transaction-filter-date').value = '';
            currentFilteredTransactions = [];
            updateTransactionList();
            updateSummariesBasedOnCurrentView();
        }

        // --- DAILY MONEYTAB FUNCTIONS ---
        function toggleCommissionField() {
            const action = document.getElementById('money-action').value;
            const commissionGroup = document.getElementById('money-commission-group');
            commissionGroup.style.display = (action === 'Emoney In') ? 'block' : 'none';
            if (action !== 'Emoney In') document.getElementById('money-commission').value = '';
        }

        function calculateMoneyCommission() {
            const action = document.getElementById('money-action').value;
            const commissionPercentInput = document.getElementById('money-commission');
            const commissionGroup = document.getElementById('money-commission-group');

            // Ensure the commission field is visible ONLY for 'Emoney In'
            if (action === 'Emoney In') {
                commissionGroup.style.display = 'block'; // Make the group visible
                let currentValue = commissionPercentInput.value;
                let cleanedValue = '';
                let dotFound = false;
                // Re-apply formatting if input already has content and it's not already formatted
                for (let i = 0; i < currentValue.length; i++) {
                    const char = currentValue[i];
                    if (char >= '0' && char <= '9') cleanedValue += char;
                    else if (char === '.' && !dotFound) { cleanedValue += '.'; dotFound = true; }
                }
                commissionPercentInput.value = cleanedValue; // Set the potentially cleaned value
            } else {
                 commissionPercentInput.value = ''; // Clear commission if action is not 'Emoney In'
                 commissionGroup.style.display = 'none'; // Hide the group
            }
        }

        function updateMoneyType() {
            const typeSelect = document.getElementById('money-type');
            const otherInput = document.getElementById('money-type-other');
            const removeButton = document.querySelector('#money-type + input[type="text"] + button');

            otherInput.style.display = typeSelect.value === 'other' ? 'block' : 'none';
            if (removeButton) removeButton.style.display = typeSelect.value === 'other' ? 'inline-block' : 'none';

            if (typeSelect.value === 'other') {
                if (otherInput.style.display === 'block' && document.activeElement !== otherInput) otherInput.focus();
            } else {
                otherInput.value = '';
            }
        }

        function removeCustomMoneyType() {
            const typeSelect = document.getElementById('money-type');
            const otherInput = document.getElementById('money-type-other');
            const customTypeValue = otherInput.value.trim();

            if (customTypeValue && removeCustomOption('money-type', customTypeValue, 'moneyManager_savedOtherMoneyTypes')) {
                typeSelect.value = 'Wave Money'; // Reset to default
                updateMoneyType();
            } else if (!customTypeValue) {
                showToast(translations[currentLanguage]["no_custom_type_to_remove"], "warning");
            } else {
                showToast(translations[currentLanguage]["failed_remove_custom_type"], "error");
            }
        }

        function addMoneyRecord() {
            const date = document.getElementById('money-date').value;
            const amount = parseFloat(document.getElementById('money-amount').value.replace(/,/g, ''));
            const action = document.getElementById('money-action').value;
            let type = document.getElementById('money-type').value;
            const otherInput = document.getElementById('money-type-other');
            let finalType = type;

            if (type === 'other') {
                const customType = otherInput.value.trim();
                if (!customType) { showToast(translations[currentLanguage]["specify_other_money_type"], 'error'); return; }
                finalType = customType;
                if (!savedOtherMoneyTypes[finalType]) {
                    savedOtherMoneyTypes[finalType] = finalType;
                    try { localStorage.setItem('moneyManager_savedOtherMoneyTypes', JSON.stringify(savedOtherMoneyTypes)); } catch (e) { console.error("Error saving custom money type:", e); }
                    addOptionToSelect('money-type', finalType);
                }
            }

            const commissionPercentage = parseFloat(document.getElementById('money-commission').value.replace(/,/g, ''));
            let actualCommission = 0;
            if (action === 'Emoney In' && !isNaN(amount) && amount > 0 && !isNaN(commissionPercentage) && commissionPercentage >= 0) {
                actualCommission = (amount * commissionPercentage) / 100;
            }

            const note = document.getElementById('money-note').value.trim();

            // Validation
            if (!date) { showToast(translations[currentLanguage]["date_time_required"], 'error'); return; }
            if (!finalType) { showToast(translations[currentLanguage]["type_required"], 'error'); return; }
            if (isNaN(amount) || amount <= 0) { showToast(translations[currentLanguage]["amount_positive"], 'error'); return; }

            const record = { date, amount, action, type: finalType, commission: actualCommission, note };
            moneyRecords.unshift(record);

            try {
                localStorage.setItem('moneyManager_moneyRecords', JSON.stringify(moneyRecords));
                showToast(translations[currentLanguage]["money_record_added_success"], 'success');
            } catch (e) {
                console.error("Error saving money records:", e);
                showToast(translations[currentLanguage]["error_saving_money_record"], 'error');
            }

            updateSummariesBasedOnCurrentView(); updateMoneyList(); clearMoneyForm();
            // Redraw charts if daily money tab is active
            if (document.getElementById('daily-money').classList.contains('active')) {
                drawDailyMoneyCharts();
            }
        }

        // Add to translations
        translations.en.specify_other_money_type = 'Please specify the other money record type';
        translations.my.specify_other_money_type = 'အခြားငွေ မှတ်တမ်း အမျိုးအစားကို သတ်မှတ်ပါ';
        translations.en.type_required = 'Type is required.';
        translations.my.type_required = 'အမျိုးအစား လိုအပ်ပါသည်။';
        translations.en.money_record_added_success = 'Money record added successfully!';
        translations.my.money_record_added_success = 'ငွေ မှတ်တမ်း အောင်မြင်စွာ ထည့်ပြီး!';
        translations.en.error_saving_money_record = 'Error saving money record';
        translations.my.error_saving_money_record = 'ငွေ မှတ်တမ်းကို သိမ်းဆည်းရာတွင် အမှားဖြစ်ပွားပါသည်';

        // Function to handle "Cancel" action during money record editing or clearing the form
        function cancelEditMoneyRecord() {
            if (isEditingMoneyRecord) {
                if (moneyRecordBeingEdited) {
                    moneyRecords.unshift(moneyRecordBeingEdited); // Re-add the record
                    try {
                        localStorage.setItem('moneyManager_moneyRecords', JSON.stringify(moneyRecords));
                    } catch (e) { console.error("Error saving money records after cancel edit:", e); }
                    showToast(translations[currentLanguage]["edit_cancelled"], 'warning');
                } else {
                    showToast(translations[currentLanguage]["edit_cancelled_error"], 'warning');
                }
                isEditingMoneyRecord = false;
                moneyRecordBeingEdited = null;
                updateSummariesBasedOnCurrentView();
                updateMoneyList();
                clearMoneyForm();
            } else {
                clearMoneyForm();
            }
        }

        function clearMoneyForm() {
            document.getElementById('money-amount').value = '';
            document.getElementById('money-action').value = 'Emoney In';
            document.getElementById('money-type').value = 'Wave Money';
            document.getElementById('money-type-other').value = ''; document.getElementById('money-type-other').style.display = 'none';
            const removeMoneyTypeButton = document.querySelector('#money-type + input[type="text"] + button');
            if(removeMoneyTypeButton) removeMoneyTypeButton.style.display = 'none'; // Hide remove button
            document.getElementById('money-commission').value = ''; document.getElementById('money-commission-group').style.display = 'none';
            document.getElementById('money-note').value = '';
            updateDateTimeFields();

            // Reset the editing flag if it was true but we are clearing without a specific cancel action
            isEditingMoneyRecord = false;
            moneyRecordBeingEdited = null;
        }

        function updateMoneyList(filteredRecords = null) {
            const listContainer = document.querySelector('#money-list .transaction-list-items');
            const recordsToShow = filteredRecords !== null ? filteredRecords : moneyRecords;

            listContainer.innerHTML = '';
            if (recordsToShow.length === 0) { listContainer.innerHTML += '<p class="no-data" data-i18n="no_money_records_found">No money records found.</p>'; return; }

            const groupedRecords = {};
            recordsToShow.forEach((record, index) => { // 'index' here is from filteredRecords, not original
                const dateKey = new Date(record.date).toISOString().split('T')[0];
                const originalIndex = moneyRecords.findIndex(r => r.date === record.date && r.amount === record.amount && r.action === record.action); // Find index in original array
                if (!groupedRecords[dateKey]) {
                    groupedRecords[dateKey] = {
                        items: [],
                        details: { emoneyIn: 0, emoneyOut: 0, cashIn: 0, cashOut: 0, commission: 0 }
                    };
                }
                groupedRecords[dateKey].items.push({ ...record, originalIndex: originalIndex });
                const recordAmount = parseFloat(record.amount);
                if (record.action === 'Emoney In') {
                    groupedRecords[dateKey].details.emoneyIn += recordAmount;
                    groupedRecords[dateKey].details.commission += parseFloat(record.commission);
                } else if (record.action === 'Emoney Out') { groupedRecords[dateKey].details.emoneyOut += recordAmount; }
                else if (record.action === 'Cash In') { groupedRecords[dateKey].details.cashIn += recordAmount; }
                else if (record.action === 'Cash Out') { groupedRecords[dateKey].details.cashOut += recordAmount; }
            });

            const sortedDates = Object.keys(groupedRecords).sort().reverse();

            for (const dateKey of sortedDates) {
                const groupData = groupedRecords[dateKey];
                const displayDate = new Date(dateKey).toDateString();
                const summary = groupData.details;

                const groupElement = document.createElement('div');
                groupElement.className = 'grouped-transaction';

                groupElement.innerHTML = `
                    <div class="group-header" onclick="toggleGroup(this.parentElement)">
                        <span>${displayDate}</span>
                        <span>E-In: ${formatNumber(summary.emoneyIn)} | E-Out: ${formatNumber(summary.emoneyOut)} | C-In: ${formatNumber(summary.cashIn)} | C-Out: ${formatNumber(summary.cashOut)}</span>
                    </div>
                    <div class="group-details">
                        ${groupData.items.map(item => {
                            let detailsHtml = '';
                            if (item.commission > 0) detailsHtml += `<span class="transaction-info-item"><strong data-i18n="comm">Comm:</strong> ${formatNumber(item.commission)}</span>`;
                            if (item.note) {
                                const truncatedNote = item.note.length > 50 ? item.note.substring(0, 50) + '...' : item.note;
                                detailsHtml += `<span class="transaction-info-item"><strong data-i18n="note">Note:</strong> ${truncatedNote}</span>`;
                            }
                            return `
                                <div class="transaction-item">
                                    <div class="transaction-header">
                                        <span class="transaction-type">${item.type}</span>
                                        <span class="transaction-amount">${formatNumber(item.amount)}</span>
                                    </div>
                                    <div class="transaction-details-mobile">
                                        <span class="transaction-date">${new Date(item.date).toLocaleTimeString()}</span>
                                        <span class="transaction-info-item"><strong data-i18n="action">Action:</strong> ${item.action}</span>
                                        ${detailsHtml}
                                    </div>
                                    <div class="transaction-actions">
                                        <button class="action-button-text edit" onclick="editMoneyRecord(${item.originalIndex})"><i class="fas fa-edit"></i></button>
                                        <button class="action-button-text delete" onclick="deleteMoneyRecord(${item.originalIndex})"><i class="fas fa-trash-alt"></i></button>
                                    </div>
                                </div>
                            `;
                        }).join('')}
                    </div>
                `;
                listContainer.appendChild(groupElement);
            }
        }

        // Add to translations
        translations.en.no_money_records_found = 'No money records found.';
        translations.my.no_money_records_found = 'ငွေ မှတ်တမ်းများ မတွေ့ပါ။';

        function editMoneyRecord(index) {
            if (index < 0 || index >= moneyRecords.length) { showToast(translations[currentLanguage]["error_loading_money_record"], "error"); return; }
            const record = moneyRecords[index];

            document.getElementById('money-date').value = record.date;
            document.getElementById('money-amount').value = formatNumber(record.amount);
            document.getElementById('money-action').value = record.action;

            const typeSelect = document.getElementById('money-type');
            const otherInput = document.getElementById('money-type-other');
            const removeButton = document.querySelector('#money-type + input[type="text"] + button');

            if (record.type && savedOtherMoneyTypes[record.type] || !['Wave Money', 'KBZ Pay', 'Aya Pay'].includes(record.type)) {
                typeSelect.value = 'other';
                otherInput.value = record.type;
                otherInput.style.display = 'block';
                if (removeButton) removeButton.style.display = 'inline-block';
                if (!savedOtherMoneyTypes[record.type]) {
                    savedOtherMoneyTypes[record.type] = record.type;
                    try { localStorage.setItem('moneyManager_savedOtherMoneyTypes', JSON.stringify(savedOtherMoneyTypes)); } catch (e) { console.error("Error saving custom money type during edit:", e); }
                    addOptionToSelect('money-type', record.type);
                }
            } else if (record.type) {
                typeSelect.value = record.type;
                otherInput.style.display = 'none'; otherInput.value = '';
                if (removeButton) removeButton.style.display = 'none';
            } else {
                typeSelect.value = 'Wave Money';
                otherInput.style.display = 'none'; otherInput.value = '';
                if (removeButton) removeButton.style.display = 'none';
            }

            toggleCommissionField();
            if (record.action === 'Emoney In') {
                document.getElementById('money-commission').value = record.commission ? formatNumber(record.commission) : '';
            } else {
                document.getElementById('money-commission').value = '';
            }

            document.getElementById('money-note').value = record.note || '';

            // Set editing state and remove from array temporarily
            isEditingMoneyRecord = true;
            moneyRecordBeingEdited = { ...record, originalIndex: index }; // Store context
            moneyRecords.splice(index, 1);
            try {
                localStorage.setItem('moneyManager_moneyRecords', JSON.stringify(moneyRecords));
            } catch (e) { console.error("Error saving money records after removing for edit:", e); }

            updateSummariesBasedOnCurrentView(); updateMoneyList();
            showToast(translations[currentLanguage]["money_record_loaded_for_editing"]);
            window.scrollTo(0, 0);
        }

        // Add to translations
        translations.en.error_loading_money_record = 'Error loading money record for editing.';
        translations.my.error_loading_money_record = 'ငွေ မှတ်တမ်းကို တည်းဖြတ်ရန် ဖွင့်ရာတွင် အမှားဖြစ်ပွားပါသည်။';
        translations.en.money_record_loaded_for_editing = 'Money record loaded for editing';
        translations.my.money_record_loaded_for_editing = 'ငွေ မှတ်တမ်း တည်းဖြတ်ရန် ဖွင့်ပြီး';

        function deleteMoneyRecord(index) {
            if (index < 0 || index >= moneyRecords.length) { showToast(translations[currentLanguage]["error_deleting_money_record"], "error"); return; }
            if (confirm(translations[currentLanguage]["confirm_delete_record"])) {
                moneyRecords.splice(index, 1);
                try {
                    localStorage.setItem('moneyManager_moneyRecords', JSON.stringify(moneyRecords));
                    showToast(translations[currentLanguage]["money_record_deleted_success"], 'success');
                } catch (e) {
                    console.error("Error saving money records after delete:", e);
                    showToast(translations[currentLanguage]["error_saving_after_deletion"], 'error');
                }
                updateSummariesBasedOnCurrentView(); updateMoneyList();
                // Redraw charts if daily money tab is active
                if (document.getElementById('daily-money').classList.contains('active')) {
                    drawDailyMoneyCharts();
                }
            }
        }

        // Add to translations
        translations.en.confirm_delete_record = 'Are you sure you want to delete this record?';
        translations.my.confirm_delete_record = 'ဤမှတ်တမ်းကို ဖျက်ရန် သေချာပါသလား?';
        translations.en.money_record_deleted_success = 'Money record deleted successfully';
        translations.my.money_record_deleted_success = 'ငွေ မှတ်တမ်း ဖျက်ပြီး အောင်မြင်ပါသည်';
        translations.en.error_deleting_money_record = 'Error deleting money record.';
        translations.my.error_deleting_money_record = 'ငွေ မှတ်တမ်း ဖျက်ရန် အမှားဖြစ်ပွားပါသည်။';

        function filterMoneyRecords() {
            const moneyActionFilter = document.getElementById('money-filter-action').value;
            const dateFilterValue = document.getElementById('money-filter-date').value;

            let filtered = moneyRecords;

            if (moneyActionFilter !== 'all') filtered = filtered.filter(r => r.action === moneyActionFilter);

            if (dateFilterValue) {
                try {
                    const filterDate = new Date(dateFilterValue);
                    filterDate.setHours(0, 0, 0, 0);
                    filtered = filtered.filter(r => {
                        const recordDateTime = new Date(r.date);
                        if (isNaN(recordDateTime.getTime())) return false;
                        return recordDateTime.getFullYear() === filterDate.getFullYear() &&
                               recordDateTime.getMonth() === filterDate.getMonth() &&
                               recordDateTime.getDate() === filterDate.getDate();
                    });
                } catch (e) { console.error("Error applying date filter for money records:", e); showToast(translations[currentLanguage]["error_applying_date_filter"], "error"); filtered = []; }
            }

            updateMoneyList(filtered);
            updateSummariesBasedOnCurrentView();
        }

        function resetMoneyFilters() {
            document.getElementById('money-filter-action').value = 'all';
            document.getElementById('money-filter-date').value = '';
            updateMoneyList();
            updateSummariesBasedOnCurrentView();
        }

        // --- DAILY SUMMARIES ---
        function updateDailySummaries(transactionsToProcess = null, recordsToSummarize = null) {
            const transactionFilterDateValue = document.getElementById('transaction-filter-date').value;
            const moneyFilterDateValue = document.getElementById('money-filter-date').value;

            // Determine the date range for the summary
            let relevantDateFilterValue = moneyFilterDateValue || transactionFilterDateValue; // Prioritize filter date from whichever tab is potentially active or if both are set
            let summaryStartDate, summaryEndDate;

            if (relevantDateFilterValue) {
                const filterDate = new Date(relevantDateFilterValue);
                summaryStartDate = new Date(filterDate); summaryStartDate.setHours(0, 0, 0, 0);
                summaryEndDate = new Date(filterDate); summaryEndDate.setHours(23, 59, 59, 999);
            } else {
                // Default to today if no filter is applied
                const today = new Date();
                summaryStartDate = new Date(today); summaryStartDate.setHours(0, 0, 0, 0);
                summaryEndDate = new Date(today); summaryEndDate.setHours(23, 59, 59, 999);
            }

           // --- Transaction Tab Daily Changes Calculation ---
            let dailyEMoneyBalanceFromTransactions = 0; // For the summary box: E-Money IN total
            let dailyCashBalanceFromTransactions = 0; // For the summary box: Cash IN total
            let totalDailyCommissionFromTransactions = 0;
            let totalDailyFeeFromTransactions = 0;
            const transactionsData = transactionsToProcess !== null ? transactionsToProcess : transactions;

            transactionsData.forEach(t => {
                const transactionDateTime = new Date(t.date);
                // Check if the transaction falls within the summary date range
                if (transactionDateTime >= summaryStartDate && transactionDateTime <= summaryEndDate) {
                    const amount = parseFloat(t.amount);
                    const commission = parseFloat(t.commission) || 0;
                    const fee = parseFloat(t.fee) || 0;

                    totalDailyCommissionFromTransactions += commission;
                    totalDailyFeeFromTransactions += fee;

                    // For the Daily Summary boxes (only E-Money IN and Cash IN)
                    // E-Money IN actions are 'Cash Out' and 'Received Money'
                    if (t.action === 'Cash Out' || t.action === 'Received Money') {
                        dailyEMoneyBalanceFromTransactions += amount;
                    }
                    // Cash IN actions are 'Cash In'
                    if (t.action === 'Cash In' || t.action === 'Send Money' || t.action === 'Payment' || t.action === 'Phone Bill') {
                        dailyCashBalanceFromTransactions += amount;
                    }
                }
            });

            // Update the Daily Summary boxes for Transactions Tab
            document.getElementById('daily-e-money').textContent = formatNumber(dailyEMoneyBalanceFromTransactions); // E-Money IN total
            document.getElementById('daily-cash').textContent = formatNumber(dailyCashBalanceFromTransactions); // Cash IN total
            document.getElementById('total-commission-summary').textContent = formatNumber(totalDailyCommissionFromTransactions);
            document.getElementById('total-fee-summary').textContent = formatNumber(totalDailyFeeFromTransactions);

            // Net Balance Change (Today) = E-Money Balance (Today) + Cash Balance (Today) for the summary boxes
            const netBalanceChangeSummary = dailyEMoneyBalanceFromTransactions + dailyCashBalanceFromTransactions;
            document.getElementById('daily-net-balance').textContent = formatNumber(netBalanceChangeSummary);

            const netBalanceElement = document.getElementById('daily-net-balance');
            netBalanceElement.className = netBalanceChangeSummary >= 0 ? 'positive' : 'negative';

           // --- Daily Money Tab Specific Summaries Calculation ---
            const dailySummaryForMoneyRecords = { emoneyIn: 0, emoneyOut: 0, cashIn: 0, cashOut: 0, commission: 0 };
            const moneyRecordsData = recordsToSummarize !== null ? recordsToSummarize : moneyRecords;

            moneyRecordsData.forEach(r => {
                const recordDateTime = new Date(r.date);
                if (recordDateTime >= summaryStartDate && recordDateTime <= summaryEndDate) {
                    const recordAmount = parseFloat(r.amount);
                    if (r.action === 'Emoney In') {
                        dailySummaryForMoneyRecords.emoneyIn += recordAmount;
                        dailySummaryForMoneyRecords.commission += parseFloat(r.commission);
                    } else if (r.action === 'Emoney Out') { dailySummaryForMoneyRecords.emoneyOut += recordAmount; }
                    else if (r.action === 'Cash In') { dailySummaryForMoneyRecords.cashIn += recordAmount; }
                    else if (r.action === 'Cash Out') { dailySummaryForMoneyRecords.cashOut += recordAmount; }
                }
            });

            document.getElementById('daily-emoney-in').textContent = formatNumber(dailySummaryForMoneyRecords.emoneyIn);
            document.getElementById('daily-emoney-out').textContent = formatNumber(dailySummaryForMoneyRecords.emoneyOut);
            document.getElementById('daily-cash-in').textContent = formatNumber(dailySummaryForMoneyRecords.cashIn);
            document.getElementById('daily-cash-out').textContent = formatNumber(dailySummaryForMoneyRecords.cashOut);

            const dailyEMoneyCashIn = dailySummaryForMoneyRecords.emoneyIn + dailySummaryForMoneyRecords.cashIn;
            document.getElementById('daily-emoney-cash-in').textContent = formatNumber(dailyEMoneyCashIn);

            // Calculate the net change for the Money Records summary
            let dailyEMoneyBalanceChangeFromMoneyRecords = (dailySummaryForMoneyRecords.emoneyIn || 0) - (dailySummaryForMoneyRecords.emoneyOut || 0);
            let dailyCashBalanceChangeFromMoneyRecords = (dailySummaryForMoneyRecords.cashIn || 0) - (dailySummaryForMoneyRecords.cashOut || 0);

            const totalDailyRemainingBalance = dailyEMoneyBalanceChangeFromMoneyRecords + dailyCashBalanceChangeFromMoneyRecords;
            document.getElementById('daily-remaining').textContent = formatNumber(totalDailyRemainingBalance);

            // NEW: Total Amount Flow (Today)
            const totalDailyFlow = dailySummaryForMoneyRecords.emoneyIn + dailySummaryForMoneyRecords.emoneyOut + dailySummaryForMoneyRecords.cashIn + dailySummaryForMoneyRecords.cashOut;
            document.getElementById('daily-total-flow').textContent = formatNumber(totalDailyFlow);


            if (dailySummaryForMoneyRecords.commission > 0) {
                document.getElementById('daily-money-commission-item').style.display = 'flex';
                document.getElementById('daily-money-commission').textContent = formatNumber(dailySummaryForMoneyRecords.commission);
            } else {
                document.getElementById('daily-money-commission-item').style.display = 'none';
            }

            // Auto-expand summary sections if they contain relevant data
            const transactionSummarySection = document.getElementById('transaction').querySelector('.summary-section');
            if (transactionSummarySection) {
                const hasTransactionData = (transactionsData.length > 0 || dailyEMoneyBalanceFromTransactions !== 0 || dailyCashBalanceFromTransactions !== 0 || totalDailyCommissionFromTransactions !== 0 || totalDailyFeeFromTransactions !== 0);
                if (hasTransactionData && !transactionSummarySection.classList.contains('expanded')) toggleExpand(transactionSummarySection);
                else if (!hasTransactionData && transactionSummarySection.classList.contains('expanded')) toggleExpand(transactionSummarySection);
            }

            const dailyMoneySummarySection = document.querySelector('#daily-money .summary-section');
            if (dailyMoneySummarySection) {
                const hasMoneyRecordData = (moneyRecordsData.length > 0 || dailySummaryForMoneyRecords.emoneyIn !== 0 || dailySummaryForMoneyRecords.emoneyOut !== 0 || dailySummaryForMoneyRecords.cashIn !== 0 || dailySummaryForMoneyRecords.cashOut !== 0 || dailySummaryForMoneyRecords.commission !== 0);
                if (hasMoneyRecordData && !dailyMoneySummarySection.classList.contains('expanded')) toggleExpand(dailyMoneySummarySection);
                else if (!hasMoneyRecordData && dailyMoneySummarySection.classList.contains('expanded')) toggleExpand(dailyMoneySummarySection);
            }
            updateTransactionTabBalances();
        }

        // Toggles the expanded state of a summary or list section.
        function toggleExpand(element) {
            element.classList.toggle('expanded');
            const summaryList = element.querySelector('.summary-list, .transaction-list-items'); // Target both types of lists
            if (summaryList) summaryList.style.display = element.classList.contains('expanded') ? 'block' : 'none';
            const arrow = element.querySelector('h2 .arrow');
            if (arrow) arrow.style.transform = element.classList.contains('expanded') ? 'rotate(180deg)' : 'rotate(0deg)';
        }

        // Toggles the expanded state of a group header (like date groups in lists)
        function toggleGroup(element) {
            element.parentElement.classList.toggle('expanded'); // Toggle class on the parent (grouped-transaction)
            const details = element.parentElement.querySelector('.group-details');
            if (details) details.style.display = element.parentElement.classList.contains('expanded') ? 'block' : 'none';
            const arrow = element.querySelector('.arrow'); // Find arrow within the clicked header
            if (arrow) arrow.style.transform = element.parentElement.classList.contains('expanded') ? 'rotate(180deg)' : 'rotate(0deg)';
        }

        function updateSummariesBasedOnCurrentView() {
            let filteredTransactionsForSummary = transactions;
            const transactionFilterDateValue = document.getElementById('transaction-filter-date').value;
            const moneyFilterDateValue = document.getElementById('money-filter-date').value;

            if (transactionFilterDateValue) {
                try {
                    const filterDate = new Date(transactionFilterDateValue); filterDate.setHours(0, 0, 0, 0);
                    filteredTransactionsForSummary = transactions.filter(t => {
                        const transactionDateTime = new Date(t.date);
                        if (isNaN(transactionDateTime.getTime())) return false;
                        return transactionDateTime.getFullYear() === filterDate.getFullYear() &&
                               transactionDateTime.getMonth() === filterDate.getMonth() &&
                               transactionDateTime.getDate() === filterDate.getDate();
                    });
                } catch (e) { console.error("Error during transaction filtering for summary update:", e); filteredTransactionsForSummary = []; }
            }

            let filteredMoneyRecordsForSummary = moneyRecords;
            const moneyActionFilterValue = document.getElementById('money-filter-action').value;
            const moneyDateFilterValue = document.getElementById('money-filter-date').value;

            if (moneyActionFilterValue !== 'all') {
                filteredMoneyRecordsForSummary = filteredMoneyRecordsForSummary.filter(r => r.action === moneyActionFilterValue);
            }
            if (moneyDateFilterValue) {
                try {
                    const filterDate = new Date(moneyDateFilterValue); filterDate.setHours(0, 0, 0, 0);
                    filteredMoneyRecordsForSummary = filteredMoneyRecordsForSummary.filter(r => {
                        const recordDateTime = new Date(r.date);
                        if (isNaN(recordDateTime.getTime())) return false;
                        return recordDateTime.getFullYear() === filterDate.getFullYear() &&
                               recordDateTime.getMonth() === filterDate.getMonth() &&
                               recordDateTime.getDate() === filterDate.getDate();
                    });
                } catch (e) { console.error("Error during money record filtering for summary update:", e); filteredMoneyRecordsForSummary = []; }
            }

            if (document.getElementById('daily-money').classList.contains('active') && document.getElementById('money-list').classList.contains('expanded')) updateMoneyList(filteredMoneyRecordsForSummary);
            if (document.getElementById('transaction').classList.contains('active') && document.getElementById('transaction-list').classList.contains('expanded')) updateTransactionList(currentFilteredTransactions);

            updateDailySummaries(filteredTransactionsForSummary, filteredMoneyRecordsForSummary);
            updateTransactionTabBalances();
        }
            
         // Update transaction tab balances whenever summaries are updated
    updateTransactionTabBalances();

        // --- EXPORT FUNCTIONS (EXCEL & PDF) ---
        function exportToExcel() {
            if (transactions.length === 0) { showToast(translations[currentLanguage]["no_transactions_to_export"], 'error'); return; }

            const dataForExcel = transactions.map(t => ({
                [translations[currentLanguage]["transaction_id"]]: t.id,
                [translations[currentLanguage]["date"]]: new Date(t.date).toLocaleString(),
                [translations[currentLanguage]["type"]]: t.type,
                [translations[currentLanguage]["action"]]: t.action,
                [translations[currentLanguage]["amount"]]: t.amount,
                [translations[currentLanguage]["commission"]]: t.commission || 0,
                [translations[currentLanguage]["fee"]]: t.fee || 0,
                [translations[currentLanguage]["phone"]]: t.phone,
                [translations[currentLanguage]["note"]]: t.note
            }));

            const ws = XLSX.utils.json_to_sheet(dataForExcel);
            const wb = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(wb, ws, translations[currentLanguage]["transactions"]);

            try { XLSX.writeFile(wb, "MoneyManager_Transactions.xlsx"); showToast(translations[currentLanguage]["transactions_exported_excel"], 'success'); }
            catch (e) { console.error("Error during Excel export:", e); showToast(translations[currentLanguage]["error_exporting_excel"], "error"); }
        }

        // Add to translations
        translations.en.no_transactions_to_export = 'No transactions to export';
        translations.my.no_transactions_to_export = 'ထုတ်ယူရန် ငွေလွှဲမှုများ မရှိပါ';
        translations.en.transactions_exported_excel = 'Transactions exported to Excel!';
        translations.my.transactions_exported_excel = 'ငွေလွှဲမှုများကို Excel သို့ ထုတ်ယူပြီး!';
        translations.en.error_exporting_excel = "Error exporting to Excel";
        translations.my.error_exporting_excel = "Excel သို့ ထုတ်ယူရာတွင် အမှားဖြစ်ပွားပါသည်";

        function exportToPDF() {
            if (transactions.length === 0) { showToast(translations[currentLanguage]["no_transactions_to_export"], 'error'); return; }

            const transactionListSection = document.getElementById('transaction-list');
            if (!transactionListSection) { showToast(translations[currentLanguage]["transaction_list_not_found"], 'error'); return; }

            // Ensure list is expanded to capture all items
            const listItemsContainer = transactionListSection.querySelector('.transaction-list-items');
            if (listItemsContainer && listItemsContainer.children.length > 0 && !transactionListSection.classList.contains('expanded')) {
                 // Need to simulate a click on the header to expand it if it's collapsed
                 const header = transactionListSection.querySelector('.group-header');
                 if (header) header.click(); // This should toggle the expansion
                 // Wait a moment for potential animations or rendering updates
                 setTimeout(() => captureForPDF(transactionListSection), 200);
            } else {
                captureForPDF(transactionListSection);
            }
        }

        // Add to translations
        translations.en.transaction_list_not_found = 'Transaction list section not found';
        translations.my.transaction_list_not_found = 'ငွေလွှဲမှု စာရင်း အပိုင်း မတွေ့ပါ';

        function captureForPDF(elementToCapture) {
            const tempWrapper = document.createElement('div');
            tempWrapper.style.cssText = `
                position: absolute; left: -9999px; top: 0; opacity: 1; width: auto; height: auto; visibility: visible;
                padding: 20px; background-color: ${isDarkMode ? '#333' : '#ffffff'}; z-index: 10000; font-family: 'Segoe UI', 'Inter', Arial, sans-serif;
                color: ${isDarkMode ? 'white' : '#212529'}; font-size: 14px; line-height: 1.6; box-sizing: border-box;
            `;

            // Clone the content to avoid modifying the original DOM during capture
            const clonedContent = elementToCapture.querySelector('.transaction-list-items').cloneNode(true);
            clonedContent.querySelectorAll('.transaction-actions').forEach(el => el.style.display = 'none'); // Hide action buttons
            clonedContent.querySelectorAll('.transaction-item.active').forEach(item => item.classList.remove('active')); // Remove hover states
            clonedContent.querySelectorAll('.group-header').forEach(header => header.classList.add('expanded')); // Ensure groups are expanded visually
            clonedContent.querySelectorAll('.group-details').forEach(details => details.style.display = 'block'); // Ensure details are visible

            tempWrapper.innerHTML = `
                <h2 style="text-align: center; margin-bottom: 30px; color: ${isDarkMode ? '#007bff' : '#007bff'}; font-size: 2em; border-bottom: 2px solid ${isDarkMode ? '#007bff' : '#007bff'}; padding-bottom: 15px;">${translations[currentLanguage]["transaction_history"]}</h2>
                <div style="margin-bottom: 25px;">${clonedContent.innerHTML}</div>
            `;
            document.body.appendChild(tempWrapper);

            html2canvas(tempWrapper, { useCORS: true, logging: false, letterRendering: true, scale: 2, backgroundColor: isDarkMode ? '#333' : '#ffffff' })
            .then(canvas => {
                if (tempWrapper.parentNode) document.body.removeChild(tempWrapper);

                const imgData = canvas.toDataURL('image/png');
                let pdf;
                try {
                    if (typeof jspdf === 'undefined' || typeof jspdf.jsPDF === 'undefined') throw new Error("jsPDF library is not loaded.");
                    pdf = new jspdf.jsPDF('p', 'mm', 'a4');
                } catch (e) { console.error("PDF initialization error:", e); showToast(translations[currentLanguage]["error_initializing_pdf"], "error"); return; }

                const imgProps = canvas; const pdfWidth = pdf.internal.pageSize.getWidth(); const pdfHeight = pdf.internal.pageSize.getHeight();
                const aspectRatio = imgProps.height / imgProps.width;
                let scaledHeight = pdfWidth * aspectRatio;
                const pageMargin = 15;

                if (scaledHeight > pdfHeight - (2 * pageMargin)) scaledHeight = pdfHeight - (2 * pageMargin);

                pdf.addImage(imgData, 'PNG', 0, pageMargin, pdfWidth, scaledHeight);
                try { pdf.save("MoneyManager_Transactions.pdf"); showToast(translations[currentLanguage]["transactions_exported_pdf"], 'success'); }
                catch (e) { console.error("Error saving PDF:", e); showToast(translations[currentLanguage]["error_saving_pdf"], "error"); }
            })
            .catch(error => {
                if (tempWrapper.parentNode) document.body.removeChild(tempWrapper);
                console.error("Error capturing transactions for PDF: ", error);
                showToast(`${translations[currentLanguage]["failed_export_pdf"]} ${error.message}`, 'error');
            });
        }

        // Add to translations
        translations.en.error_initializing_pdf = "Error initializing PDF generator.";
        translations.my.error_initializing_pdf = "PDF ဂျင်နရေတာ အစပြုရန် အမှားဖြစ်ပွားပါသည်။";
        translations.en.transactions_exported_pdf = 'Transactions exported to PDF!';
        translations.my.transactions_exported_pdf = 'ငွေလွှဲမှုများကို PDF သို့ ထုတ်ယူပြီး!';
        translations.en.error_saving_pdf = "Error saving PDF";
        translations.my.error_saving_pdf = "PDF သိမ်းဆည်းရာတွင် အမှားဖြစ်ပွားပါသည်";
        translations.en.failed_export_pdf ='Failed to export transactions to PDF:';
        translations.my.failed_export_pdf = 'ငွေလွှဲမှုများကို PDF သို့ ထုတ်ယူရန် မအောင်မြင်ပါ:';

        // --- TOGGLE VISIBILITY OF COLLAPSIBLE LISTS ---
        function toggleTransactionList() {
            const listContainer = document.getElementById('transaction-list');
            listContainer.classList.toggle('expanded');
            if (listContainer.classList.contains('expanded') && (listContainer.querySelector('.grouped-transaction') === null || listContainer.querySelector('.no-data'))) {
                 if (transactions.length > 0) updateTransactionList();
            }
        }

        function toggleMoneyList() {
            const listContainer = document.getElementById('money-list');
            listContainer.classList.toggle('expanded');
            if (listContainer.classList.contains('expanded') && (listContainer.querySelector('.grouped-transaction') === null || listContainer.querySelector('.no-data'))) {
                 if (moneyRecords.length > 0) updateMoneyList();
            }
        }

        // --- DEBT/CREDIT TAB FUNCTIONS ---
        function updateExistingDebtNames() {
            const nameSet = new Set();
            debts.forEach(debtGroup => nameSet.add(debtGroup.name.toLowerCase()));
            existingDebtNames = Array.from(nameSet);
        }

        function handleDebtNameInput(event) {
            const inputField = event.target;
            const name = inputField.value.trim();
            const suggestionsContainer = document.getElementById('debt-name-suggestions');

            if (suggestionsContainer) {
                suggestionsContainer.innerHTML = '';
                suggestionsContainer.style.display = 'none';
            }
            if (name.length < 2) return;

            const matchingNames = existingDebtNames
                .filter(existingName => existingName.includes(name.toLowerCase()))
                .slice(0, 5);

            if (matchingNames.length > 0 && suggestionsContainer) {
                suggestionsContainer.style.display = 'block';
                matchingNames.forEach(match => {
                    const suggestionItem = document.createElement('div');
                    suggestionItem.className = 'debt-suggestion-item';
                    suggestionItem.textContent = match.charAt(0).toUpperCase() + match.slice(1);
                    suggestionItem.onclick = () => {
                        inputField.value = suggestionItem.textContent;
                        if (suggestionsContainer) suggestionsContainer.style.display = 'none';
                        if (hideSuggestionsOnClickOutside) {
                            document.removeEventListener('click', hideSuggestionsOnClickOutside);
                            hideSuggestionsOnClickOutside = null;
                        }
                    };
                    suggestionsContainer.appendChild(suggestionItem);
                });

                if (!hideSuggestionsOnClickOutside) {
                    hideSuggestionsOnClickOutside = (e) => {
                        if (suggestionsContainer && !suggestionsContainer.contains(e.target) && !inputField.contains(e.target)) {
                            suggestionsContainer.style.display = 'none';
                            document.removeEventListener('click', hideSuggestionsOnClickOutside);
                            hideSuggestionsOnClickOutside = null;
                        }
                    };
                    document.addEventListener('click', hideSuggestionsOnClickOutside);
                }
            }
        }

        function addOrUpdateDebtEntry() {
            const nameInput = document.getElementById('debt-name');
            const name = nameInput.value.trim();
            const type = document.getElementById('debt-type').value;
            const amount = parseFloat(document.getElementById('debt-amount').value.replace(/,/g, ''));
            const date = document.getElementById('debt-date').value;
            const note = document.getElementById('debt-note').value.trim();

            // Validation
            if (!name) { showToast(translations[currentLanguage]["name_required"], "error"); return; }
            if (isNaN(amount) || amount <= 0) { showToast(translations[currentLanguage]["amount_positive"], "error"); return; }
            if (!date) { showToast(translations[currentLanguage]["date_time_required"], "error"); return; }

            // Determine the type for the history entry itself (e.g., 'initial_payable' or 'payment_out')
            // We need to know the original type of the entry IF we are editing, to know if we are moving it between groups.
            let historyEntryType;
            if (editingDebtEntry) {
                historyEntryType = editingDebtEntry.type; // Keep the original type of the entry
            } else {
                // For new entries, the type is determined by the current form selection
                historyEntryType = type === 'payable' ? 'initial_payable' : 'initial_receivable';
            }

            const newOrUpdatedEntry = {
                id: editingDebtEntry ? editingDebtEntry.id : Date.now().toString(), // Use existing ID or generate new
                date: date, amount: amount, type: historyEntryType, note: note
            };

            let debtGroupIndex = debts.findIndex(debt => debt.name === name && debt.type === type);
            let targetGroupType = type; // The type of the group we intend to add/update to

            // If the name/type combination doesn't exist, create it.
            if (debtGroupIndex === -1) {
                if (!existingDebtNames.includes(name.toLowerCase())) {
                     existingDebtNames.push(name.toLowerCase()); // Add to list of known names
                }
                debts.push({ name: name, type: targetGroupType, history: [], id: `debtGroup_${Date.now()}` });
                debtGroupIndex = debts.length - 1; // Get the index of the newly created group
            }

            // Handle moving an entry if the type (payable/receivable) has changed during editing
            let needsReconciliation = editingDebtEntry && editingDebtEntry.groupType !== targetGroupType;

            if (editingDebtEntry && needsReconciliation) {
                // Find the original group where the entry came from
                const originalGroupIndex = debts.findIndex(debt => debt.name === name && debt.type === editingDebtEntry.groupType);
                if (originalGroupIndex !== -1) {
                    // Find the specific entry within that original group
                    const originalEntryIndex = debts[originalGroupIndex].history.findIndex(entry => entry.id.toString() === editingDebtEntry.id.toString());
                    if (originalEntryIndex !== -1) {
                        // Remove the entry from its original group
                        debts[originalGroupIndex].history.splice(originalEntryIndex, 1);
                        // If the original group is now empty, remove the group
                        if (debts[originalGroupIndex].history.length === 0) debts.splice(originalGroupIndex, 1);
                    }
                }
                // Add the entry to the new group (which we ensured exists above)
                debts[debtGroupIndex].history.push(newOrUpdatedEntry);
            } else if (editingDebtEntry) {
                // If not a type change, just update the entry in its current group
                const entryIndexInGroup = debts[debtGroupIndex].history.findIndex(entry => entry.id.toString() === editingDebtEntry.id.toString());
                if (entryIndexInGroup !== -1) debts[debtGroupIndex].history[entryIndexInGroup] = newOrUpdatedEntry;
                else debts[debtGroupIndex].history.push(newOrUpdatedEntry); // Should not happen if logic is correct, but as a fallback
            } else {
                // If it's a new entry, simply push it to the correct group's history
                debts[debtGroupIndex].history.push(newOrUpdatedEntry);
            }

            updateExistingDebtNames();
            saveData();
            renderDebts();
            clearDebtForm(); // This will reset editingDebtEntry and change button text
            showToast(editingDebtEntry ? translations[currentLanguage]["debt_credit_updated_success"] : translations[currentLanguage]["debt_credit_added_success"], 'success');
            editingDebtEntry = null; // Clear editing context
            updateAddUpdateButtonText(); // Reset button text
        }

        // Add to translations
        translations.en.name_required = "Name is required.";
        translations.my.name_required = "အမည် လိုအပ်ပါသည်။";
        translations.en.debt_credit_updated_success = 'Debt/Credit entry updated successfully!';
        translations.my.debt_credit_updated_success = 'ကြွေးမြီ/ချေးငွေ မှတ်တမ်း အောင်မြင်စွာ အပ်ဒိတ်ပြီး!';
        translations.en.debt_credit_added_success = 'Debt/Credit added successfully!';
        translations.my.debt_credit_added_success = 'ကြွေးမြီ/ချေးငွေ အောင်မြင်စွာ ထည့်ပြီး!';

        function updateAddUpdateButtonText() {
            const button = document.getElementById('add-update-debt-button');
            button.innerHTML = editingDebtEntry ? '<i class="fas fa-sync-alt"></i> ' + translations[currentLanguage]["update_entry"] : '<i class="fas fa-save"></i> ' + translations[currentLanguage]["add_debt_credit"];
        }

        // Add to translations
        translations.en.update_entry = 'Update Entry';
        translations.my.update_entry = 'မှတ်တမ်း အပ်ဒိတ်ပါ';

        function clearDebtForm() {
            document.getElementById('debt-name').value = '';
            const suggestionsContainer = document.getElementById('debt-name-suggestions');
            if (suggestionsContainer) {
                suggestionsContainer.innerHTML = ''; suggestionsContainer.style.display = 'none';
            }
            if (hideSuggestionsOnClickOutside) {
                document.removeEventListener('click', hideSuggestionsOnClickOutside);
                hideSuggestionsOnClickOutside = null;
            }

            document.getElementById('debt-type').value = 'payable';
            document.getElementById('debt-amount').value = '';
            updateDateTimeFields();
            document.getElementById('debt-note').value = '';
            updateDebtFormVisibility(); // Ensure any dependent UI is updated

            editingDebtEntry = null; // Crucially, clear the editing context
            updateAddUpdateButtonText(); // Reset button text
        }

        // Function to handle the "Cancel" action for debt editing
        function cancelEditDebtEntry() {
            if (editingDebtEntry) {
                // Restore the original entry and group if it was temporarily removed.
                // We need to reconstruct the entry with its original data if the form was partially updated.
                const { id, type, groupType, groupIdx, entryIdx } = editingDebtEntry;

                // Find the original group where the entry came from.
                // If the group was deleted (e.g., if it became empty after the entry was removed), we need to find it based on its index or reconstruct it.
                // For now, we'll assume the name is still in the form, and we use the `groupType` from `editingDebtEntry`.
                let originalGroup = debts.find(debt => debt.name === document.getElementById('debt-name').value.trim() && debt.type === groupType);

                // Reconstruct the entry with its original data from `editingDebtEntry`
                // We use the data that was potentially in the form *just before* cancel was pressed, so so we use form values for date/amount/note,
                // but keep the original ID and type from the `editingDebtEntry` context.
                const restoredEntry = {
                    id: id,
                    date: document.getElementById('debt-date').value, // Use form values for date, amount etc if they changed prior to cancel
                    amount: parseFloat(document.getElementById('debt-amount').value.replace(/,/g, '')) || 0,
                    type: originalGroup.type === 'payable' ? 'initial_payable' : 'initial_receivable', // Type based on the group it's being restored to
                    note: document.getElementById('debt-note').value.trim()
                };

                // Re-add the restored entry back to its original position
                originalGroup.history.push(restoredEntry);

                // Re-save and re-render
                saveData();
                renderDebts();
                showToast(translations[currentLanguage]["edit_cancelled"], 'warning');
            } else {
                showToast(translations[currentLanguage]["no_entry_edited"], 'info');
            }
            clearDebtForm(); // This also clears editingDebtEntry and resets button text
        }

        // Add to translations
        translations.en.no_entry_edited = 'No entry was being edited.';
        translations.my.no_entry_edited = 'တည်းဖြတ်နေသော မှတ်တမ်း မရှိပါ။';

        function renderDebts() {
            const payableList = document.querySelector('#payable-debts-list .transaction-list-items');
            const receivableList = document.querySelector('#receivable-debts-list .transaction-list-items');
            payableList.innerHTML = ''; receivableList.innerHTML = '';

            let totalPayable = 0; let totalReceivable = 0;
            const aggregatedDebts = {};

            debts.forEach(debtGroup => {
                const { name, type, history, id } = debtGroup;
                if (!aggregatedDebts[name]) aggregatedDebts[name] = { payableHistory: [], receivableHistory: [] };
                if (type === 'payable') aggregatedDebts[name].payableHistory.push(...history.map(h => ({...h, groupId: id})));
                else aggregatedDebts[name].receivableHistory.push(...history.map(h => ({...h, groupId: id})));
            });

            const sortedNames = Object.keys(aggregatedDebts).sort();

            sortedNames.forEach(name => {
                const debtAggregation = aggregatedDebts[name];

                // Process Payable Debts
                if (debtAggregation.payableHistory.length > 0) {
                    let currentPayableTotal = 0;
                    debtAggregation.payableHistory.sort((a, b) => new Date(a.date) - new Date(b.date));
                    debtAggregation.payableHistory.forEach(entry => {
                        if (['initial_payable', 'payment_out'].includes(entry.type)) currentPayableTotal += entry.amount;
                        else if (['initial_receivable', 'payment_in'].includes(entry.type)) currentPayableTotal -= entry.amount;
                    });
                    currentPayableTotal = Math.max(0, currentPayableTotal);

                    if (currentPayableTotal > 0) {
                        totalPayable += currentPayableTotal;
                        const payableDiv = createDebtListItem(name, 'payable', currentPayableTotal, debtAggregation.payableHistory);
                        payableList.appendChild(payableDiv);
                    }
                }

                // Process Receivable Credits
                if (debtAggregation.receivableHistory.length > 0) {
                    let currentReceivableTotal = 0;
                    debtAggregation.receivableHistory.sort((a, b) => new Date(a.date) - new Date(b.date));
                    debtAggregation.receivableHistory.forEach(entry => {
                        if (['initial_receivable', 'payment_in'].includes(entry.type)) currentReceivableTotal += entry.amount;
                        else if (['initial_payable', 'payment_out'].includes(entry.type)) currentReceivableTotal -= entry.amount;
                    });
                    currentReceivableTotal = Math.max(0, currentReceivableTotal);

                    if (currentReceivableTotal > 0) {
                        totalReceivable += currentReceivableTotal;
                        const receivableDiv = createDebtListItem(name, 'receivable', currentReceivableTotal, debtAggregation.receivableHistory);
                        receivableList.appendChild(receivableDiv);
                    }
                }
            });

            document.getElementById('total-payable-amount').textContent = formatNumber(totalPayable);
            document.getElementById('total-receivable-amount').textContent =formatNumber(totalReceivable);

            // Update initial summary display as well
            document.getElementById('initial-total-payable').textContent = formatNumber(totalPayable);
            document.getElementById('initial-total-receivable').textContent = formatNumber(totalReceivable);

            if (payableList.children.length === 0) payableList.innerHTML = '<p class="no-data" data-i18n="no_payable_debts_found">No payable debts found.</p>';
            if (receivableList.children.length === 0) receivableList.innerHTML = '<p class="no-data" data-i18n="no_receivable_credits_found">No receivable credits found.</p>';
        }

        // Add to translations
        translations.en.no_payable_debts_found = 'No payable debts found.';
        translations.my.no_payable_debts_found = 'ပေးချေရမည့် ကြွေးမြီများ မတွေ့ပါ။';
        translations.en.no_receivable_credits_found = 'No receivable credits found.';
        translations.my.no_receivable_credits_found = 'လက်ခံရမည့် ချေးငွေများ မတွေ့ပါ။';

        function createDebtListItem(name, type, amount, history) {
            const debtDiv = document.createElement('div');
            debtDiv.className = 'debt-list-item';
            debtDiv.dataset.name = name; debtDiv.dataset.type = type;

            const amountClass = type === 'payable' ? 'negative' : 'positive';
            const formattedAmount = formatNumber(amount);
            const historyHtml = generateHistoryHtml(history); // This function will create the transaction-like history items

            debtDiv.innerHTML = `
                <div class="debt-item-summary sticky-header" onclick="toggleDebtDetails(event, '${name.replace(/'/g, "\\'")}', '${type}')">
                    <div class="debt-name">${name}</div>
                    <span class="debt-amount ${amountClass}">${formattedAmount}</span>
                </div>
                <div class="debt-item-details-expanded" id="debt-details-${name.replace(/'/g, "\\'")}-${type}">
                    <div class="debt-actions">
                        <button class="action-button-text delete" onclick="deleteDebtGroup('${name.replace(/'/g, "\\'")}','${type}')"><i class="fas fa-trash-alt"></i> <span data-i18n="delete_group">Delete Group</span></button>
                        <button class="action-button-text secondary" id="debt-toggle-details-button-${name.replace(/'/g, "\\'")}-${type}" onclick="toggleDetailsButtonAction('${name.replace(/'/g, "\\'")}', '${type}')"><i class="fas fa-ellipsis-h"></i> <span data-i18n="details">Details</span></button>
                    </div>
                    <div class="debt-details">
                        <span class="debt-type">${type === 'payable' ? translations[currentLanguage]["you_owe"] : translations[currentLanguage]["owed_to_you"]}</span>
                        ${historyHtml ? `<span class="debt-note">${history.length} ${translations[currentLanguage]["entries"]}</span>` : ''}
                    </div>
                    ${historyHtml}
                </div>
            `;
            return debtDiv;
        }

        // Add to translations
        translations.en.delete_group = 'Delete Group';
        translations.my.delete_group = 'အဖွဲ့ကို ဖျက်ပါ';
        translations.en.details = 'Details';
        translations.my.details = 'အသေးစိတ်';
        translations.en.you_owe = 'You owe';
        translations.my.you_owe = 'သင်ကြွေးဆပ်ရမည်';
        translations.en.owed_to_you = 'Owed to you';
        translations.my.owed_to_you = 'သင့်ကို ကြွေးဆပ်ရမည်';
        translations.en.entries = 'entries';
        translations.my.entries = 'မှတ်တမ်းများ';

        function toggleDebtDetails(event, name, type) {
            // Prevent toggling if clicking on an action button (edit, delete)
            if (event.target.closest('.debt-actions') || event.target.closest('button')) return;

            const detailsDiv = document.getElementById(`debt-details-${name.replace(/'/g, "\\'")}-${type}`);
            if (detailsDiv) {
                const isNowVisible = !detailsDiv.classList.contains('visible');
                detailsDiv.classList.toggle('visible');
                updateToggleButton(name, type, isNowVisible); // Update button state
            }
        }

        function updateToggleButton(name, type, isVisible) {
            const toggleButton = document.getElementById(`debt-toggle-details-button-${name.replace(/'/g, "\\'")}-${type}`);
            if (toggleButton) {
                const iconElement = toggleButton.querySelector('i');
                if (isVisible) {
                    iconElement.classList.remove('fa-ellipsis-h');
                    iconElement.classList.add('fa-times');
                    toggleButton.textContent = ' ' + translations[currentLanguage]["hide_details"];
                    toggleButton.prepend(iconElement); // Ensure icon is before text
                } else {
                    iconElement.classList.remove('fa-times');
                    iconElement.classList.add('fa-ellipsis-h');
                    toggleButton.textContent = ' ' + translations[currentLanguage]["details"];
                    toggleButton.prepend(iconElement); // Ensure icon is before text
                }
            }
        }

        // Add to translations
        translations.en.hide_details = 'Hide Details';
        translations.my.hide_details = 'အသေးစိတ်ကို ဖုံးကွယ်ပါ';

        function editDebtHistoryEntry(entryId) {
            for (let i = 0; i < debts.length; i++) {
                const debtGroup = debts[i];
                const historyEntryIndex = debtGroup.history.findIndex(entry => entry.id.toString() === entryId.toString());

                if (historyEntryIndex !== -1) {
                    const entryToEdit = debtGroup.history[historyEntryIndex];

                    document.getElementById('debt-name').value = debtGroup.name;
                    document.getElementById('debt-type').value = debtGroup.type; // Set the correct type of the group
                    document.getElementById('debt-amount').value = formatNumber(entryToEdit.amount);
                    document.getElementById('debt-date').value = entryToEdit.date;
                    document.getElementById('debt-note').value = entryToEdit.note || '';
                    updateDebtFormVisibility(); // Ensure any dependent UI is updated

                    // Store the editing context: entry ID, entry type, group type, group index, and original entry index
                    editingDebtEntry = {
                        id: entryToEdit.id,
                        type: entryToEdit.type, // The specific type of this history entry (e.g., 'initial_payable')
                        groupType: debtGroup.type, // The type of the group it belongs to (e.g., 'payable')
                        groupIdx: i,
                        entryIdx: historyEntryIndex
                    };
                    updateAddUpdateButtonText(); // Change button text to "Update Entry"

                    // Temporarily remove the entry from its original position to prevent it showing twice
                    debtGroup.history.splice(historyEntryIndex, 1);
                    // If the group becomes empty after removing the entry, remove the group too
                    if (debtGroup.history.length === 0) debts.splice(i, 1);

                    saveData(); // Save the changes immediately
                    renderDebts(); // Re-render the lists
                    showToast(translations[currentLanguage]["entry_loaded_for_editing"]);
                    window.scrollTo(0, 0); // Scroll to the form at the top
                    return;
                }
            }
            showToast(translations[currentLanguage]["entry_not_found_editing"], "error");
        }

        // Add to translations
        translations.en.entry_loaded_for_editing = 'Entry loaded for editing. Update form and click Update.';
        translations.my.entry_loaded_for_editing = 'မှတ်တမ်း တည်းဖြတ်ရန် ဖွင့်ပြီး။ ဖောင်ကို အပ်ဒိတ်ပါ နှင့် အပ်ဒိတ်ကို နှိပ်ပါ။';
        translations.en.entry_not_found_editing = "Entry not found for editing.";
        translations.my.entry_not_found_editing = "တည်းဖြတ်ရန် မှတ်တမ်း မတွေ့ပါ။";

        function deleteDebtHistoryEntry(entryId) {
            if (!confirm(translations[currentLanguage]["confirm_delete_history_entry"])) return;

            for (let i = 0; i < debts.length; i++) {
                const debtGroup = debts[i];
                const historyEntryIndex = debtGroup.history.findIndex(entry => entry.id.toString() === entryId.toString());

                if (historyEntryIndex !== -1) {
                    debtGroup.history.splice(historyEntryIndex, 1);
                    if (debtGroup.history.length === 0) debts.splice(i, 1); // Remove group if empty

                    updateExistingDebtNames(); // Update known names if a group is removed
                    saveData();
                    renderDebts();
                    showToast(translations[currentLanguage]["history_entry_deleted_success"], 'success');
                    return;
                }
            }
            showToast(translations[currentLanguage]["entry_not_found_deletion"], "error");
        }

        // Add to translations
        translations.en.confirm_delete_history_entry = 'Are you sure you want to delete this history entry?';
        translations.my.confirm_delete_history_entry = 'ဤမှတ်တမ်း မှတ်တမ်းကို ဖျက်ရန် သေချာပါသလား?';
        translations.en.history_entry_deleted_success = 'History entry deleted successfully';
        translations.my.history_entry_deleted_success = 'မှတ်တမ်း မှတ်တမ်း ဖျက်ပြီး အောင်မြင်ပါသည်';
        translations.en.entry_not_found_deletion = "Entry not found for deletion.";
        translations.my.entry_not_found_deletion = "ဖျက်ရန် မှတ်တမ်း မတွေ့ပါ။";

        function deleteDebtGroup(name, type) {
             if (!confirm(`${translations[currentLanguage]["confirm_delete_group"]} "${name}" (${type})? ${translations[currentLanguage]["action_cannot_undone"]}`)) return;

            const groupIndexToDelete = debts.findIndex(debt => debt.name === name && debt.type === type);
            if (groupIndexToDelete !== -1) {
                debts.splice(groupIndexToDelete, 1);
                updateExistingDebtNames(); // Update known names if a group is removed
                saveData();
                renderDebts();
                showToast(translations[currentLanguage]["debt_group_deleted_success"]);
            } else {
                showToast(translations[currentLanguage]["group_not_found_deletion"], 'error');
            }
        }

        // Add to translations
        translations.en.confirm_delete_group = 'Are you sure you want to delete the entire group for';
        translations.my.confirm_delete_group = 'အဖွဲ့ တစ်ခုလုံးကို ဖျက်ရန် သေချာပါသလား';
        translations.en.action_cannot_undone = 'This action cannot be undone.';
        translations.my.action_cannot_undone = 'ဤလုပ်ဆောင်ချက်ကို မပြန်လည်နိုင်ပါ။';
        translations.en.debt_group_deleted_success = 'Debt group deleted successfully';
        translations.my.debt_group_deleted_success = 'ကြွေးမြီ အဖွဲ့ ဖျက်ပြီး အောင်မြင်ပါသည်';
        translations.en.group_not_found_deletion = 'Group not found for deletion.';
        translations.my.group_not_found_deletion = 'ဖျက်ရန် အဖွဲ့ မတွေ့ပါ။';

        function updateDebtFormVisibility() {
            // This function could be used if certain fields should appear/disappear based on debt type.
            // Currently, all fields are always visible.
        }

        function filterDebts() {
            const nameFilter = document.getElementById('debt-filter-name').value.toLowerCase();
            let filteredDebts = debts;
            if (nameFilter) {
                filteredDebts = filteredDebts.filter(debtGroup => debtGroup.name.toLowerCase().includes(nameFilter));
            }
            renderDebtsFiltered(filteredDebts);
        }

        function resetDebtFilters() {
            document.getElementById('debt-filter-name').value = '';
            renderDebts();
        }

        function generateHistoryHtml(history) {
            if (!history || history.length === 0) return '';

            let historyHtml = '<div class="debt-history-list">';
            const sortedHistory = [...history].sort((a, b) => new Date(a.date) - new Date(b.date));

            sortedHistory.forEach(entry => {
                const entryDateTime = new Date(entry.date);
                const entryDisplay = entryDateTime.toLocaleString();

                let amountClass = ''; let entryTypeLabel = '';
                switch (entry.type) {
                    case 'initial_payable': amountClass = 'negative'; entryTypeLabel = translations[currentLanguage]["initial_debt"]; break;
                    case 'initial_receivable': amountClass = 'positive'; entryTypeLabel = translations[currentLanguage]["initial_credit"]; break;
                    case 'payment_out': amountClass = 'negative'; entryTypeLabel = translations[currentLanguage]["paid"]; break;
                    case 'payment_in': amountClass = 'positive'; entryTypeLabel = translations[currentLanguage]["received"]; break;
                    default:
                        amountClass = '';
                        entryTypeLabel = entry.type.charAt(0).toUpperCase() + entry.type.slice(1).replace('_', ' ');
                        break;
                }
                const noteDisplay = entry.note ? ` - ${entry.note}` : '';

                // Re-using transaction-item structure for debt history entries
                historyHtml += `
                    <div class="transaction-item" onclick="handleItemHover(this)">
                        <div class="transaction-header">
                            <span class="transaction-type">${entryTypeLabel}</span>
                            <span class="transaction-amount ${amountClass}">${formatNumber(entry.amount)}</span>
                        </div>
                        <div class="transaction-details-mobile">
                            <span class="transaction-date">${entryDateTime.toLocaleTimeString()}</span>
                            <span class="transaction-info-item"><strong data-i18n="date">Date:</strong> ${entryDateTime.toLocaleDateString()}</span>
                            ${noteDisplay ? `<span class="transaction-info-item"><strong data-i18n="note">Note:</strong> ${noteDisplay.substring(3)}</span>` : ''}
                        </div>
                        <div class="transaction-actions">
                            <button class="action-button-text edit" onclick="editDebtHistoryEntry('${entry.id}')"><i class="fas fa-edit"></i></button>
                            <button class="action-button-text delete" onclick="deleteDebtHistoryEntry('${entry.id}')"><i class="fas fa-trash-alt"></i></button>
                        </div>
                    </div>
                `;
            });
            historyHtml += '</div>';
            return historyHtml;
        }

        // Add to translations
        translations.en.initial_debt = 'Initial Debt';
        translations.my.initial_debt = 'အစ ကြွေးမြီ';
        translations.en.initial_credit = 'Initial Credit';
        translations.my.initial_credit = 'အစ ချေးငွေ';
        translations.en.paid = 'Paid';
        translations.my.paid = 'ပေးချေပြီး';
        translations.en.received = 'Received';
        translations.my.received = 'ရရှိပြီး';
        translations.en.date = 'Date:';
        translations.my.date = 'နေ့စွဲ:';

        function renderDebtsFiltered(filteredDebts) {
            const payableList = document.querySelector('#payable-debts-list .transaction-list-items');
            const receivableList = document.querySelector('#receivable-debts-list .transaction-list-items');
            payableList.innerHTML = ''; receivableList.innerHTML = '';

            let totalPayable = 0; let totalReceivable = 0;
            const aggregatedDebts = {};

            filteredDebts.forEach(debtGroup => { // Iterate over the filtered list
                const { name, type, history, id } = debtGroup;
                if (!aggregatedDebts[name]) aggregatedDebts[name] = { payableHistory: [], receivableHistory: [] };
                if (type === 'payable') aggregatedDebts[name].payableHistory.push(...history.map(h => ({...h, groupId: id})));
                else aggregatedDebts[name].receivableHistory.push(...history.map(h => ({...h, groupId: id})));
            });

            const sortedNames = Object.keys(aggregatedDebts).sort();

            sortedNames.forEach(name => {
                const debtAggregation = aggregatedDebts[name];

                // Process Payable Debts
                if (debtAggregation.payableHistory.length > 0) {
                    let currentPayableTotal = 0;
                    debtAggregation.payableHistory.sort((a, b) => new Date(a.date) - new Date(b.date));
                    debtAggregation.payableHistory.forEach(entry => {
                        if (['initial_payable', 'payment_out'].includes(entry.type)) currentPayableTotal += entry.amount;
                        else if (['initial_receivable', 'payment_in'].includes(entry.type)) currentPayableTotal -= entry.amount;
                    });
                    currentPayableTotal = Math.max(0, currentPayableTotal);

                    if (currentPayableTotal > 0) {
                        totalPayable += currentPayableTotal;
                        const payableDiv = createDebtListItem(name, 'payable', currentPayableTotal, debtAggregation.payableHistory);
                        payableList.appendChild(payableDiv);
                    }
                }

                // Process Receivable Credits
                if (debtAggregation.receivableHistory.length > 0) {
                    let currentReceivableTotal = 0;
                    debtAggregation.receivableHistory.sort((a, b) => new Date(a.date) - new Date(b.date));
                    debtAggregation.receivableHistory.forEach(entry => {
                        if (['initial_receivable', 'payment_in'].includes(entry.type)) currentReceivableTotal += entry.amount;
                        else if (['initial_payable', 'payment_out'].includes(entry.type)) currentReceivableTotal -= entry.amount;
                    });
                    currentReceivableTotal = Math.max(0, currentReceivableTotal);

                    if (currentReceivableTotal > 0) {
                        totalReceivable += currentReceivableTotal;
                        const receivableDiv = createDebtListItem(name, 'receivable', currentReceivableTotal, debtAggregation.receivableHistory);
                        receivableList.appendChild(receivableDiv);
                    }
                }
            });

            document.getElementById('total-payable-amount').textContent = formatNumber(totalPayable);
            document.getElementById('total-receivable-amount').textContent = formatNumber(totalReceivable);

            // Update initial summary display as well
            document.getElementById('initial-total-payable').textContent = formatNumber(totalPayable);
            document.getElementById('initial-total-receivable').textContent = formatNumber(totalReceivable);

            if (payableList.children.length === 0) payableList.innerHTML = '<p class="no-data" data-i18n="no_payable_debts_found">No payable debts found.</p>';
            if (receivableList.children.length === 0) receivableList.innerHTML = '<p class="no-data" data-i18n="no_receivable_credits_found">No receivable credits found.</p>';
        }

        // --- EXPENSE TAB SPECIFIC FUNCTIONS ---
        function updateExpenseCategoryVisibility() {
            const categorySelect = document.getElementById('expense-category');
            const otherInput = document.getElementById('expense-category-other');
            const removeButton = document.querySelector('#expense-category + input[type="text"] + button');

            otherInput.style.display = categorySelect.value === 'other' ? 'block' : 'none';
            if (removeButton) removeButton.style.display = categorySelect.value === 'other' ? 'inline-block' : 'none';

            if (categorySelect.value === 'other') {
                if (otherInput.style.display === 'block' && document.activeElement !== otherInput) otherInput.focus();
            } else {
                otherInput.value = '';
            }
        }

        function removeCustomExpenseCategory() {
            const categorySelect = document.getElementById('expense-category');
            const otherInput = document.getElementById('expense-category-other');
            const customCategoryValue = otherInput.value.trim();

            if (customCategoryValue && removeCustomOption('expense-category', customCategoryValue, 'moneyManager_savedExpenseCategories')) {
                categorySelect.value = 'Rent'; // Reset to default
                updateExpenseCategoryVisibility();
            } else if (!customCategoryValue) {
                showToast(translations[currentLanguage]["no_custom_category_to_remove"], "warning");
            } else {
                showToast(translations[currentLanguage]["failed_remove_custom_category"], "error");
            }
        }

        // Add to translations
        translations.en.no_custom_category_to_remove = "No custom category entered to remove.";
        translations.my.no_custom_category_to_remove = "ဖယ်ရှားရန် ကိုယ်တိုင်အမျိုးအစားကို မထည့်ရသေးပါ။";
        translations.en.failed_remove_custom_category = "Failed to remove custom category.";
        translations.my.failed_remove_custom_category = "ကိုယ်တိုင်အမျိုးအစားကို ဖယ်ရှားရန် မအောင်မြင်ပါ။";

        function updatePaymentMethodVisibility() {
            const paymentMethodSelect = document.getElementById('expense-payment-method');
            const otherInput = document.getElementById('expense-payment-method-other');
            const removeButton = document.querySelector('#expense-payment-method + input[type="text"] + button');

            otherInput.style.display = paymentMethodSelect.value === 'Other' ? 'block' : 'none';
            if (removeButton) removeButton.style.display = paymentMethodSelect.value === 'Other' ? 'inline-block' : 'none';

            if (paymentMethodSelect.value === 'Other') {
                if (otherInput.style.display === 'block' && document.activeElement !== otherInput) otherInput.focus();
            } else {
                otherInput.value = '';
            }
        }

        function removeCustomPaymentMethod() {
            const paymentMethodSelect = document.getElementById('expense-payment-method');
            const otherInput = document.getElementById('expense-payment-method-other');
            const customMethodValue = otherInput.value.trim();

            if (customMethodValue && removeCustomOption('expense-payment-method', customMethodValue, 'moneyManager_savedExpensePaymentMethods')) {
                paymentMethodSelect.value = 'E-Money'; // Reset to default
                updatePaymentMethodVisibility();
            } else if (!customMethodValue) {
                showToast(translations[currentLanguage]["no_custom_method_to_remove"], "warning");
            } else {
                showToast(translations[currentLanguage]["failed_remove_custom_method"], "error");
            }
        }

        // Add to translations
        translations.en.no_custom_method_to_remove = "No custom payment method entered to remove.";
        translations.my.no_custom_method_to_remove = "ဖယ်ရှားရန် ကိုယ်တိုင်ပေးချေမှုနည်းလမ်းကို မထည့်ရသေးပါ။";
        translations.en.failed_remove_custom_method = "Failed to remove custom payment method.";
        translations.my.failed_remove_custom_method = "ကိုယ်တိုင်ပေးချေမှုနည်းလမ်းကို ဖယ်ရှားရန် မအောင်မြင်ပါ။";

        function addExpenseEntry() {
            const date = document.getElementById('expense-date').value;
            const type = document.getElementById('expense-type').value;
            const categorySelect = document.getElementById('expense-category');
            const categoryOtherInput = document.getElementById('expense-category-other');
            let finalCategory = categorySelect.value;

            if (finalCategory === 'other') {
                const customCategory = categoryOtherInput.value.trim();
                if (!customCategory) { showToast(translations[currentLanguage]["specify_other_category"], 'error'); return; }
                finalCategory = customCategory;
                if (!savedExpenseCategories[finalCategory]) {
                    savedExpenseCategories[finalCategory] = finalCategory;
                    try { localStorage.setItem('moneyManager_savedExpenseCategories', JSON.stringify(savedExpenseCategories)); } catch (e) { console.error("Error saving custom expense category:", e); }
                    addOptionToSelect('expense-category', finalCategory);
                }
            }

            const amount = parseFloat(document.getElementById('expense-amount').value.replace(/,/g, ''));
            const paymentMethod = document.getElementById('expense-payment-method').value;
            const paymentMethodOtherInput = document.getElementById('expense-payment-method-other');
            let finalPaymentMethod = paymentMethod;
            if (paymentMethod === 'Other') {
                const customPaymentMethod = paymentMethodOtherInput.value.trim();
                if (!customPaymentMethod) { showToast(translations[currentLanguage]["specify_other_method"], 'error'); return; }
                finalPaymentMethod = customPaymentMethod;
                if (!savedExpensePaymentMethods[finalPaymentMethod]) {
                    savedExpensePaymentMethods[finalPaymentMethod] = finalPaymentMethod;
                    try { localStorage.setItem('moneyManager_savedExpensePaymentMethods', JSON.stringify(savedExpensePaymentMethods)); } catch (e) { console.error("Error saving custom payment method:", e); }
                    addOptionToSelect('expense-payment-method', finalPaymentMethod);
                }
            }
            const note = document.getElementById('expense-note').value.trim();

            // Validation
            if (!date) { showToast(translations[currentLanguage]["date_time_required"], 'error'); return; }
            if (!finalCategory) { showToast(translations[currentLanguage]["category_required"], 'error'); return; }
            if (isNaN(amount) || amount <= 0) { showToast(translations[currentLanguage]["amount_positive"], 'error'); return; }
            if (!finalPaymentMethod) { showToast(translations[currentLanguage]["payment_method_required"], 'error'); return; }

            const newEntry = { id: Date.now().toString(), date, type, category: finalCategory, amount, paymentMethod: finalPaymentMethod, note };
            expenseEntries.unshift(newEntry);

            try {
                localStorage.setItem('moneyManager_expenseEntries', JSON.stringify(expenseEntries));
                showToast(translations[currentLanguage]["expense_income_added_success"], 'success');
            } catch (e) {
                console.error("Error saving expense entries:", e);
                showToast(translations[currentLanguage]["error_saving_expense_entry"], 'error');
            }

            updateExpenseSummaries(); renderExpenseEntries(); clearExpenseForm();
            // Redraw charts if expense tab is active
            if (document.getElementById('expense').classList.contains('active')) {
                drawExpenseCharts();
            }
        }

        // Add to translations
        translations.en.specify_other_category = 'Please specify the other category';
        translations.my.specify_other_category = 'အခြားအမျိုးအစားကို သတ်မှတ်ပါ';
        translations.en.specify_other_method = 'Please specify the other payment method';
        translations.my.specify_other_method = 'အခြားပေးချေမှုနည်းလမ်းကို သတ်မှတ်ပါ';
        translations.en.category_required = 'Category is required.';
        translations.my.category_required = 'အမျိုးအစား လိုအပ်ပါသည်။';
        translations.en.payment_method_required = 'Payment Method is required.';
        translations.my.payment_method_required = 'ပေးချေမှုနည်းလမ်း လိုအပ်ပါသည်။';
        translations.en.expense_income_added_success = 'Expense/Income entry added successfully!';
        translations.my.expense_income_added_success = 'အသုံးစရိတ်/ဝင်ငွေ မှတ်တမ်း အောင်မြင်စွာ ထည့်ပြီး!';
        translations.en.error_saving_expense_entry = 'Error saving expense entry';
        translations.my.error_saving_expense_entry = 'အသုံးစရိတ် မှတ်တမ်းကို သိမ်းဆည်းရာတွင် အမှားဖြစ်ပွားပါသည်';

        // Function to handle "Cancel" action during expense entry editing or clearing the form
        function cancelEditExpenseEntry() {
            if (isEditingExpenseEntry) {
                if (expenseEntryBeingEdited) {
                    expenseEntries.unshift(expenseEntryBeingEdited); // Re-add the entry
                    try {
                        localStorage.setItem('moneyManager_expenseEntries', JSON.stringify(expenseEntries));
                    } catch (e) { console.error("Error saving expense entries after cancel edit:", e); }
                    showToast(translations[currentLanguage]["edit_cancelled"], 'warning');
                } else {
                    showToast(translations[currentLanguage]["edit_cancelled_error"], 'warning');
                }
                isEditingExpenseEntry = false;
                expenseEntryBeingEdited = null;
                updateExpenseSummaries();
                renderExpenseEntries();
                clearExpenseForm();
            } else {
                clearExpenseForm();
            }
        }

        function clearExpenseForm() {
            document.getElementById('expense-date').value = ''; updateDateTimeFields();
            document.getElementById('expense-type').value = 'Expense';
            document.getElementById('expense-category').value = 'Rent';
            document.getElementById('expense-category-other').value = ''; document.getElementById('expense-category-other').style.display = 'none';
            const removeCatButton = document.querySelector('#expense-category + input[type="text"] + button');
            if(removeCatButton) removeCatButton.style.display = 'none'; // Hide remove button

            document.getElementById('expense-amount').value = '';
            document.getElementById('expense-payment-method').value = 'E-Money';
            document.getElementById('expense-payment-method-other').value = ''; document.getElementById('expense-payment-method-other').style.display = 'none';
            const removePayMethodButton = document.querySelector('#expense-payment-method + input[type="text"] + button');
            if(removePayMethodButton) removePayMethodButton.style.display = 'none'; // Hide remove button

            document.getElementById('expense-note').value = '';
            updateExpenseCategoryVisibility();

            // Reset the editing flag if it was true but we are clearing without a specific cancel action
            isEditingExpenseEntry = false;
            expenseEntryBeingEdited = null;
        }

        function renderExpenseEntries(filteredEntries = null) {
            const listContainer = document.querySelector('#expense-list .transaction-list-items');
            const entriesToShow = filteredEntries !== null ? filteredEntries : expenseEntries;

            listContainer.innerHTML = '';
            if (entriesToShow.length === 0) { listContainer.innerHTML += '<p class="no-data" data-i18n="no_expense_income_records">No expense/income records found.</p>'; return; }

            const groupedEntries = {};
            entriesToShow.forEach((entry, index) => { // 'index' here is from filteredEntries, not original
                const dateKey = new Date(entry.date).toISOString().split('T')[0];
                const originalIndex = expenseEntries.findIndex(e => e.id === entry.id); // Find index in original array

                if (!groupedEntries[dateKey]) {
                    groupedEntries[dateKey] = { items: [], typeSummary: { income: 0, expense: 0 } };
                }
                groupedEntries[dateKey].items.push({ ...entry, originalIndex });

                const amount = parseFloat(entry.amount);
                if (entry.type === 'Income') groupedEntries[dateKey].typeSummary.income += amount;
                else groupedEntries[dateKey].typeSummary.expense += amount;
            });

            const sortedDates = Object.keys(groupedEntries).sort().reverse();

            for (const dateKey of sortedDates) {
                const groupData = groupedEntries[dateKey];
                const displayDate = new Date(dateKey).toDateString();
                const summaries = groupData.typeSummary;

                const groupElement = document.createElement('div');
                groupElement.className = 'grouped-transaction';

                groupElement.innerHTML = `
                    <div class="group-header" onclick="toggleGroup(this.parentElement)">
                        <span>${displayDate}</span>
                        <span data-i18n="income">Income</span>: ${formatNumber(summaries.income)} | <span data-i18n="expense">Expense</span>: ${formatNumber(summaries.expense)}
                    </div>
                    <div class="group-details">
                        ${groupData.items.map(item => {
                            const amountClass = item.type === 'Income' ? 'positive' : 'negative';
                            return `
                                <div class="transaction-item" onclick="handleItemHover(this)">
                                    <div class="transaction-header">
                                        <span class="transaction-type">${item.category}</span>
                                        <span class="transaction-amount ${amountClass}">${formatNumber(item.amount)}</span>
                                    </div>
                                    <div class="transaction-details-mobile">
                                        <span class="transaction-date">${new Date(item.date).toLocaleTimeString()}</span>
                                        <span class="transaction-info-item"><strong data-i18n="type">Type:</strong> ${item.type}</span>
                                        <span class="transaction-info-item"><strong data-i18n="method">Method:</strong> ${item.paymentMethod}</span>
                                        ${item.note ? `<span class="transaction-info-item"><strong data-i18n="note">Note:</strong> ${item.note.length > 50 ? item.note.substring(0, 50) + '...' : item.note}</span>` : ''}
                                    </div>
                                    <div class="transaction-actions">
                                        <button class="action-button-text edit" onclick="editExpenseEntry(${item.originalIndex})"><i class="fas fa-edit"></i></button>
                                        <button class="action-button-text delete" onclick="deleteExpenseEntry(${item.originalIndex})"><i class="fas fa-trash-alt"></i></button>
                                    </div>
                                </div>
                            `;
                        }).join('')}
                    </div>
                `;
                listContainer.appendChild(groupElement);
            }
        }

        // Add to translations
        translations.en.no_expense_income_records = 'No expense/income records found.';
        translations.my.no_expense_income_records = 'အသုံးစရိတ်/ဝင်ငွေ မှတ်တမ်းများ မတွေ့ပါ။';
        translations.en.method = 'Method:';
        translations.my.method = 'နည်းလမ်း:';

        function editExpenseEntry(index) {
            if (index < 0 || index >= expenseEntries.length) { showToast(translations[currentLanguage]["error_loading_expense_entry"], "error"); return; }
            const entry = expenseEntries[index];

            document.getElementById('expense-date').value = entry.date;
            document.getElementById('expense-type').value = entry.type;

            const categorySelect = document.getElementById('expense-category');
            const categoryOtherInput = document.getElementById('expense-category-other');
            const categoryRemoveButton = document.querySelector('#expense-category + input[type="text"] + button');

            if (entry.category && savedExpenseCategories[entry.category] || !['Rent', 'Sales'].includes(entry.category)) {
                categorySelect.value = 'other';
                categoryOtherInput.value = entry.category;
                categoryOtherInput.style.display = 'block';
                if (categoryRemoveButton) categoryRemoveButton.style.display = 'inline-block';
                if (!savedExpenseCategories[entry.category]) {
                    savedExpenseCategories[entry.category] = entry.category;
                    try { localStorage.setItem('moneyManager_savedExpenseCategories', JSON.stringify(savedExpenseCategories)); } catch (e) { console.error("Error saving custom expense category during edit:", e); }
                    addOptionToSelect('expense-category', entry.category);
                }
            } else if (entry.category) {
                categorySelect.value = entry.category;
                categoryOtherInput.style.display = 'none'; categoryOtherInput.value = '';
                if (categoryRemoveButton) categoryRemoveButton.style.display = 'none';
            } else {
                categorySelect.value = 'Rent';
                categoryOtherInput.style.display = 'none'; categoryOtherInput.value = '';
                if (categoryRemoveButton) categoryRemoveButton.style.display = 'none';
            }

            document.getElementById('expense-amount').value = formatNumber(entry.amount);

            const paymentMethodSelect = document.getElementById('expense-payment-method');
            const paymentMethodOtherInput = document.getElementById('expense-payment-method-other');
            const paymentMethodRemoveButton = document.querySelector('#expense-payment-method + input[type="text"] + button');

            if (entry.paymentMethod && savedExpensePaymentMethods[entry.paymentMethod] || !['E-Money', 'Cash'].includes(entry.paymentMethod)) {
                paymentMethodSelect.value = 'Other';
                paymentMethodOtherInput.value = entry.paymentMethod;
                paymentMethodOtherInput.style.display = 'block';
                if (paymentMethodRemoveButton) paymentMethodRemoveButton.style.display = 'inline-block';
                if (!savedExpensePaymentMethods[entry.paymentMethod]) {
                    savedExpensePaymentMethods[entry.paymentMethod] = entry.paymentMethod;
                    try { localStorage.setItem('moneyManager_savedExpensePaymentMethods', JSON.stringify(savedExpensePaymentMethods)); } catch (e) { console.error("Error saving custom payment method during edit:", e); }
                    addOptionToSelect('expense-payment-method', entry.paymentMethod);
                }
            } else if (entry.paymentMethod) {
                paymentMethodSelect.value = entry.paymentMethod;
                paymentMethodOtherInput.style.display = 'none'; paymentMethodOtherInput.value = '';
                if (paymentMethodRemoveButton) paymentMethodRemoveButton.style.display = 'none';
            } else {
                paymentMethodSelect.value = 'E-Money';
                paymentMethodOtherInput.style.display = 'none'; paymentMethodOtherInput.value = '';
                if (paymentMethodRemoveButton) paymentMethodRemoveButton.style.display = 'none';
            }

            document.getElementById('expense-note').value = entry.note || '';
            updateExpenseCategoryVisibility();

            // Set editing state and remove from array temporarily
            isEditingExpenseEntry = true;
            expenseEntryBeingEdited = { ...entry, originalIndex: index }; // Store context
            expenseEntries.splice(index, 1);
            try {
                localStorage.setItem('moneyManager_expenseEntries', JSON.stringify(expenseEntries));
            } catch (e) { console.error("Error saving expense entries after removing for edit:", e); }

            updateExpenseSummaries(); renderExpenseEntries();
            showToast(translations[currentLanguage]["expense_entry_loaded_for_editing"]);
            window.scrollTo(0, 0);
        }

        // Add to translations
        translations.en.error_loading_expense_entry = 'Error loading expense entry for editing.';
        translations.my.error_loading_expense_entry = 'အသုံးစရိတ် မှတ်တမ်းကို တည်းဖြတ်ရန် ဖွင့်ရာတွင် အမှားဖြစ်ပွားပါသည်။';
        translations.en.expense_entry_loaded_for_editing = 'Expense entry loaded for editing';
        translations.my.expense_entry_loaded_for_editing = 'အသုံးစရိတ် မှတ်တမ်း တည်းဖြတ်ရန် ဖွင့်ပြီး';

        function deleteExpenseEntry(index) {
            if (index < 0 || index >= expenseEntries.length) { showToast(translations[currentLanguage]["error_deleting_expense_entry"], "error"); return; }
            if (confirm(translations[currentLanguage]["confirm_delete_entry"])) {
                expenseEntries.splice(index, 1);
                try {
                    localStorage.setItem('moneyManager_expenseEntries', JSON.stringify(expenseEntries));
                    showToast(translations[currentLanguage]["entry_deleted_success"], 'success');
                } catch (e) {
                    console.error("Error saving expense entries after delete:", e);
                    showToast(translations[currentLanguage]["error_saving_after_deletion"], 'error');
                }
                updateExpenseSummaries(); renderExpenseEntries();
                // Redraw charts if expense tab is active
                if (document.getElementById('expense').classList.contains('active')) {
                    drawExpenseCharts();
                }
            }
        }

        // Add to translations
        translations.en.confirm_delete_entry = 'Are you sure you want to delete this entry?';
        translations.my.confirm_delete_entry = 'ဤမှတ်တမ်းကို ဖျက်ရန် သေချာပါသလား?';
        translations.en.entry_deleted_success = 'Entry deleted successfully';
        translations.my.entry_deleted_success = 'မှတ်တမ်း ဖျက်ပြီး အောင်မြင်ပါသည်';
        translations.en.error_deleting_expense_entry = 'Error deleting expense entry.';
        translations.my.error_deleting_expense_entry = 'အသုံးစရိတ် မှတ်တမ်း ဖျက်ရန် အမှားဖြစ်ပွားပါသည်။';

        function filterExpenses() {
            const typeFilter = document.getElementById('expense-filter-type').value;
            const categoryFilter = document.getElementById('expense-filter-category').value.toLowerCase();
            const dateFilterValue = document.getElementById('expense-filter-date').value;

            let filtered = expenseEntries;

            if (typeFilter !== 'all') filtered = filtered.filter(entry => entry.type === typeFilter);
            if (categoryFilter) filtered = filtered.filter(entry => entry.category.toLowerCase().includes(categoryFilter));
            if (dateFilterValue) {
                try {
                    const filterDate = new Date(dateFilterValue); filterDate.setHours(0, 0, 0, 0);
                    filtered = filtered.filter(entry => {
                        const entryDateTime = new Date(entry.date);
                        if (isNaN(entryDateTime.getTime())) return false;
                        return entryDateTime.getFullYear() === filterDate.getFullYear() &&
                               entryDateTime.getMonth() === filterDate.getMonth() &&
                               entryDateTime.getDate() === filterDate.getDate();
                    });
                } catch (e) { console.error("Error applying date filter for expenses:", e); showToast(translations[currentLanguage]["error_applying_date_filter"], "error"); filtered = []; }
            }

            renderExpenseEntries(filtered);
            updateExpenseSummaries();
        }

        function resetExpenseFilters() {
            document.getElementById('expense-filter-type').value = 'all';
            document.getElementById('expense-filter-category').value = '';
            document.getElementById('expense-filter-date').value = '';
            renderExpenseEntries();
            updateExpenseSummaries();
        }

        function updateExpenseSummaries() {
            const dateFilterValue = document.getElementById('expense-filter-date').value;
            let startDate, endDate;

            if (dateFilterValue) {
                const filterDate = new Date(dateFilterValue);
                startDate = new Date(filterDate); startDate.setHours(0, 0, 0, 0);
                endDate = new Date(filterDate); endDate.setHours(23, 59, 59, 999);
            } else {
                const today = new Date();
                startDate = new Date(today); startDate.setHours(0, 0, 0, 0);
                endDate = new Date(today); endDate.setHours(23, 59, 59, 999);
            }

            let dailyIncome = 0; let dailyExpenses = 0;

            expenseEntries.forEach(entry => {
                const entryDate = new Date(entry.date);
                if (entryDate >= startDate && entryDate <= endDate) {
                    const amount = parseFloat(entry.amount);
                    if (entry.type === 'Income') dailyIncome += amount;
                    else dailyExpenses += amount;
                }
            });

            const netBalance = dailyIncome - dailyExpenses;

            document.getElementById('daily-total-income').textContent = formatNumber(dailyIncome);
            document.getElementById('daily-total-expenses').textContent = formatNumber(dailyExpenses);
            document.getElementById('expense-daily-net-balance').textContent = formatNumber(netBalance);
            const netBalanceElement = document.getElementById('expense-daily-net-balance');
            netBalanceElement.className = netBalance >= 0 ? 'positive' : 'negative';
        }

        function updatePeriodicalExpenseSummaries() {
            const periodType = document.getElementById('period-type').value;
            const now = new Date();

            let startDate = new Date();
            let endDate = new Date();

            if (periodType === 'week') {
                startDate.setDate(now.getDate() - now.getDay()); startDate.setHours(0, 0, 0, 0);
                endDate.setDate(now.getDate() + (6 - now.getDay())); endDate.setHours(23, 59, 59, 999);
            } else if (periodType === 'month') {
                startDate.setDate(1); startDate.setHours(0, 0, 0, 0);
                endDate.setMonth(now.getMonth() + 1); endDate.setDate(0); endDate.setHours(23, 59, 59, 999);
            } else if (periodType === 'year') {
                startDate.setMonth(0); startDate.setDate(1); startDate.setHours(0, 0, 0, 0);
                endDate.setFullYear(now.getFullYear() + 1); endDate.setMonth(0); endDate.setDate(0); endDate.setHours(23, 59, 59, 999);
            }

            let periodicalIncome = 0; let periodicalExpenses = 0;

            expenseEntries.forEach(entry => {
                const entryDate = new Date(entry.date);
                if (entryDate >= startDate && entryDate <= endDate) {
                    const amount = parseFloat(entry.amount);
                    if (entry.type === 'Income') periodicalIncome += amount;
                    else periodicalExpenses += amount;
                }
            });

            const periodicalNetBalance = periodicalIncome - periodicalExpenses;

            document.getElementById('periodical-total-income').textContent = formatNumber(periodicalIncome);
            document.getElementById('periodical-total-expenses').textContent = formatNumber(periodicalExpenses);
            document.getElementById('periodical-net-balance').textContent = formatNumber(periodicalNetBalance);
            const periodicalNetBalanceElement = document.getElementById('periodical-net-balance');
            periodicalNetBalanceElement.className = periodicalNetBalance >= 0 ? 'positive' : 'negative';
        }

        function updateExpenseTabUI() {
            updateExpenseSummaries();
            updatePeriodicalExpenseSummaries();
            renderExpenseEntries();
            updateSummariesBasedOnCurrentView();
        }

        // --- MAIN APPLICATION INITIALIZATION ---
        document.addEventListener('DOMContentLoaded', function() {
            initializeDarkMode(); // Initialize dark mode first
            setLanguage(currentLanguage); // Set language after DOM load
            initializeLockScreen();
            updateDateTimeFields();
            loadData();

            // Ensure initial charts view is active and others are hidden
            // Initially set all tabs to inactive, then activate the charts view
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            document.getElementById('initial-charts-view').classList.add('active');

            // Render initial data and summaries
            // Call the update functions that render lists and summaries
            updateTransactionList(); // Render the transaction list
            updateMoneyList();       // Render the money records list
            renderExpenseEntries();  // Render the expense entries list
            renderDebts();           // Render the debts/credits list

            // Initial summary updates based on loaded data
            updateExpenseSummaries();
            updatePeriodicalExpenseSummaries();
            updateSummariesBasedOnCurrentView();

            // Draw charts on initial load
            drawTransactionCharts();
            drawDailyMoneyCharts();
            drawExpenseCharts();

            // Set default date for opening balance
            if (document.getElementById('opening-date')) {
                document.getElementById('opening-date').value = new Date().toISOString().split('T')[0];
            }

            // Event listeners for user activity to reset the lock timer
            document.addEventListener('mousemove', resetLockTimer);
            document.addEventListener('mousedown', resetLockTimer);
            document.addEventListener('keydown', resetLockTimer);
            document.addEventListener('touchstart', resetLockTimer);
            // Also track clicks on interactive elements to reset the timer
            document.addEventListener('click', resetLockTimer);
            document.addEventListener('scroll', resetLockTimer); // Reset timer on scroll too

            // Ensure lock screen is displayed correctly on initial load if enabled
            if (isScreenLockEnabled && !permanentlyLocked) {
                showLockScreen(translations[currentLanguage]["lock_screen_message"]);
            } else {
                hideLockScreen();
            }
        });

        // --- TAB SWITCHING LOGIC ---
        function switchTab(tabId) {
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));

            // Find the correct tab element based on the onclick attribute
            const activeTabElement = document.querySelector(`.tab[onclick*="'${tabId}'"]`);
            if (activeTabElement) {
                activeTabElement.classList.add('active');
            }
            document.getElementById(tabId).classList.add('active');

            // Hide the initial charts view if switching to another tab
            if (tabId !== 'initial-charts-view') {
                document.getElementById('initial-charts-view').classList.remove('active');
            }

            updateSummariesBasedOnCurrentView();
            resetLockTimer();

            // Ensure charts are drawn when their respective tabs become active
            if (tabId === 'transaction') {
                drawTransactionCharts();
            } else if (tabId === 'daily-money') {
                drawDailyMoneyCharts();
            } else if (tabId === 'expense') {
                drawExpenseCharts();
            } else if (tabId === 'opening') {
                // Ensure opening balances are displayed correctly
                document.getElementById('opening-emoney').value = '';
                document.getElementById('opening-cash').value = '';
            } else if (tabId === 'debt') {
                renderDebts(); // Re-render debts when tab is activated
            }
        }

        // Dummy function for balance display, replaced by specific updates
        function updateBalanceDisplay() {
            // This function might be redundant now as balances are updated in specific tab functions.
            // If needed, it could call updateTransactionTabBalances(), updateDailySummaries(), etc.
            updateTransactionTabBalances();
            updateExpenseSummaries();
            updatePeriodicalExpenseSummaries();
            updateSummariesBasedOnCurrentView();
        }

        // --- SAVE DATA ON PAGE UNLOAD ---
        window.addEventListener('beforeunload', saveData);

        // --- CLEAR FORM AFTER ADDING TRANSACTION ---
        function clearTransactionForm() {
            document.getElementById('transaction-id').value = '';
            document.getElementById('transaction-date').value = '';
            document.getElementById('transaction-type').value = 'Wave Money';
            document.getElementById('transaction-type-other').value = ''; document.getElementById('transaction-type-other').style.display = 'none';
            const removeTransactionTypeButton = document.querySelector('#transaction-type + input[type="text"] + button');
            if(removeTransactionTypeButton) removeTransactionTypeButton.style.display = 'none'; // Hide remove button
            document.getElementById('transaction-action').value = 'Cash In';
            document.getElementById('transaction-amount').value = '';
            document.getElementById('transaction-commission').value = '';
            document.getElementById('transaction-fee').value = '';
            document.getElementById('transaction-phone').value = '';
            document.getElementById('transaction-note').value = '';
            updateDateTimeFields();
        }