<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>My Money Manager</title>

    <!-- PWA Manifest -->
    <link rel="manifest" href="/manifest.json">

    <!-- PWA Icons -->
    <!-- Ensure you have these icons in the /icons folder -->
    <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
    <link rel="shortcut icon" href="/icons/favicon.ico">

    <!-- PWA Service Worker Registration -->
    <script>
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/sw.js')
                    .then(registration => {
                        console.log('ServiceWorker registration successful with scope: ', registration.scope);
                    })
                    .catch(error => {
                        console.log('ServiceWorker registration failed: ', error);
                    });
            });
        }
    </script>

    <style>
        /* --- Color Palette and Typography --- */
        :root {
            --primary: #4CAF50; /* Green */
            --primary-dark: #388E3C; /* Darker Green */
            --secondary: #2196F3; /* Blue */
            --danger: #F44336; /* Red */
            --light-gray: #f5f5f5;
            --medium-gray: #e0e0e0;
            --dark-gray: #757575; /* Medium Dark Gray */
            --text: #212121; /* Darkest Text */
            --text-light: #9E9E9E; /* Light Gray Text */
            --positive: #2ecc71; /* Bright Green for positive amounts */
            --negative: #e74c3c; /* Bright Red for negative amounts */
            --card-background: #ffffff; /* White for cards */
            --card-hover-shadow: 0 8px 20px rgba(0, 0, 0, 0.15); /* Deeper shadow on hover */
            --input-border-color: var(--medium-gray);
            --input-focus-border-color: var(--primary);
            --button-hover-bg: var(--primary-dark);
            --transition-fast: 0.2s ease;
            --transition-medium: 0.3s ease;
            --modal-background: rgba(0, 0, 0, 0.7); /* Dimmed background for modals */
        }

        /* --- Global Reset and Base Styles --- */
        * {
            box-sizing: border-box;
            font-family: 'Segoe UI', 'Roboto', 'Helvetica Neue', sans-serif;
            margin: 0;
            padding: 0;
        }

        body {
            background-color: #f8f9fa; /* Light background for the page */
            color: var(--text);
            line-height: 1.6;
            padding-bottom: 0;
            overflow-x: hidden; /* Prevent horizontal scroll */
        }

        /* --- Lock Screen Styles --- */
        #lock-screen-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--modal-background); /* Dimmed background */
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            opacity: 0;
            visibility: hidden;
            transition: opacity var(--transition-medium), visibility var(--transition-medium);
            overflow: hidden; /* Crucial for backdrop-filter to work correctly */
        }

        /* Add blur to the lock screen background */
        #lock-screen-overlay::before {
            content: '';
            position: absolute;
            top: -5px; /* Extend slightly to catch blur edges */
            left: -5px;
            right: -5px;
            bottom: -5px;
            background: inherit; /* Inherit the modal background */
            filter: blur(10px); /* Apply the blur */
            z-index: -1; /* Place it behind the content */
        }

        #lock-screen-overlay.visible {
            opacity: 1;
            visibility: visible;
        }

        #lock-screen-content {
            position: relative; /* Ensure it's above the pseudo-element */
            z-index: 1; /* Place it above the blur */
            text-align: center;
            background-color: rgba(255, 255, 255, 0.05); /* Subtle translucent background */
            padding: 40px 50px; /* Slightly more padding */
            border-radius: 12px; /* Rounded corners */
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4); /* More pronounced shadow */
            border: 1px solid rgba(255, 255, 255, 0.1); /* Subtle border */
        }

        #lock-screen-title {
            font-size: 2.8em; /* Larger title */
            margin-bottom: 25px;
            font-weight: 700; /* Bold */
            color: var(--primary); /* Use primary color for emphasis */
            text-shadow: 0 2px 5px rgba(0,0,0,0.3); /* Text shadow for depth */
        }

        #lock-screen-message {
            font-size: 1.15em; /* Slightly larger message text */
            margin-bottom: 35px;
            color: var(--text-light);
            opacity: 0.9;
        }

        #lock-screen-pin-input {
            font-size: 2.2em; /* Larger font for PIN display */
            margin-bottom: 30px;
            padding: 15px 20px;
            border: 3px solid var(--primary); /* Thicker primary border */
            border-radius: 8px;
            background-color: transparent;
            color: white;
            width: 180px; /* Wider input field */
            text-align: center;
            letter-spacing: 10px; /* More space between digits */
            box-shadow: inset 0 0 10px rgba(0,0,0,0.5); /* Inner shadow for depth */
        }

        #lock-screen-pin-input:focus {
            outline: none;
            border-color: var(--secondary); /* Secondary color on focus */
            box-shadow: inset 0 0 10px rgba(33, 150, 243, 0.5), 0 0 15px rgba(33, 150, 243, 0.4); /* Focus glow effect */
        }

        #lock-screen-keyboard .key-row {
            display: flex;
            gap: 15px; /* Increased gap between keys */
            margin-bottom: 15px;
            justify-content: center;
        }

        #lock-screen-keyboard button {
            min-width: 70px; /* Wider keys */
            padding: 18px 25px; /* More padding for keys */
            font-size: 1.4em; /* Larger font for keys */
            background-color: var(--dark-gray); /* Use dark gray for keys */
            color: white;
            border: none;
            border-radius: 8px; /* More rounded keys */
            cursor: pointer;
            transition: background-color var(--transition-fast), transform 0.1s ease-out; /* Add subtle transform on hover */
            box-shadow: 0 4px 8px rgba(0,0,0,0.2); /* Key shadow */
        }

        #lock-screen-keyboard button:hover {
            background-color: #888888; /* Slightly lighter gray on hover */
            transform: translateY(-2px); /* Slight lift on hover */
        }

        #lock-screen-keyboard .key-delete {
            background-color: var(--danger); /* Red for delete key */
        }

        #lock-screen-keyboard .key-delete:hover {
            background-color: #d32f2f; /* Darker red on hover */
        }

        #lock-screen-error-message {
            color: var(--danger);
            font-weight: 500;
            min-height: 20px;
            margin-top: 10px; /* Space above error message */
            font-size: 1.05em;
        }

        #lock-screen-footer {
            margin-top: 30px;
            font-size: 0.9em;
            color: rgba(255, 255, 255, 0.7);
        }

        /* --- Main Layout and Navigation --- */
        .container {
            max-width: 1000px;
            margin: 20px auto; /* Add some top margin */
            padding: 25px; /* Increased padding */
            background-color: var(--card-background); /* Use card background for container */
            border-radius: 12px; /* Rounded container corners */
            box-shadow: 0 5px 15px rgba(0,0,0,0.08); /* Softer shadow for container */
        }

        .header {
            text-align: center;
            margin-bottom: 35px; /* More space below header */
            background: linear-gradient(135deg, var(--primary), var(--primary-dark)); /* Gradient header */
            color: white;
            padding: 25px 20px; /* Increased padding */
            border-radius: 12px; /* Rounded header */
            box-shadow: 0 6px 10px rgba(0,0,0,0.12); /* Enhanced header shadow */
        }

        .header h1 {
            font-weight: 600; /* Slightly bolder title */
            margin-bottom: 12px;
            font-size: 2.5em; /* Larger title font */
        }

        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }

        /* --- Tabs --- */
        .tabs {
            display: flex;
            justify-content: space-around; /* Distribute tabs evenly */
            margin-bottom: 25px;
            border-bottom: 2px solid var(--medium-gray);
            background-color: white;
            border-radius: 12px 12px 0 0;
            overflow: hidden;
            box-shadow: 0 2px 0px var(--light-gray);
        }

        .tab {
            padding: 18px 25px;
            cursor: pointer;
            flex: 1; /* Allow tabs to grow and shrink */
            min-width: 100px; /* Minimum width for tabs */
            text-align: center;
            font-weight: 500;
            color: var(--dark-gray);
            transition: all var(--transition-medium);
            border-bottom: 4px solid transparent;
            font-size: 1.05em;
            position: relative; /* For active state indicator */
        }

        .tab:hover {
            background-color: rgba(0,0,0,0.04);
            color: var(--text);
        }

        .tab.active {
            color: var(--primary);
            border-bottom: 4px solid var(--primary); /* Indicator for active tab */
            background-color: rgba(76, 175, 80, 0.07);
        }

        /* Tab content styling */
        .tab-content {
            display: none;
            padding: 30px;
            background-color: var(--card-background);
            border-radius: 0 0 12px 12px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.07);
            animation: fadeIn 0.4s ease;
        }

        .tab-content.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(15px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* --- Card Styles --- */
        .card-container {
          display: grid;
          grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); /* Responsive grid for cards */
          gap: 25px;
          margin-bottom: 30px;
        }

        .card {
          background: var(--card-background);
          border-radius: 10px;
          box-shadow: 0 3px 8px rgba(0,0,0,0.06);
          padding: 25px 20px;
          text-align: center;
          transition: transform var(--transition-medium), box-shadow var(--transition-medium);
          border: 1px solid var(--light-gray);
        }

        .card:hover {
            transform: translateY(-5px);
            box-shadow: var(--card-hover-shadow);
        }

        .card h3 {
            font-size: 17px;
            color: var(--dark-gray);
            margin-bottom: 12px;
            font-weight: 500;
        }

        .card-amount {
            font-size: 32px;
            font-weight: 700;
            color: var(--text);
        }

        /* --- Form Section Styles --- */
        .form-section {
            background-color: var(--card-background);
            padding: 30px;
            border-radius: 12px;
            margin-bottom: 30px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.07);
        }

        .form-section h2 {
            margin-bottom: 25px;
            color: var(--primary);
            font-weight: 600;
            font-size: 24px;
        }

        .form-section h3 {
            margin-bottom: 20px;
            color: var(--primary);
            font-weight: 600;
            font-size: 20px;
        }

        .form-group {
            margin-bottom: 25px;
        }

        .form-group label {
            display: block;
            margin-bottom: 10px;
            font-weight: 500;
            color: var(--text);
            font-size: 16px;
        }

        /* Input, Select, Textarea styling */
        input[type="text"],
        input[type="password"],
        input[type="datetime-local"],
        input[type="date"],
        select,
        textarea {
            width: 100%;
            padding: 15px 18px;
            border: 1px solid var(--input-border-color);
            border-radius: 8px;
            font-size: 16px;
            transition: border var(--transition-fast), box-shadow var(--transition-fast);
            color: var(--text); /* Ensure text color is consistent */
            background-color: var(--card-background); /* Ensure inputs have background */
        }

        input:focus, select:focus, textarea:focus {
            outline: none;
            border-color: var(--input-focus-border-color);
            box-shadow: 0 0 0 4px rgba(76, 175, 80, 0.25);
        }

        /* Styling for select elements to look more like inputs */
        select {
            appearance: none; /* Remove default arrow */
            background-image: url('data:image/svg+xml;charset=UTF-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="%23757575"><path d="M7.293 10.293a1 1 0 0 1 1.414 0L10.5 12.586l2.293-2.293a1 1 0 0 1 1.414 1.414l-3.5 3.5a1 1 0 0 1-1.414 0l-3.5-3.5a1 1 0 0 1 0-1.414z"/></svg>'); /* Custom arrow */
            background-repeat: no-repeat;
            background-position: right 15px top 50%;
            background-size: 16px;
            padding-right: 45px; /* Space for the custom arrow */
        }

        /* Button styling */
        button {
            background-color: var(--primary);
            color: white;
            border: none;
            padding: 14px 25px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 500;
            transition: all var(--transition-medium);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        button:hover {
            background-color: var(--button-hover-bg);
            transform: translateY(-3px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.15);
        }

        button.secondary {
            background-color: white;
            color: var(--primary);
            border: 1px solid var(--primary);
            padding: 14px 25px;
        }

        button.secondary:hover {
            background-color: rgba(76, 175, 80, 0.07);
            transform: translateY(-3px);
        }

        button.danger {
            background-color: var(--danger);
        }

        button.danger:hover {
            background-color: #d32f2f;
        }

        .button-group {
            display: flex;
            gap: 15px;
            margin-top: 25px;
        }

        .button-group button {
            flex: 1; /* Distribute space equally among buttons */
        }

        /* --- Transaction List Styles --- */
        .transaction-list {
            margin-top: 25px;
        }

        .transaction-list h2 {
            margin-bottom: 20px;
            color: var(--primary);
            font-weight: 600;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 20px;
            background-color: var(--card-background);
            border-radius: 10px;
            border: 1px solid var(--light-gray);
            box-shadow: 0 3px 8px rgba(0,0,0,0.06);
            transition: background-color var(--transition-fast);
        }

        .transaction-list h2:hover {
            background-color: var(--light-gray);
        }

        .transaction-list h2 .arrow {
            transform: rotate(0deg);
            transition: transform var(--transition-medium);
            font-size: 0.9em;
            opacity: 0.8;
        }

        .transaction-list.expanded h2 .arrow {
            transform: rotate(180deg);
        }

        .transaction-list-items {
            display: none;
            margin-top: 15px;
        }

        .transaction-list.expanded .transaction-list-items {
            display: block;
        }

        .grouped-transaction {
            margin-bottom: 20px;
            background-color: var(--card-background);
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.08);
            overflow: hidden;
        }

        .group-header {
            background-color: var(--light-gray);
            padding: 18px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            font-weight: 500;
            border-left: 5px solid var(--primary);
            transition: background-color var(--transition-fast);
            font-size: 1.05em;
        }

        .group-header:hover {
            background-color: #e9e9e9;
        }

        .group-header span:last-child {
            font-size: 0.9em;
            color: var(--dark-gray);
        }

        .group-details {
            padding: 0;
            max-height: 0;
            overflow: hidden;
            transition: max-height var(--transition-medium), padding var(--transition-medium);
        }

        .grouped-transaction.expanded .group-details {
            max-height: 2000px; /* Large enough to contain content */
            padding: 15px 0;
        }

        .transaction-item {
            background-color: var(--card-background);
            padding: 15px 20px;
            margin: 0 15px 15px 15px; /* Add margin to align with group header */
            border-radius: 8px;
            box-shadow: 0 3px 8px rgba(0,0,0,0.05);
            position: relative;
            transition: all var(--transition-fast);
            border-left: 5px solid var(--primary);
            cursor: pointer;
            display: flex;
            flex-direction: column;
            justify-content: center;
            border-top-right-radius: 0;
            border-bottom-right-radius: 0;
            border-right: none;
            border-top: none;
            border-bottom: none;
        }

        .transaction-item:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 15px rgba(0,0,0,0.1);
        }

        .transaction-item.active {
            background-color: var(--light-gray); /* Highlight active item */
            transform: none !important; /* Remove hover effect when active */
            box-shadow: 0 3px 8px rgba(0,0,0,0.05); /* Reset shadow */
        }

        .transaction-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
        }

        .transaction-type {
            font-weight: 600;
            color: var(--primary);
            font-size: 15px;
        }

        .transaction-amount {
            font-weight: 700;
            font-size: 16px;
        }

        .transaction-amount.positive { color: var(--positive); }
        .transaction-amount.negative { color: var(--negative); }

        .transaction-details-mobile {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
            font-size: 13px;
            color: var(--dark-gray);
            width: 100%;
        }

        .transaction-info-item {
            display: inline-flex; /* Use inline-flex for better alignment */
            align-items: center;
            gap: 5px; /* Space between label and value */
        }

        .transaction-details-mobile .transaction-date {
            font-size: 12px;
            color: var(--text-light);
        }

        .transaction-actions {
            position: absolute;
            bottom: 10px;
            right: 10px;
            display: none;
            gap: 10px;
            z-index: 10;
        }

        .transaction-item:hover .transaction-actions,
        .transaction-item.active .transaction-actions {
            display: flex;
        }

        .action-button-text {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 7px 12px;
            border-radius: 6px;
            font-weight: 500;
            font-size: 13px;
            transition: all var(--transition-fast);
            border: 1px solid transparent;
            gap: 6px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .action-button-text.edit {
            background-color: var(--secondary);
            color: white;
            border-color: var(--secondary);
        }

        .action-button-text.edit:hover {
            background-color: #1976D2;
            border-color: #1976D2;
        }

        .action-button-text.delete {
            background-color: var(--danger);
            color: white;
            border-color: var(--danger);
        }

        .action-button-text.delete:hover {
            background-color: #d32f2f;
            border-color: #d32f2f;
        }

        /* --- Summary Section --- */
        .summary-section {
            background-color: var(--card-background);
            padding: 25px;
            border-radius: 12px;
            margin-top: 30px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.07);
            border: 1px solid var(--light-gray);
        }

        .summary-section h2 {
            margin-bottom: 20px;
            color: var(--primary);
            font-weight: 600;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 20px;
            background-color: var(--card-background);
            border-radius: 10px;
            border: 1px solid var(--light-gray);
            box-shadow: 0 3px 8px rgba(0,0,0,0.06);
            transition: background-color var(--transition-fast);
        }

        .summary-section h2:hover {
             background-color: var(--light-gray);
        }

        .summary-section h2 .arrow {
            transform: rotate(0deg);
            transition: transform var(--transition-medium);
            font-size: 0.9em;
            opacity: 0.8;
        }

        .summary-section.expanded h2 .arrow {
            transform: rotate(180deg);
        }

        .summary-list {
            display: none;
            margin-top: 20px;
        }

        .summary-section.expanded .summary-list {
            display: block;
        }

        .summary-item {
            display: flex;
            justify-content: space-between;
            padding: 12px 5px;
            border-bottom: 1px solid var(--light-gray);
            font-size: 1.05em;
        }

        .summary-item:last-child {
            border-bottom: none;
        }

        .summary-label {
            font-weight: 500;
            color: var(--dark-gray);
        }

        /* --- Filter Section --- */
        .filter-section {
            display: flex;
            gap: 15px;
            margin-bottom: 25px;
            flex-wrap: wrap;
            align-items: center;
            padding: 20px;
            background-color: var(--card-background);
            border-radius: 10px;
            box-shadow: 0 3px 8px rgba(0,0,0,0.06);
            border: 1px solid var(--light-gray);
        }

        .filter-section select, .filter-section input {
            flex: 1;
            min-width: 160px;
            padding: 12px 15px;
            font-size: 15px;
        }

        .filter-section button {
            padding: 12px 20px;
            flex-shrink: 0;
            font-size: 15px;
        }

        /* --- Input Field Enhancements --- */
        .phone-input {
            position: relative;
        }

        .phone-prefix {
            position: absolute;
            left: 15px;
            top: 50%;
            transform: translateY(-50%);
            color: var(--dark-gray);
            pointer-events: none;
            z-index: 1;
            font-weight: 500;
        }

        .phone-input input {
            padding-left: 55px; /* Space for the prefix */
        }

        /* --- Backup Section --- */
        .backup-section {
            background-color: var(--card-background);
            padding: 30px;
            border-radius: 12px;
            margin-top: 30px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.07);
            border: 1px solid var(--light-gray);
        }

        .backup-section h2 {
            margin-bottom: 20px;
            color: var(--primary);
            font-weight: 600;
            font-size: 24px;
        }

        .backup-textarea {
            width: 100%;
            min-height: 150px;
            padding: 15px;
            border: 1px solid var(--input-border-color);
            border-radius: 8px;
            font-family: monospace;
            margin-bottom: 20px;
            resize: vertical;
            font-size: 14px;
        }

        .backup-textarea:focus {
             border-color: var(--input-focus-border-color);
             box-shadow: 0 0 0 4px rgba(76, 175, 80, 0.25);
        }

        /* --- Toast Notification --- */
        .toast {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background-color: var(--primary);
            color: white;
            padding: 15px 30px;
            border-radius: 8px;
            box-shadow: 0 6px 15px rgba(0,0,0,0.2);
            opacity: 0;
            transition: opacity var(--transition-medium);
            z-index: 1000;
            font-size: 1em;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 10px;
            pointer-events: none; /* Toast should not interfere with clicks */
        }

        .toast.show {
            opacity: 1;
        }

        .toast.error {
            background-color: var(--danger);
        }

        /* --- Export Buttons --- */
        .export-buttons-container {
            margin-top: 25px;
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .export-button {
            background-color: var(--secondary);
            color: white;
            border: none;
            padding: 12px 22px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 15px;
            font-weight: 500;
            transition: all var(--transition-medium);
            display: inline-flex;
            align-items: center;
            gap: 10px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }

        .export-button:hover {
            background-color: #1976D2;
            transform: translateY(-3px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.15);
        }

        .export-button i {
            font-size: 18px;
        }

        /* --- Message for No Data --- */
        .no-data {
            text-align: center;
            color: var(--dark-gray);
            margin-top: 20px;
            padding: 30px;
            font-size: 1.1em;
            opacity: 0.7;
        }

        /* --- Debts/Credits Tab Styles --- */
        .debt-form-section { /* Using the general form-section styling */ }

        .debt-list-item {
            background-color: var(--card-background);
            padding: 18px 20px;
            margin-bottom: 15px;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.08);
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: stretch;
            justify-content: center;
            border: 1px solid var(--light-gray);
        }

        .debt-item-summary {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            cursor: pointer;
            margin-bottom: 15px;
        }

        .debt-item-summary .debt-name {
            font-weight: 600;
            font-size: 18px;
            color: var(--primary);
        }

        .debt-item-summary .debt-amount {
            font-size: 20px;
            font-weight: 700;
        }

        .debt-item-details-expanded {
            display: none; /* Hidden by default */
            flex-direction: column;
            gap: 10px;
            font-size: 14px;
            color: var(--dark-gray);
            border-top: 1px solid var(--light-gray);
            padding-top: 15px;
        }

        .debt-item-details-expanded.visible {
            display: flex; /* Show when visible */
        }

        .debt-actions {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            margin-bottom: 10px;
            flex-wrap: wrap;
        }

        .debt-actions .action-button-text {
            font-size: 13px;
            padding: 7px 12px;
        }

        .debt-details {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            margin-bottom: 10px;
        }

        .debt-type {
            font-weight: 500;
            color: var(--dark-gray);
        }

        .debt-note {
            font-size: 13px;
            color: var(--text-light);
            margin-top: 5px;
            flex-grow: 1;
        }

        .debt-history-list {
            margin-top: 15px;
            padding-left: 15px;
            border-left: 3px solid var(--medium-gray);
        }

        .debt-history-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            font-size: 13px;
            color: var(--dark-gray);
            gap: 10px;
        }

        .debt-history-item span:first-child { /* Style for the date/type/note part */
            flex-grow: 1;
            margin-right: 10px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .debt-history-item .negative {
            color: var(--negative);
        }
        .debt-history-item .positive {
            color: var(--positive);
        }

        .debt-history-item .debt-history-actions {
             display: flex;
             gap: 6px;
             margin-left: 10px;
             flex-shrink: 0;
        }
        .debt-history-item .debt-history-actions .action-button-text {
             font-size: 11px;
             padding: 4px 8px;
        }

        .debt-suggestion-item {
            padding: 10px 15px;
            cursor: pointer;
            transition: background-color var(--transition-fast);
            font-size: 1.05em;
        }
        .debt-suggestion-item:hover {
            background-color: var(--light-gray);
        }

        /* --- Debt/Credit Tab Specific Styles --- */
        #debt-tab .form-group input, #debt-tab .form-group select {
            width: 100%;
        }

        #debt-tab .filter-section input {
            min-width: 200px;
            flex-grow: 2;
        }

        /* --- Debt Summary Totals --- */
        .debt-summary-totals {
            background-color: var(--light-gray);
            padding: 20px 25px;
            margin-top: 25px;
            border-radius: 10px;
            display: flex;
            justify-content: flex-end;
            gap: 40px;
            font-weight: 500;
            font-size: 17px;
            box-shadow: inset 0 3px 8px rgba(0,0,0,0.05);
        }

        .debt-summary-totals .total-payable,
        .debt-summary-totals .total-receivable {
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .debt-summary-totals .total-payable .label,
        .debt-summary-totals .total-receivable .label {
            color: var(--dark-gray);
            font-weight: 500;
        }

        .debt-summary-totals .total-payable .amount,
        .debt-summary-totals .total-receivable .amount {
            font-weight: 700;
        }

        .debt-summary-totals .total-payable .amount {
            color: var(--negative);
        }

        .debt-summary-totals .total-receivable .amount {
            color: var(--positive);
        }

        /* --- Media Queries for Responsiveness --- */
        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }

            .card-container {
                grid-template-columns: repeat(2, 1fr);
            }

            .button-group {
                flex-direction: column;
            }

            .filter-section {
                flex-direction: column;
                align-items: stretch;
            }

            .filter-section select, .filter-section input {
                min-width: auto;
                width: 100%;
            }

            .filter-section button {
                width: 100%;
            }

            .group-header {
                flex-direction: column;
                align-items: flex-start;
            }

            .group-header span:last-child {
                margin-top: 5px;
                font-size: 14px;
            }

            .export-buttons-container {
                flex-direction: column;
                align-items: stretch;
            }

            .export-button {
                width: 100%;
                justify-content: center;
            }

            .debt-list-item {
                flex-direction: column;
                align-items: flex-start;
            }

            .debt-item-summary {
                width: 100%;
                margin-bottom: 10px;
            }

            .debt-actions {
                width: 100%;
                justify-content: flex-end;
                margin-top: 10px;
            }

            .debt-item-details-expanded {
                width: 100%;
            }

            .debt-summary-totals {
                flex-direction: column;
                align-items: center;
                gap: 15px;
                font-size: 16px;
            }

            /* Lock screen adjustments for medium screens */
            #lock-screen-content {
                padding: 30px 40px;
            }
            #lock-screen-title {
                font-size: 2.2em;
            }
             #lock-screen-pin-input {
                font-size: 1.8em;
                width: 160px;
                letter-spacing: 7px;
            }
            #lock-screen-keyboard button {
                min-width: 60px;
                padding: 15px 20px;
                font-size: 1.2em;
            }
            #lock-screen-keyboard .key-row {
                gap: 10px;
            }
        }

        @media (max-width: 480px) {
            .header h1 {
                font-size: 2em;
            }
            .header p {
                font-size: 0.95em;
            }

            .tabs {
                flex-direction: column;
                border-bottom: none;
            }

            .tab {
                border-bottom: 3px solid var(--primary);
                border-right: none;
                border-radius: 0;
                margin-bottom: 5px;
            }

            .tab.active {
                background-color: rgba(76, 175, 80, 0.07);
                border-bottom: 3px solid var(--primary);
            }

            .tab-content {
                border-radius: 0 0 12px 12px;
            }

            .card-container {
                grid-template-columns: 1fr;
            }

            .transaction-item, .grouped-transaction, .summary-section, .form-section {
                padding: 20px;
            }

            .transaction-item {
                margin: 0 0 15px 0;
            }

            .transaction-header, .transaction-details-mobile {
                flex-direction: column;
                align-items: flex-start;
                gap: 5px;
            }

            .transaction-actions {
                position: static;
                margin-top: 10px;
                justify-content: center;
                width: 100%;
            }

            .debt-summary-totals {
                flex-direction: column;
                align-items: center;
                gap: 15px;
                font-size: 15px;
            }

            /* Lock screen adjustments for very small screens */
            #lock-screen-title {
                font-size: 1.8em;
            }
             #lock-screen-pin-input {
                font-size: 1.6em;
                width: 140px;
                letter-spacing: 6px;
            }
            #lock-screen-keyboard button {
                min-width: 55px;
                padding: 12px 15px;
                font-size: 1.15em;
            }
            #lock-screen-keyboard .key-row {
                gap: 8px;
            }
        }
    </style>
    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">

    <!-- Libraries for Excel and PDF export -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.17.5/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
</head>
<body>

    <!-- Lock Screen Overlay -->
    <div id="lock-screen-overlay">
        <div id="lock-screen-content">
            <div id="lock-screen-title">Money Manager</div>
            <div id="lock-screen-message">Your session has been locked due to inactivity.</div>
            <input type="password" id="lock-screen-pin-input" maxlength="4" readonly placeholder="----">
            <div id="lock-screen-error-message"></div>
            <div id="lock-screen-keyboard">
                <div class="key-row">
                    <button onclick="handleLockScreenInput('1')">1</button>
                    <button onclick="handleLockScreenInput('2')">2</button>
                    <button onclick="handleLockScreenInput('3')">3</button>
                </div>
                <div class="key-row">
                    <button onclick="handleLockScreenInput('4')">4</button>
                    <button onclick="handleLockScreenInput('5')">5</button>
                    <button onclick="handleLockScreenInput('6')">6</button>
                </div>
                <div class="key-row">
                    <button onclick="handleLockScreenInput('7')">7</button>
                    <button onclick="handleLockScreenInput('8')">8</button>
                    <button onclick="handleLockScreenInput('9')">9</button>
                </div>
                <div class="key-row">
                    <button onclick="handleLockScreenInput('0')">0</button>
                </div>
                <div class="key-row">
                    <button onclick="handleLockScreenInput('delete')" class="key-delete">DEL</button>
                </div>
            </div>
            <div id="lock-screen-footer">MKT Computer & Mobile Services</div>
        </div>
    </div>

    <div class="container">
        <div class="header">
            <h1>My Money Manager</h1>
            <p>Track your financial transactions and daily money records</p>
        </div>

        <div class="tabs">
            <div class="tab active" onclick="switchTab('opening')">Opening</div>
            <div class="tab" onclick="switchTab('transaction')">Transactions</div>
            <div class="tab" onclick="switchTab('daily-money')">Daily Money</div>
            <div class="tab" onclick="switchTab('expense')">Expenses</div>
            <div class="tab" onclick="switchTab('debt')">Debts/Credits</div>
        </div>

        <!-- Opening Tab -->
        <div id="opening" class="tab-content active">
            <div class="form-section">
                <h2>Set Opening Balances</h2>
                <div class="balance-section">
                    <div class="form-group">
                        <label for="opening-emoney">E-Money Balance</label>
                        <input type="text" id="opening-emoney" placeholder="Enter E-Money amount" oninput="formatInputAmount(this)">
                    </div>
                    <div class="form-group">
                        <label for="opening-cash">Cash Balance</label>
                        <input type="text" id="opening-cash" placeholder="Enter Cash amount" oninput="formatInputAmount(this)">
                    </div>
                </div>
                <button onclick="saveOpeningBalances()">Save Opening Balances</button>
            </div>

            <div class="backup-section">
                <h2>Data Backup/Restore</h2>
                <p><strong>Backup to Text Area:</strong></p>
                <textarea class="backup-textarea" id="backup-data" placeholder="Backup data will appear here"></textarea>
                <div class="button-group">
                    <button onclick="generateBackup()">Generate Text Backup</button>
                    <button onclick="restoreBackup()" class="secondary">Restore from Text</button>
                </div>

                <hr style="margin: 30px 0; border: 0; border-top: 1px solid var(--medium-gray);">

                <p><strong>Backup/Restore via File:</strong></p>
                <div class="button-group">
                    <button onclick="generateBackupFile()">Download Backup File</button>
                    <label for="backup-file-input" class="button secondary">
                        <i class="fas fa-upload"></i> Restore from File
                    </label>
                    <input type="file" id="backup-file-input" accept=".json" style="display: none;" onchange="restoreFromFile(event)">
                </div>
            </div>

            <!-- Export Buttons -->
            <div class="form-section">
                <h2>Export Data</h2>
                <div class="export-buttons-container">
                    <button class="export-button" onclick="exportToExcel()">
                        <i class="fas fa-file-excel"></i> Export Transactions to Excel
                    </button>
                    <button class="export-button" onclick="exportToPDF()">
                        <i class="fas fa-file-pdf"></i> Export Transactions to PDF
                    </button>
                </div>
            </div>

            <!-- Screen Lock Settings -->
            <div id="settings-lock-section" class="form-section">
                <h3>Application Security Settings</h3>
                <div class="form-group">
                    <div class="checkbox-wrapper">
                        <input type="checkbox" id="enable-screen-lock" onchange="saveLockSetting()">
                        <label for="enable-screen-lock">Enable Automatic Screen Lock</label>
                    </div>
                </div>
                <div class="form-group">
                    <label for="current-pin">Current PIN:</label>
                    <input type="password" id="current-pin" placeholder="Enter current PIN" maxlength="4">
                </div>
                <div class="form-group">
                    <label for="new-pin">New PIN:</label>
                    <input type="password" id="new-pin" placeholder="Enter new 4-digit PIN" maxlength="4">
                </div>
                <div class="form-group">
                    <label for="confirm-new-pin">Confirm New PIN:</label>
                    <input type="password" id="confirm-new-pin" placeholder="Confirm new PIN" maxlength="4">
                </div>
                <button onclick="handleChangePIN()">Change PIN</button>
                <div style="margin-top: 15px; font-size: 0.9em; color: var(--dark-gray);">
                    Note: If you forget your PIN, and the screen becomes permanently locked, all application data will be wiped.
                </div>
            </div>
        </div>

        <!-- Transaction Tab -->
        <div id="transaction" class="tab-content">
            <div class="card-container">
                <div class="card">
                    <h3>E-Money Balance</h3>
                    <div class="card-amount" id="e-money-balance">0.00</div>
                </div>
                <div class="card">
                    <h3>Cash Balance</h3>
                    <div class="card-amount" id="cash-balance">0.00</div>
                </div>
                <div class="card">
                    <h3>Total Balance</h3>
                    <div class="card-amount" id="total-balance">0.00</div>
                </div>
            </div>

            <div class="form-section">
                <h2>New Transaction</h2>
                <div class="form-group">
                    <label for="transaction-id">Transaction ID</label>
                    <input type="text" id="transaction-id" placeholder="Enter transaction ID">
                </div>
                <div class="form-group">
                    <label for="transaction-date">Date/Time</label>
                    <input type="datetime-local" id="transaction-date">
                </div>
                <div class="form-group">
                    <label for="transaction-type">Transaction Type</label>
                    <select id="transaction-type" onchange="updateTransactionType(); updateSavedCommissionAndFee();">
                        <option value="Wave Money">Wave Money</option>
                        <option value="Wave Pay">Wave Pay</option>
                        <option value="KBZ Pay">KBZ Pay</option>
                        <option value="Aya Pay">Aya Pay</option>
                        <option value="other">Other (Manual)</option>
                    </select>
                    <input type="text" id="transaction-type-other" style="display: none; margin-top: 5px;" placeholder="Enter type">
                </div>
                <div class="form-group">
                    <label for="transaction-action">Action</label>
                    <select id="transaction-action" onchange="updateSavedCommissionAndFee();">
                        <option value="Cash In">Cash In</option>
                        <option value="Cash Out">Cash Out</option>
                        <option value="Send Money">Send Money</option>
                        <option value="Received Money">Received Money</option>
                        <option value="Payment">Payment</option>
                        <option value="Phone Bill">Phone Bill</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="transaction-amount">Amount</label>
                    <input type="text" id="transaction-amount" placeholder="Enter amount" oninput="updateSavedCommissionAndFee(); formatInputAmount(this);">
                </div>
                <div class="form-group">
                    <label for="transaction-commission">Commission</label>
                    <input type="text" id="transaction-commission" placeholder="Commission" oninput="saveFeeTemporarily(); formatInputAmount(this);">
                </div>
                <div class="form-group">
                    <label for="transaction-fee">Fee</label>
                    <input type="text" id="transaction-fee" placeholder="Enter fee" oninput="saveFeeTemporarily(); formatInputAmount(this);">
                </div>
                <div class="form-group phone-input">
                    <label for="transaction-phone">Phone Number</label>
                    <input type="text" id="transaction-phone" placeholder="Enter phone number (e.g., 912345678)">
                </div>
                <div class="form-group">
                    <label for="transaction-note">Note</label>
                    <input type="text" id="transaction-note" placeholder="Optional note">
                </div>
                <div class="button-group">
                    <button type="button" onclick="addTransaction()">Add Transaction</button>
                    <button onclick="clearTransactionForm()" class="secondary">Clear Form</button>
                </div>
            </div>

            <div class="filter-section">
                <select id="transaction-filter-type">
                    <option value="all">All Types</option>
                    <option value="Wave Money">Wave Money</option>
                    <option value="Wave Pay">Wave Pay</option>
                    <option value="KBZ Pay">KBZ Pay</option>
                    <option value="Aya Pay">Aya Pay</option>
                </select>
                <select id="transaction-filter-action">
                    <option value="all">All Actions</option>
                    <option value="Cash In">Cash In</option>
                    <option value="Cash Out">Cash Out</option>
                    <option value="Send Money">Send Money</option>
                    <option value="Received Money">Received Money</option>
                    <option value="Payment">Payment</option>
                    <option value="Phone Bill">Phone Bill</option>
                </select>
                <input type="date" id="transaction-filter-date">
                <button onclick="filterTransactions()">Filter</button>
                <button onclick="resetTransactionFilters()" class="secondary">Reset</button>
            </div>

            <div class="transaction-list" id="transaction-list">
                <h2 onclick="toggleTransactionList()">Transaction History <span class="arrow">&#9660;</span></h2>
                <div class="transaction-list-items">
                    <!-- Transactions will be added here dynamically -->
                </div>
            </div>

            <div class="summary-section">
                <h2 onclick="updateSummariesBasedOnCurrentView(); toggleExpand(this.parentElement)">Daily Summaries <span class="arrow">&#9660;</span></h2>
                <div class="summary-list">
                    <div class="summary-item">
                        <span class="summary-label">E-Money Balance Change (Today):</span>
                        <span id="daily-e-money">0.00</span>
                    </div>
                    <div class="summary-item">
                        <span class="summary-label">Cash Balance Change (Today):</span>
                        <span id="daily-cash">0.00</span>
                    </div>
                    <div class="summary-item">
                        <span class="summary-label">Total Commission (Today):</span>
                        <span id="total-commission-summary">0.00</span>
                    </div>
                    <div class="summary-item">
                        <span class="summary-label">Total Fee (Today):</span>
                        <span id="total-fee-summary">0.00</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Daily Money Tab -->
        <div id="daily-money" class="tab-content">
            <div class="form-section">
                <h2>New Money Record</h2>
                <div class="form-group">
                    <label for="money-date">Date/Time</label>
                    <input type="datetime-local" id="money-date">
                </div>
                <div class="form-group">
                    <label for="money-amount">Amount</label>
                    <input type="text" id="money-amount" placeholder="Enter amount" oninput="calculateMoneyCommission(); formatInputAmount(this);">
                </div>
                <div class="form-group">
                    <label for="money-action">Action</label>
                    <select id="money-action" onchange="toggleCommissionField(); calculateMoneyCommission()">
                        <option value="Emoney In">E-Money In</option>
                        <option value="Emoney Out">E-Money Out</option>
                        <option value="Cash In">Cash In</option>
                        <option value="Cash Out">Cash Out</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="money-type">Type</label>
                    <select id="money-type" onchange="updateMoneyType()">
                        <option value="Wave Money">Wave Money</option>
                        <option value="KBZ Pay">KBZ Pay</option>
                        <option value="Aya Pay">Aya Pay</option>
                        <option value="other">Other (Manual)</option>
                    </select>
                    <input type="text" id="money-type-other" style="display: none; margin-top: 5px;" placeholder="Enter type">
                </div>
                <div class="form-group" id="money-commission-group" style="display: none;">
                    <label for="money-commission">Commission (%)</label>
                    <input type="text" id="money-commission" placeholder="Enter commission percentage" oninput="calculateMoneyCommission(); formatInputAmount(this);">
                </div>
                <div class="form-group">
                    <label for="money-note">Note</label>
                    <input type="text" id="money-note" placeholder="Optional note">
                </div>
                <div class="button-group">
                    <button onclick="addMoneyRecord()">Add Record</button>
                    <button onclick="clearMoneyForm()" class="secondary">Clear Form</button>
                </div>
            </div>

            <div class="filter-section">
                <select id="money-filter-action">
                    <option value="all">All Actions</option>
                    <option value="Emoney In">E-Money In</option>
                    <option value="Emoney Out">E-Money Out</option>
                    <option value="Cash In">Cash In</option>
                    <option value="Cash Out">Cash Out</option>
                </select>
                <input type="date" id="money-filter-date">
                <button onclick="filterMoneyRecords()">Filter</button>
                <button onclick="resetMoneyFilters()" class="secondary">Reset</button>
            </div>

            <div class="transaction-list" id="money-list">
                <h2 onclick="toggleMoneyList()">Money Records <span class="arrow">&#9660;</span></h2>
                <div class="transaction-list-items">
                    <!-- Records will be added here dynamically -->
                </div>
            </div>

            <div class="summary-section">
                <h2 onclick="updateSummariesBasedOnCurrentView(); toggleExpand(this.parentElement)">Daily Summary <span class="arrow">&#9660;</span></h2>
                <div class="summary-list">
                    <div class="summary-item">
                        <span class="summary-label">E-Money In:</span>
                        <span id="daily-emoney-in">0.00</span>
                    </div>
                    <div class="summary-item">
                        <span class="summary-label">E-Money Out:</span>
                        <span id="daily-emoney-out">0.00</span>
                    </div>
                    <div class="summary-item">
                        <span class="summary-label">Cash In:</span>
                        <span id="daily-cash-in">0.00</span>
                    </div>
                    <div class="summary-item">
                        <span class="summary-label">Cash Out:</span>
                        <span id="daily-cash-out">0.00</span>
                    </div>
                    <div class="summary-item">
                        <span class="summary-label">Remaining Balance:</span>
                        <span id="daily-remaining">0.00</span>
                    </div>
                    <div class="summary-item" id="daily-money-commission-item" style="display: none;">
                        <span class="summary-label">Commission:</span>
                        <span id="daily-money-commission">0.00</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- EXPENSE TAB -->
        <div id="expense" class="tab-content">
            <div class="form-section">
                <h2>Add New Expense/Income</h2>
                <div class="form-group">
                    <label for="expense-date">Date/Time</label>
                    <input type="datetime-local" id="expense-date">
                </div>
                <div class="form-group">
                    <label for="expense-type">Type</label>
                    <select id="expense-type" onchange="updateExpenseCategoryVisibility()">
                        <option value="Expense">Expense</option>
                        <option value="Income">Income</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="expense-category">Category</label>
                    <select id="expense-category" onchange="updateExpenseCategoryVisibility()">
                        <option value="other">Other (Manual)</option>
                        <!-- Categories will be loaded here dynamically -->
                    </select>
                    <!-- New input for 'Other' category -->
                    <input type="text" id="expense-category-other" style="display: none; margin-top: 5px;" placeholder="Enter new category">
                </div>
                <div class="form-group">
                    <label for="expense-amount">Amount</label>
                    <input type="text" id="expense-amount" placeholder="Enter amount" oninput="formatInputAmount(this)">
                </div>
                <div class="form-group">
                    <label for="expense-payment-method">Payment Method</label>
                    <select id="expense-payment-method" onchange="updatePaymentMethodVisibility()">
                        <option value="E-Money">E-Money</option>
                        <option value="Cash">Cash</option>
                        <option value="Other">Other</option>
                    </select>
                    <input type="text" id="expense-payment-method-other" style="display: none; margin-top: 5px;" placeholder="Enter payment method">
                </div>
                <div class="form-group">
                    <label for="expense-note">Note</label>
                    <input type="text" id="expense-note" placeholder="Optional note">
                </div>
                <div class="button-group">
                    <button type="button" onclick="addExpenseEntry()">Add Entry</button>
                    <button onclick="clearExpenseForm()" class="secondary">Clear Form</button>
                </div>
            </div>

            <div class="filter-section">
                <select id="expense-filter-type">
                    <option value="all">All Types</option>
                    <option value="Expense">Expense</option>
                    <option value="Income">Income</option>
                </select>
                <!-- Filter category will now be a text input for searching -->
                <input type="text" id="expense-filter-category" placeholder="Filter by Category">
                <input type="date" id="expense-filter-date">
                <button onclick="filterExpenses()">Filter</button>
                <button onclick="resetExpenseFilters()" class="secondary">Reset</button>
            </div>

            <div class="transaction-list" id="expense-list">
                <h2 onclick="toggleExpenseList()">Expense/Income Records <span class="arrow">&#9660;</span></h2>
                <div class="transaction-list-items">
                    <!-- Expense entries will be added here -->
                </div>
            </div>

            <!-- Summary Section for Expenses Tab -->
            <div class="summary-section">
                <h2 onclick="updateExpenseSummaries(); toggleExpand(this.parentElement)">Daily Summary <span class="arrow">&#9660;</span></h2>
                <div class="summary-list">
                    <div class="summary-item">
                        <span class="summary-label">Total Income (Today):</span>
                        <span id="daily-total-income">0.00</span>
                    </div>
                    <div class="summary-item">
                        <span class="summary-label">Total Expenses (Today):</span>
                        <span id="daily-total-expenses">0.00</span>
                    </div>
                    <div class="summary-item">
                        <span class="summary-label">Net Balance (Today):</span>
                        <span id="daily-net-balance">0.00</span>
                    </div>
                </div>
            </div>

            <!-- Periodical Summary Section for Expenses Tab -->
            <div class="summary-section">
                <h2 onclick="updatePeriodicalExpenseSummaries(); toggleExpand(this.parentElement)">Periodical Summaries <span class="arrow">&#9660;</span></h2>
                <div class="summary-list">
                    <div class="form-group">
                        <label for="period-type">Select Period:</label>
                        <select id="period-type" onchange="updatePeriodicalExpenseSummaries()">
                            <option value="week">This Week</option>
                            <option value="month">This Month</option>
                            <option value="year">This Year</option>
                        </select>
                    </div>
                    <div class="summary-item">
                        <span class="summary-label">Total Income (Period):</span>
                        <span id="periodical-total-income">0.00</span>
                    </div>
                    <div class="summary-item">
                        <span class="summary-label">Total Expenses (Period):</span>
                        <span id="periodical-total-expenses">0.00</span>
                    </div>
                    <div class="summary-item">
                        <span class="summary-label">Net Balance (Period):</span>
                        <span id="periodical-net-balance">0.00</span>
                    </div>
                </div>
            </div>
        </div>


        <!-- Debts/Credits Tab -->
        <div id="debt" class="tab-content">
            <div class="form-section debt-form-section">
                <h2>Add New Debt/Credit</h2>
                <div class="form-group">
                    <label for="debt-name">Name</label>
                    <input type="text" id="debt-name" placeholder="Enter person's name" oninput="handleDebtNameInput(event)">
                    <!-- Suggestions Dropdown -->
                    <div id="debt-name-suggestions" style="position: relative; z-index: 1000; background-color: white; border: 1px solid var(--medium-gray); border-radius: 8px; margin-top: 2px; max-height: 150px; overflow-y: auto; display: none; box-shadow: 0 4px 12px rgba(0,0,0,0.08);">
                        <!-- Suggestions will be loaded here -->
                    </div>
                </div>
                <div class="form-group">
                    <label for="debt-type">Type</label>
                    <select id="debt-type" onchange="updateDebtFormVisibility()">
                        <option value="payable">You Owe (Payable)</option>
                        <option value="receivable">Others Owe You (Receivable)</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="debt-amount">Amount</label>
                    <input type="text" id="debt-amount" placeholder="Enter amount" oninput="formatInputAmount(this)">
                </div>
                <div class="form-group">
                    <label for="debt-date">Date/Time</label>
                    <input type="datetime-local" id="debt-date">
                </div>
                <div class="form-group">
                    <label for="debt-note">Note</label>
                    <input type="text" id="debt-note" placeholder="Optional note">
                </div>
                <div class="button-group">
                    <!-- Button text changes based on edit mode -->
                    <button id="add-update-debt-button" onclick="addOrUpdateDebtEntry()">Add Debt/Credit</button>
                    <button onclick="clearDebtForm()" class="secondary">Clear Form</button>
                </div>
            </div>

            <!-- Filter box ONLY for search by name -->
            <div class="filter-section">
                <input type="text" id="debt-filter-name" placeholder="Search by Name" style="min-width: 200px; flex-grow: 2;">
                <button onclick="filterDebts()">Search</button>
                <button onclick="resetDebtFilters()" class="secondary">Reset</button>
            </div>

            <!-- Payable Debts Section -->
            <div class="transaction-list" id="payable-debts-list">
                <h2 onclick="toggleExpand(this.parentElement)">Payable Debts <span class="arrow">&#9660;</span></h2>
                <div class="transaction-list-items">
                    <!-- Payable debt items will be added here -->
                </div>
            </div>

            <!-- Receivable Debts Section -->
            <div class="transaction-list" id="receivable-debts-list">
                <h2 onclick="toggleExpand(this.parentElement)">Receivable Credits <span class="arrow">&#9660;</span></h2>
                <div class="transaction-list-items">
                    <!-- Receivable debt items will be added here -->
                </div>
            </div>

            <!-- Summary Totals for Debts/Credits -->
            <div class="debt-summary-totals">
                <div class="total-payable">
                    <span class="label">Total Payable:</span>
                    <span class="amount" id="total-payable-amount">0.00</span>
                </div>
                <div class="total-receivable">
                    <span class="label">Total Receivable:</span>
                    <span class="amount" id="total-receivable-amount">0.00</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- GLOBAL STATE VARIABLES ---
        let transactions = [];
        let moneyRecords = [];
        let debts = []; // Array to store debt/credit groups. Each group has 'name', 'type', and 'history'.
        let openingBalances = { eMoney: 0, cash: 0 };
        let savedOtherTransactionTypes = {}; // Stores custom transaction types
        let savedOtherMoneyTypes = {}; // Stores custom money record types
        let tempCommissionData = {}; // Stores commission/fee data temporarily for auto-fill
        let currentFilteredTransactions = []; // Holds transactions filtered by transaction tab filters
        let existingDebtNames = []; // Stores unique debt names for autocomplete suggestions
        let editingDebtEntry = null; // Stores the context for the debt entry being edited { id, type, groupType, groupIdx, entryIdx }

        // Expense related variables
        let expenseEntries = [];
        let savedExpenseCategories = {}; // Stores custom categories from localStorage

        // --- SCREEN LOCK VARIABLES ---
        let isLocked = false; // Global state to track if the screen is locked
        let lockAttempts = 0; // Counter for incorrect PIN attempts
        const MAX_LOCK_ATTEMPTS = 10; // Maximum incorrect attempts before permanent lockout
        let lockScreenTimer = null; // Timer for automatic locking
        const AUTO_LOCK_DELAY = 2 * 60 * 1000; // 2 minutes in milliseconds (2 * 60 * 1000)
        let pinInputBuffer = ''; // Stores the digits entered on the lock screen
        let settingsPIN = '0000'; // Default initial PIN
        let isScreenLockEnabled = false; // Flag for whether screen lock is enabled in settings
        let permanentlyLocked = false; // Flag for permanent lockout state
        let hideSuggestionsOnClickOutside = null; // Handler for closing debt suggestions

        // --- INITIALIZATION FUNCTIONS ---

        // Initialize the lock screen and its state
        function initializeLockScreen() {
            const storedPIN = localStorage.getItem('moneyManager_appPIN');
            if (storedPIN) {
                settingsPIN = storedPIN;
            } else {
                localStorage.setItem('moneyManager_appPIN', settingsPIN);
            }

            isScreenLockEnabled = localStorage.getItem('moneyManager_isScreenLockEnabled') === 'true';
            document.getElementById('enable-screen-lock').checked = isScreenLockEnabled;

            permanentlyLocked = localStorage.getItem('moneyManager_permanentlyLocked') === 'true';

            if (permanentlyLocked) {
                showLockScreen("This application has been permanently locked due to too many failed attempts. All data has been wiped.");
                document.getElementById('lock-screen-keyboard').style.display = 'none';
            } else if (isScreenLockEnabled) {
                showLockScreen("Your application has been locked. Please enter your PIN to continue.");
                clearTimeout(lockScreenTimer);
            } else {
                hideLockScreen();
            }
        }

        // Saves the lock screen enable/disable setting
        function saveLockSetting() {
            const checkbox = document.getElementById('enable-screen-lock');
            isScreenLockEnabled = checkbox.checked;
            localStorage.setItem('moneyManager_isScreenLockEnabled', isScreenLockEnabled);

            if (isScreenLockEnabled) {
                if (!isLocked && !permanentlyLocked) {
                    showLockScreen("Screen lock is now enabled. Please enter your PIN to continue.");
                    lockAttempts = 0;
                    pinInputBuffer = '';
                }
            } else {
                if (isLocked) {
                    hideLockScreen();
                }
                const overlay = document.getElementById('lock-screen-overlay');
                if (overlay) {
                    overlay.classList.remove('visible');
                }
                isLocked = false;
                clearTimeout(lockScreenTimer);
            }
        }

        // Show the lock screen overlay
        function showLockScreen(message = null) {
            const overlay = document.getElementById('lock-screen-overlay');
            if (overlay) {
                overlay.classList.add('visible');
            }
            isLocked = true;
            pinInputBuffer = '';
            document.getElementById('lock-screen-pin-input').value = '';
            document.getElementById('lock-screen-error-message').textContent = '';

            if (message) {
                document.getElementById('lock-screen-message').textContent = message;
            } else {
                document.getElementById('lock-screen-message').textContent = "Your application has been locked. Please enter your PIN.";
            }

            const keyboard = document.getElementById('lock-screen-keyboard');
            if (keyboard) {
                keyboard.style.display = permanentlyLocked ? 'none' : 'block';
            }
        }

        // Hide the lock screen overlay and resume application
        function hideLockScreen() {
            const overlay = document.getElementById('lock-screen-overlay');
            if (overlay) {
                overlay.classList.remove('visible');
            }
            isLocked = false;
            pinInputBuffer = '';
            document.getElementById('lock-screen-pin-input').value = '';
            document.getElementById('lock-screen-error-message').textContent = '';

            if (isScreenLockEnabled && !permanentlyLocked) {
                startLockTimer();
            }
        }

        // Handle input from the lock screen keyboard
        function handleLockScreenInput(input) {
            if (permanentlyLocked) return;

            const errorDisplay = document.getElementById('lock-screen-error-message');

            if (input === 'delete') {
                pinInputBuffer = pinInputBuffer.slice(0, -1);
            } else {
                if (pinInputBuffer.length < 4) {
                    pinInputBuffer += input;
                }
            }
            document.getElementById('lock-screen-pin-input').value = '*'.repeat(pinInputBuffer.length);

            if (pinInputBuffer.length === 4) {
                checkPIN(pinInputBuffer);
            }
        }

        // Check the entered PIN against the stored PIN
        function checkPIN(enteredPIN) {
            if (permanentlyLocked) return;

            const errorDisplay = document.getElementById('lock-screen-error-message');

            if (enteredPIN === settingsPIN) {
                errorDisplay.textContent = '';
                hideLockScreen();
                return;
            } else {
                lockAttempts++;
                pinInputBuffer = '';
                document.getElementById('lock-screen-pin-input').value = '';

                if (lockAttempts >= MAX_LOCK_ATTEMPTS) {
                    permanentlyLocked = true;
                    localStorage.setItem('moneyManager_permanentlyLocked', 'true');
                    wipeAllData();
                    errorDisplay.textContent = `Too many failed attempts. Application permanently locked.`;
                    document.getElementById('lock-screen-message').textContent = "Your application has been permanently locked. All data has been wiped.";
                    document.getElementById('lock-screen-keyboard').style.display = 'none';
                    return;
                } else {
                    errorDisplay.textContent = `Incorrect PIN. ${MAX_LOCK_ATTEMPTS - lockAttempts} attempts remaining.`;
                    document.getElementById('lock-screen-message').textContent = "Incorrect PIN. Please try again.";
                }
            }
        }

        // Wipe all application data from localStorage and reset state
        function wipeAllData() {
            localStorage.removeItem('moneyManager_transactions');
            localStorage.removeItem('moneyManager_moneyRecords');
            localStorage.removeItem('moneyManager_openingBalances');
            localStorage.removeItem('moneyManager_savedOtherTransactionTypes');
            localStorage.removeItem('moneyManager_savedOtherMoneyTypes');
            localStorage.removeItem('moneyManager_tempCommissionData');
            localStorage.removeItem('moneyManager_debts');
            localStorage.removeItem('moneyManager_expenseEntries');
            localStorage.removeItem('moneyManager_savedExpenseCategories');
            localStorage.removeItem('moneyManager_appPIN'); // Clear PIN on wipe
            localStorage.removeItem('moneyManager_isScreenLockEnabled');
            localStorage.removeItem('moneyManager_permanentlyLocked');

            transactions = []; moneyRecords = []; debts = []; openingBalances = { eMoney: 0, cash: 0 };
            savedOtherTransactionTypes = {}; savedOtherMoneyTypes = {}; tempCommissionData = {};
            expenseEntries = []; savedExpenseCategories = {};

            updateSummariesBasedOnCurrentView();
            updateTransactionList(); updateMoneyList(); renderDebts(); renderExpenseEntries();
            populateCustomTypes(); populateExpenseCategories();

            document.getElementById('opening-emoney').value = '';
            document.getElementById('opening-cash').value = '';

            showToast("All application data has been wiped due to security measures.", "error");
        }

        // Start the timer for automatic screen locking
        function startLockTimer() {
            clearTimeout(lockScreenTimer);
            lockScreenTimer = setTimeout(() => {
                if (!isLocked && isScreenLockEnabled && !permanentlyLocked) {
                    showLockScreen("Your session has timed out and the application has been locked.");
                    lockAttempts = 0;
                    pinInputBuffer = '';
                }
            }, AUTO_LOCK_DELAY);
        }

        // Reset the lock timer on user activity
        function resetLockTimer() {
            if (!isLocked && isScreenLockEnabled && !permanentlyLocked) {
                startLockTimer();
            }
        }

        // --- SETTINGS: PIN CHANGE FUNCTIONALITY ---
        function handleChangePIN() {
            const currentPinInput = document.getElementById('current-pin');
            const newPinInput = document.getElementById('new-pin');
            const confirmNewPinInput = document.getElementById('confirm-new-pin');

            const currentPin = currentPinInput.value;
            const newPin = newPinInput.value;
            const confirmNewPin = confirmNewPinInput.value;

            if (!currentPin || !newPin || !confirmNewPin) {
                showToast("Please fill in all PIN fields.", "error");
                return;
            }
            if (newPin.length !== 4 || !/^\d+$/.test(newPin)) {
                showToast("New PIN must be exactly 4 digits.", "error");
                return;
            }
            if (newPin !== confirmNewPin) {
                showToast("New PIN and Confirm New PIN do not match.", "error");
                return;
            }

            if (currentPin !== settingsPIN) {
                showToast("Incorrect current PIN.", "error");
                return;
            }

            settingsPIN = newPin;
            localStorage.setItem('moneyManager_appPIN', settingsPIN);

            currentPinInput.value = '';
            newPinInput.value = '';
            confirmNewPinInput.value = '';

            showToast("PIN changed successfully!");
        }

        // --- UTILITY FUNCTIONS ---

        // Formats a number for display with commas and two decimal places
        function formatNumber(num) {
            if (num === null || num === undefined) return '0.00';
            const n = parseFloat(num);
            if (isNaN(n)) return '0.00';

            if (Number.isInteger(n)) {
                return n.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
            } else {
                let parts = n.toFixed(2).split('.');
                parts[0] = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, ",");
                return parts.join('.');
            }
        }

        // Formats a number input field value to have comma separators and at most two decimal places
        function formatInputAmount(inputElement) {
            let value = inputElement.value.replace(/,/g, '');
            let cleanedValue = '';
            let decimalFound = false;

            for (let i = 0; i < value.length; i++) {
                const char = value[i];
                if (char >= '0' && char <= '9') {
                    cleanedValue += char;
                } else if (char === '.' && !decimalFound) {
                    cleanedValue += '.';
                    decimalFound = true;
                }
            }
            if (cleanedValue.includes('.')) {
                const decimalPart = cleanedValue.split('.')[1];
                if (decimalPart && decimalPart.length > 2) {
                    cleanedValue = cleanedValue.substring(0, cleanedValue.indexOf('.') + 3);
                }
            }
            let formattedValue = '';
            let commaIndex = cleanedValue.indexOf('.');
            let integerPart = commaIndex === -1 ? cleanedValue : cleanedValue.substring(0, commaIndex);
            let decimalPart = commaIndex === -1 ? '' : '.' + cleanedValue.substring(commaIndex + 1);

            for (let i = integerPart.length - 1; i >= 0; i--) {
                formattedValue = integerPart[i] + formattedValue;
                if ((integerPart.length - i) % 3 === 0 && i !== 0) {
                    formattedValue = ',' + formattedValue;
                }
            }
            inputElement.value = formattedValue + decimalPart;
        }

        // Sets the current date and time to relevant input fields if they are empty
        function updateDateTimeFields() {
            const now = new Date();
            const year = now.getFullYear();
            const month = (now.getMonth() + 1).toString().padStart(2, '0');
            const day = now.getDate().toString().padStart(2, '0');
            const hours = now.getHours().toString().padStart(2, '0');
            const minutes = now.getMinutes().toString().padStart(2, '0');

            const currentDateTime = `${year}-${month}-${day}T${hours}:${minutes}`;

            if (!document.getElementById('transaction-date').value) {
                 document.getElementById('transaction-date').value = currentDateTime;
            }
            if (!document.getElementById('money-date').value) {
                document.getElementById('money-date').value = currentDateTime;
            }
            if (!document.getElementById('debt-date').value) {
                 document.getElementById('debt-date').value = currentDateTime;
            }
            if (!document.getElementById('expense-date').value) {
                document.getElementById('expense-date').value = currentDateTime;
            }
        }

        // Displays a temporary notification message (toast) at the bottom of the screen
        function showToast(message, type = 'success') {
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.textContent = message;
            document.body.appendChild(toast);

            void toast.offsetWidth; // Trigger reflow
            toast.classList.add('show');

            setTimeout(() => {
                toast.classList.remove('show');
                setTimeout(() => {
                    toast.remove();
                }, 300); // Match transition duration
            }, 3000); // Show duration
        }

        // Adds a new option to a specified select element if it doesn't exist
        function addOptionToSelect(selectId, optionValue) {
            const selectElement = document.getElementById(selectId);
            const optionExists = Array.from(selectElement.options).some(option => option.value.toLowerCase() === optionValue.toLowerCase());
            if (!optionExists && optionValue && optionValue.trim() !== '' && optionValue.trim().toLowerCase() !== 'other') {
                const newOption = document.createElement('option');
                newOption.value = optionValue.trim();
                newOption.textContent = optionValue.trim();

                const otherOption = selectElement.querySelector('option[value="other"]');
                if (otherOption) {
                    selectElement.insertBefore(newOption, otherOption);
                } else {
                    selectElement.appendChild(newOption);
                }
            }
        }

        // --- DATA PERSISTENCE (SAVE/LOAD TO LOCALSTORAGE) ---

        // Saves all current application data to localStorage
        function saveData() {
            try {
                localStorage.setItem('moneyManager_transactions', JSON.stringify(transactions));
                localStorage.setItem('moneyManager_moneyRecords', JSON.stringify(moneyRecords));
                localStorage.setItem('moneyManager_openingBalances', JSON.stringify(openingBalances));
                localStorage.setItem('moneyManager_savedOtherTransactionTypes', JSON.stringify(savedOtherTransactionTypes));
                localStorage.setItem('moneyManager_savedOtherMoneyTypes', JSON.stringify(savedOtherMoneyTypes));
                localStorage.setItem('moneyManager_tempCommissionData', JSON.stringify(tempCommissionData));
                localStorage.setItem('moneyManager_debts', JSON.stringify(debts));
                localStorage.setItem('moneyManager_expenseEntries', JSON.stringify(expenseEntries));
                localStorage.setItem('moneyManager_savedExpenseCategories', JSON.stringify(savedExpenseCategories));
            } catch (e) {
                console.error("Error saving data to localStorage:", e);
                if (e.name === 'QuotaExceededError') {
                    showToast("Local storage is full. Cannot save data.", "error");
                } else {
                    showToast("An error occurred while saving data.", "error");
                }
            }
        }

        // Loads data from localStorage into the application's global variables
        function loadData() {
            let savedTransactions = localStorage.getItem('moneyManager_transactions');
            let savedMoneyRecords = localStorage.getItem('moneyManager_moneyRecords');
            let savedOpeningBalances = localStorage.getItem('moneyManager_openingBalances');
            let savedOtherTransactionTypesData = localStorage.getItem('moneyManager_savedOtherTransactionTypes');
            let savedOtherMoneyTypesData = localStorage.getItem('moneyManager_savedOtherMoneyTypes');
            let savedTempCommissionData = localStorage.getItem('moneyManager_tempCommissionData');
            let savedDebts = localStorage.getItem('moneyManager_debts');
            let savedExpenseEntries = localStorage.getItem('moneyManager_expenseEntries');
            let savedExpenseCategoriesData = localStorage.getItem('moneyManager_savedExpenseCategories');

            try {
                transactions = savedTransactions ? JSON.parse(savedTransactions) : [];
                moneyRecords = savedMoneyRecords ? JSON.parse(savedMoneyRecords) : [];
                openingBalances = savedOpeningBalances ? JSON.parse(savedOpeningBalances) : { eMoney: 0, cash: 0 };
                savedOtherTransactionTypes = savedOtherTransactionTypesData ? JSON.parse(savedOtherTransactionTypesData) : {};
                savedOtherMoneyTypes = savedOtherMoneyTypesData ? JSON.parse(savedOtherMoneyTypesData) : {};
                tempCommissionData = savedTempCommissionData ? JSON.parse(savedTempCommissionData) : {};
                debts = savedDebts ? JSON.parse(savedDebts) : [];
                expenseEntries = savedExpenseEntries ? JSON.parse(savedExpenseEntries) : [];
                savedExpenseCategories = savedExpenseCategoriesData ? JSON.parse(savedExpenseCategoriesData) : {};

            } catch (e) {
                console.error("Error parsing data from localStorage:", e);
                showToast("Error reading data from local storage", "error");
                // Reset to default empty states if parsing fails
                transactions = []; moneyRecords = []; openingBalances = { eMoney: 0, cash: 0 };
                savedOtherTransactionTypes = {}; savedOtherMoneyTypes = {}; tempCommissionData = {}; debts = [];
                expenseEntries = []; savedExpenseCategories = {};
                return;
            }

            // Data validation and fallback to defaults
            if (!Array.isArray(transactions)) transactions = [];
            if (!Array.isArray(moneyRecords)) moneyRecords = [];
            if (typeof openingBalances !== 'object' || openingBalances === null) openingBalances = { eMoney: 0, cash: 0 };
            if (typeof openingBalances.eMoney !== 'number' || isNaN(openingBalances.eMoney)) openingBalances.eMoney = 0;
            if (typeof openingBalances.cash !== 'number' || isNaN(openingBalances.cash)) openingBalances.cash = 0;
            if (typeof savedOtherTransactionTypes !== 'object' || savedOtherTransactionTypes === null) savedOtherTransactionTypes = {};
            if (typeof savedOtherMoneyTypes !== 'object' || savedOtherMoneyTypes === null) savedOtherMoneyTypes = {};
            if (typeof tempCommissionData !== 'object' || tempCommissionData === null) tempCommissionData = {};
            if (!Array.isArray(debts)) debts = [];
            if (!Array.isArray(expenseEntries)) expenseEntries = [];
            if (typeof savedExpenseCategories !== 'object' || savedExpenseCategories === null) savedExpenseCategories = {};

            updateExistingDebtNames();
            populateCustomTypes();
            populateExpenseCategories();
        }

        // Populates the custom transaction and money record type select options from saved data
        function populateCustomTypes() {
            const transactionTypeSelect = document.getElementById('transaction-type');
            const moneyTypeSelect = document.getElementById('money-type');

            // Populate Transaction Types
            const existingTransactionTypes = Array.from(transactionTypeSelect.options).map(opt => opt.value.toLowerCase());
            for (const type in savedOtherTransactionTypes) {
                if (Object.hasOwnProperty.call(savedOtherTransactionTypes, type) && !existingTransactionTypes.includes(type.toLowerCase()) && type.trim() !== '' && type.toLowerCase() !== 'other') {
                    addOptionToSelect('transaction-type', type);
                }
            }

            // Populate Money Record Types
            const existingMoneyTypes = Array.from(moneyTypeSelect.options).map(opt => opt.value.toLowerCase());
            for (const type in savedOtherMoneyTypes) {
                if (Object.hasOwnProperty.call(savedOtherMoneyTypes, type) && !existingMoneyTypes.includes(type.toLowerCase()) && type.trim() !== '' && type.toLowerCase() !== 'other') {
                    addOptionToSelect('money-type', type);
                }
            }
        }

        // --- MAIN APPLICATION INITIALIZATION ---
        document.addEventListener('DOMContentLoaded', function() {
            initializeLockScreen();
            updateDateTimeFields();
            loadData();

            updateSummariesBasedOnCurrentView();
            updateTransactionList();
            updateMoneyList();
            renderDebts();
            renderExpenseEntries();

            // Event listener for closing debt suggestions when clicking outside
            document.addEventListener('click', function(e) {
                const transactionItem = e.target.closest('.transaction-item');
                if (transactionItem) {
                    // Handle click on transaction item itself (e.g., toggle active state)
                    if (!e.target.closest('.transaction-actions')) {
                        const parentGroupDetails = transactionItem.closest('.group-details');
                        if(parentGroupDetails) {
                            // Deactivate other items in the same group
                            parentGroupDetails.querySelectorAll('.transaction-item').forEach(item => {
                                if (item !== transactionItem) {
                                    item.classList.remove('active');
                                }
                            });
                        }
                        transactionItem.classList.toggle('active');
                    }
                } else {
                    // Deactivate any active transaction item if click is outside
                    document.querySelectorAll('.transaction-item').forEach(item => {
                        item.classList.remove('active');
                    });
                }

                // Handle closing debt name suggestions
                const debtNameInput = document.getElementById('debt-name');
                const suggestionsContainer = document.getElementById('debt-name-suggestions');
                if (suggestionsContainer && debtNameInput && !suggestionsContainer.contains(e.target) && !debtNameInput.contains(e.target)) {
                    suggestionsContainer.style.display = 'none';
                    if (hideSuggestionsOnClickOutside) {
                        document.removeEventListener('click', hideSuggestionsOnClickOutside);
                        hideSuggestionsOnClickOutside = null;
                    }
                }
                resetLockTimer(); // Reset timer on any click
            });

            // Reset lock timer on various interactions
            document.addEventListener('mousemove', resetLockTimer);
            document.addEventListener('mousedown', resetLockTimer);
            document.addEventListener('keydown', resetLockTimer);
            document.addEventListener('touchstart', resetLockTimer);

            toggleCommissionField(); // Set initial visibility of commission field
            updateExpenseCategoryVisibility(); // Set initial visibility of other category input
            updatePaymentMethodVisibility(); // Set initial visibility of other payment method input

            const debtNameInput = document.getElementById('debt-name');
            if (debtNameInput) {
                debtNameInput.addEventListener('input', handleDebtNameInput);
            }

            populateExpenseCategories(); // Load existing categories

            if (!isScreenLockEnabled) { // Ensure lock screen is hidden if not enabled
                hideLockScreen();
            }
        });

        // --- TAB SWITCHING LOGIC ---
        function switchTab(tabId) {
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));

            // Activate the clicked tab and its content
            document.querySelector(`.tab[onclick="switchTab('${tabId}')"]`).classList.add('active');
            document.getElementById(tabId).classList.add('active');

            updateSummariesBasedOnCurrentView(); // Update summaries when tab changes
        }

        // --- OPENING BALANCE TAB FUNCTIONS ---
        function saveOpeningBalances() {
            const eMoney = parseFloat(document.getElementById('opening-emoney').value.replace(/,/g, '')) || 0;
            const cash = parseFloat(document.getElementById('opening-cash').value.replace(/,/g, '')) || 0;

            openingBalances = { eMoney, cash };
            try {
                localStorage.setItem('moneyManager_openingBalances', JSON.stringify(openingBalances));
                showToast('Opening balances saved successfully!');
            } catch (e) {
                console.error("Error saving opening balances:", e);
                showToast('Error saving opening balances', 'error');
            }
            updateSummariesBasedOnCurrentView(); // Update balances on screen
        }

        // --- BACKUP FUNCTIONS ---

        // Generates a backup of all application data into a text area
        function generateBackup() {
            const backupData = {
                transactions: transactions,
                moneyRecords: moneyRecords,
                openingBalances: openingBalances,
                savedOtherTransactionTypes: savedOtherTransactionTypes,
                savedOtherMoneyTypes: savedOtherMoneyTypes,
                tempCommissionData: tempCommissionData,
                debts: debts,
                expenseEntries: expenseEntries,
                savedExpenseCategories: savedExpenseCategories,
                isScreenLockEnabled: isScreenLockEnabled,
                appPIN: settingsPIN
            };

            try {
                document.getElementById('backup-data').value = JSON.stringify(backupData, null, 2);
                showToast('Backup data generated!');
            } catch (e) {
                console.error("Error generating backup data:", e);
                showToast('Error generating backup data', 'error');
            }
        }

        // Restores application data from the text area, merging with existing data
        function restoreBackup() {
            if (!confirm('This will merge existing data with the data from the text area. Existing data will be preserved. Continue?')) {
                return;
            }

            try {
                const backupText = document.getElementById('backup-data').value;
                if (!backupText.trim()) {
                    showToast('No backup data found in the text area', 'error');
                    return;
                }

                let backupData;
                try {
                    backupData = JSON.parse(backupText);
                } catch (e) {
                    console.error("Error parsing backup JSON:", e);
                    showToast('Invalid backup data format', 'error');
                    return;
                }

                // Validate essential data structures before merging
                if (backupData.transactions && backupData.moneyRecords && backupData.openingBalances && backupData.debts && backupData.expenseEntries && backupData.savedExpenseCategories) {
                    // Merge transactions (add new ones, avoid duplicates by ID)
                    const newTransactions = backupData.transactions.filter(bt => !transactions.some(at => at.id === bt.id));
                    transactions = newTransactions.concat(transactions);

                    // Merge money records (add new ones, avoid duplicates based on a combination of fields)
                    const newMoneyRecords = backupData.moneyRecords.filter(bmr => !moneyRecords.some(amr => amr.date === bmr.date && amr.amount === bmr.amount && amr.action === bmr.action));
                    moneyRecords = newMoneyRecords.concat(moneyRecords);

                    // Merge opening balances (take from backup if available)
                    if (backupData.openingBalances) {
                        openingBalances = {
                            eMoney: parseFloat(backupData.openingBalances.eMoney) || openingBalances.eMoney,
                            cash: parseFloat(backupData.openingBalances.cash) || openingBalances.cash
                        };
                        // Ensure balances are numbers
                        if (isNaN(openingBalances.eMoney)) openingBalances.eMoney = 0;
                        if (isNaN(openingBalances.cash)) openingBalances.cash = 0;
                    }

                    // Merge custom types and temp data (prioritize existing data slightly)
                    savedOtherTransactionTypes = { ...backupData.savedOtherTransactionTypes, ...savedOtherTransactionTypes };
                    savedOtherMoneyTypes = { ...backupData.savedOtherMoneyTypes, ...savedOtherMoneyTypes };
                    tempCommissionData = { ...tempCommissionData, ...backupData.tempCommissionData };

                    // Merge debts (add new ones, avoid duplicates by ID)
                    const newDebts = backupData.debts.filter(bd => !debts.some(ad => ad.id === bd.id));
                    debts = newDebts.concat(debts);

                    // Merge expense entries (add new ones, avoid duplicates by ID)
                    const newExpenseEntries = backupData.expenseEntries.filter(be => !expenseEntries.some(ae => ae.id === be.id));
                    expenseEntries = newExpenseEntries.concat(expenseEntries);

                    // Merge expense categories
                    savedExpenseCategories = { ...backupData.savedExpenseCategories, ...savedExpenseCategories };

                    // Restore settings if present
                    if (backupData.isScreenLockEnabled !== undefined) {
                        isScreenLockEnabled = backupData.isScreenLockEnabled;
                        localStorage.setItem('moneyManager_isScreenLockEnabled', isScreenLockEnabled);
                        document.getElementById('enable-screen-lock').checked = isScreenLockEnabled;
                    }
                    if (backupData.appPIN) {
                        settingsPIN = backupData.appPIN;
                        localStorage.setItem('moneyManager_appPIN', settingsPIN);
                    }

                    // Save all merged data back to localStorage
                    try {
                        localStorage.setItem('moneyManager_transactions', JSON.stringify(transactions));
                        localStorage.setItem('moneyManager_moneyRecords', JSON.stringify(moneyRecords));
                        localStorage.setItem('moneyManager_openingBalances', JSON.stringify(openingBalances));
                        localStorage.setItem('moneyManager_savedOtherTransactionTypes', JSON.stringify(savedOtherTransactionTypes));
                        localStorage.setItem('moneyManager_savedOtherMoneyTypes', JSON.stringify(savedOtherMoneyTypes));
                        localStorage.setItem('moneyManager_tempCommissionData', JSON.stringify(tempCommissionData));
                        localStorage.setItem('moneyManager_debts', JSON.stringify(debts));
                        localStorage.setItem('moneyManager_expenseEntries', JSON.stringify(expenseEntries));
                        localStorage.setItem('moneyManager_savedExpenseCategories', JSON.stringify(savedExpenseCategories));

                        // Refresh UI elements
                        updateSummariesBasedOnCurrentView();
                        updateTransactionList();
                        updateMoneyList();
                        renderDebts();
                        populateCustomTypes();
                        populateExpenseCategories();
                        renderExpenseEntries();

                        // Update input fields with restored balances
                        document.getElementById('opening-emoney').value = openingBalances.eMoney !== undefined ? formatNumber(openingBalances.eMoney) : '';
                        document.getElementById('opening-cash').value = openingBalances.cash !== undefined ? formatNumber(openingBalances.cash) : '';

                        showToast('Data merged successfully from text!');
                    } catch (e) {
                        console.error("Error saving merged data to localStorage:", e);
                        showToast('Error saving merged data', 'error');
                    }
                } else {
                    showToast('Invalid backup data format (missing essential fields)', 'error');
                }
            } catch (e) {
                console.error("An unexpected error occurred during text restore:", e);
                showToast('An unexpected error occurred during restore', 'error');
            }
        }

        // Generates a JSON backup file for download
        function generateBackupFile() {
            const backupData = {
                transactions: transactions,
                moneyRecords: moneyRecords,
                openingBalances: openingBalances,
                savedOtherTransactionTypes: savedOtherTransactionTypes,
                savedOtherMoneyTypes: savedOtherMoneyTypes,
                tempCommissionData: tempCommissionData,
                debts: debts,
                expenseEntries: expenseEntries,
                savedExpenseCategories: savedExpenseCategories,
                isScreenLockEnabled: isScreenLockEnabled,
                appPIN: settingsPIN
            };

            const dataStr = JSON.stringify(backupData, null, 2);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);

            const link = document.createElement('a');
            link.href = url;
            link.download = `MoneyManager_Backup_${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(link);
            link.click();

            URL.revokeObjectURL(url); // Clean up the URL object
            link.remove();
            showToast('Backup file generated!');
        }

        // Restores application data from a selected JSON file, merging with existing data
        function restoreFromFile(event) {
            const file = event.target.files[0];
            if (!file) {
                return; // No file selected
            }

            // Validate file type
            if (file.type !== 'application/json' && !file.name.toLowerCase().endsWith('.json')) {
                showToast('Invalid file type. Please select a .json file.', 'error');
                event.target.value = ''; // Clear the file input
                return;
            }

            if (!confirm(`This will merge existing data with the data from "${file.name}". Existing data will be preserved. Continue?`)) {
                event.target.value = ''; // Clear the file input if user cancels
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const backupData = JSON.parse(e.target.result);

                    // Validate essential data structures before merging
                    if (backupData.transactions && backupData.moneyRecords && backupData.openingBalances && backupData.debts && backupData.expenseEntries && backupData.savedExpenseCategories) {
                        // Merge transactions
                        const newTransactions = backupData.transactions.filter(bt => !transactions.some(at => at.id === bt.id));
                        transactions = newTransactions.concat(transactions);

                        // Merge money records
                        const newMoneyRecords = backupData.moneyRecords.filter(bmr => !moneyRecords.some(amr => amr.date === bmr.date && amr.amount === bmr.amount && amr.action === bmr.action));
                        moneyRecords = newMoneyRecords.concat(moneyRecords);

                        // Merge opening balances
                        if (backupData.openingBalances) {
                            openingBalances = {
                                eMoney: parseFloat(backupData.openingBalances.eMoney) || openingBalances.eMoney,
                                cash: parseFloat(backupData.openingBalances.cash) || openingBalances.cash
                            };
                            if (isNaN(openingBalances.eMoney)) openingBalances.eMoney = 0;
                            if (isNaN(openingBalances.cash)) openingBalances.cash = 0;
                        }

                        // Merge custom types and temp data
                        savedOtherTransactionTypes = { ...backupData.savedOtherTransactionTypes, ...savedOtherTransactionTypes };
                        savedOtherMoneyTypes = { ...backupData.savedOtherMoneyTypes, ...savedOtherMoneyTypes };
                        tempCommissionData = { ...tempCommissionData, ...backupData.tempCommissionData };

                        // Merge debts
                        const newDebts = backupData.debts.filter(bd => !debts.some(ad => ad.id === bd.id));
                        debts = newDebts.concat(debts);

                        // Merge expense entries
                        const newExpenseEntries = backupData.expenseEntries.filter(be => !expenseEntries.some(ae => ae.id === be.id));
                        expenseEntries = newExpenseEntries.concat(expenseEntries);

                        // Merge expense categories
                        savedExpenseCategories = { ...backupData.savedExpenseCategories, ...savedExpenseCategories };

                        // Restore settings
                        if (backupData.isScreenLockEnabled !== undefined) {
                            isScreenLockEnabled = backupData.isScreenLockEnabled;
                            localStorage.setItem('moneyManager_isScreenLockEnabled', isScreenLockEnabled);
                            document.getElementById('enable-screen-lock').checked = isScreenLockEnabled;
                        }
                        if (backupData.appPIN) {
                            settingsPIN = backupData.appPIN;
                            localStorage.setItem('moneyManager_appPIN', settingsPIN);
                        }

                        // Save all merged data
                        try {
                            localStorage.setItem('moneyManager_transactions', JSON.stringify(transactions));
                            localStorage.setItem('moneyManager_moneyRecords', JSON.stringify(moneyRecords));
                            localStorage.setItem('moneyManager_openingBalances', JSON.stringify(openingBalances));
                            localStorage.setItem('moneyManager_savedOtherTransactionTypes', JSON.stringify(savedOtherTransactionTypes));
                            localStorage.setItem('moneyManager_savedOtherMoneyTypes', JSON.stringify(savedOtherMoneyTypes));
                            localStorage.setItem('moneyManager_tempCommissionData', JSON.stringify(tempCommissionData));
                            localStorage.setItem('moneyManager_debts', JSON.stringify(debts));
                            localStorage.setItem('moneyManager_expenseEntries', JSON.stringify(expenseEntries));
                            localStorage.setItem('moneyManager_savedExpenseCategories', JSON.stringify(savedExpenseCategories));

                            // Refresh UI
                            updateSummariesBasedOnCurrentView();
                            updateTransactionList();
                            updateMoneyList();
                            renderDebts();
                            populateCustomTypes();
                            populateExpenseCategories();
                            renderExpenseEntries();

                            // Update input fields
                            document.getElementById('opening-emoney').value = openingBalances.eMoney !== undefined ? formatNumber(openingBalances.eMoney) : '';
                            document.getElementById('opening-cash').value = openingBalances.cash !== undefined ? formatNumber(openingBalances.cash) : '';

                            showToast('Data merged successfully from file!');
                        } catch (e) {
                            console.error("Error saving merged data from file to localStorage:", e);
                            showToast('Error saving merged data from file', 'error');
                        }
                    } else {
                        showToast('Invalid backup file format (missing essential fields)', 'error');
                    }
                } catch (e) {
                    console.error("Error parsing backup file:", e);
                    showToast('Error reading or parsing backup file', 'error');
                } finally {
                    event.target.value = ''; // Clear the file input regardless of success/failure
                }
            };

            reader.onerror = function() {
                console.error("Error reading file:", reader.error);
                showToast('Error reading file', 'error');
                event.target.value = ''; // Clear the file input
            };

            reader.readAsText(file); // Read the file content as text
        }


        // --- TRANSACTION TAB FUNCTIONS ---

        // Updates the visibility of the 'Other (Manual)' input for transaction types
        function updateTransactionType() {
            const typeSelect = document.getElementById('transaction-type');
            const otherInput = document.getElementById('transaction-type-other');

            if (typeSelect.value === 'other') {
                otherInput.style.display = 'block';
                otherInput.focus();
            } else {
                otherInput.style.display = 'none';
                otherInput.value = ''; // Clear the input if 'other' is not selected
            }
            updateSavedCommissionAndFee(); // Recalculate potential commission/fee
        }

        // Attempts to auto-fill commission and fee based on saved data for the current transaction
        function updateSavedCommissionAndFee() {
            const type = document.getElementById('transaction-type').value;
            const typeOtherInput = document.getElementById('transaction-type-other');
            const typeOther = typeOtherInput.value.trim();
            const effectiveType = (type === 'other' && typeOther) ? typeOther : type; // Use custom type if 'other' is selected and filled

            const action = document.getElementById('transaction-action').value;
            const amountInput = document.getElementById('transaction-amount');
            const amount = parseFloat(amountInput.value.replace(/,/g, '')) || 0; // Get current amount

            // Only attempt to fill if type, action, and a positive amount are present
            if (effectiveType && action && amount > 0) {
                const key = `${effectiveType}-${action}-${amount}`; // Create a unique key
                const savedData = tempCommissionData[key]; // Look up saved data

                if (savedData) {
                    // If commission field is empty or zero, fill it from saved data
                    if (document.getElementById('transaction-commission').value === '' || parseFloat(document.getElementById('transaction-commission').value.replace(/,/g, '')) === 0) {
                        document.getElementById('transaction-commission').value = savedData.commission !== undefined && savedData.commission !== null ? formatNumber(savedData.commission) : '';
                    }
                    // If fee field is empty or zero, fill it from saved data
                    if (document.getElementById('transaction-fee').value === '' || parseFloat(document.getElementById('transaction-fee').value.replace(/,/g, '')) === 0) {
                         document.getElementById('transaction-fee').value = savedData.fee !== undefined && savedData.fee !== null ? formatNumber(savedData.fee) : '';
                    }
                } else {
                    // Clear fields if no saved data matches
                    if (document.getElementById('transaction-commission').value === '') document.getElementById('transaction-commission').value = '';
                    if (document.getElementById('transaction-fee').value === '') document.getElementById('transaction-fee').value = '';
                }
            } else {
                // Clear fields if required data is missing
                if (document.getElementById('transaction-commission').value === '') document.getElementById('transaction-commission').value = '';
                if (document.getElementById('transaction-fee').value === '') document.getElementById('transaction-fee').value = '';
            }
        }

        // Saves commission and fee data associated with a specific transaction type, action, and amount for future auto-filling
        function saveCommissionAndFee(type, action, amount, commission, fee) {
            if (type && action && !isNaN(amount) && amount > 0 && !isNaN(commission) && !isNaN(fee)) {
                const key = `${type}-${action}-${amount}`;
                // Only save if the data is new or different from what's already stored
                if (!tempCommissionData[key] || tempCommissionData[key].commission !== commission || tempCommissionData[key].fee !== fee) {
                    tempCommissionData[key] = { commission, fee };
                    try {
                        localStorage.setItem('moneyManager_tempCommissionData', JSON.stringify(tempCommissionData));
                    } catch (e) {
                        console.error("Error saving tempCommissionData:", e);
                    }
                }
            }
        }

        // Captures current values from the transaction form to potentially save them for future auto-filling
        function saveFeeTemporarily() {
            const type = document.getElementById('transaction-type').value;
            const typeOtherInput = document.getElementById('transaction-type-other');
            const typeOther = typeOtherInput.value.trim();
            const effectiveType = (type === 'other' && typeOther) ? typeOther : type; // Use custom type if 'other' is selected and filled

            const action = document.getElementById('transaction-action').value;
            const amountStr = document.getElementById('transaction-amount').value;
            const amount = parseFloat(amountStr.replace(/,/g, '')); // Parse amount

            const commissionStr = document.getElementById('transaction-commission').value;
            const commission = commissionStr ? parseFloat(commissionStr.replace(/,/g, '')) : 0; // Parse commission, default to 0

            const feeStr = document.getElementById('transaction-fee').value;
            const fee = feeStr ? parseFloat(feeStr.replace(/,/g, '')) : 0; // Parse fee, default to 0

            // Save if all necessary fields are present and valid
            if (effectiveType && action && !isNaN(amount) && amount > 0 && !isNaN(commission) && !isNaN(fee)) {
                saveCommissionAndFee(effectiveType, action, amount, commission, fee);
            }
        }

        // Adds a new transaction based on form input
        function addTransaction() {
            const id = document.getElementById('transaction-id').value.trim();
            const date = document.getElementById('transaction-date').value;
            let type = document.getElementById('transaction-type').value;
            const otherInput = document.getElementById('transaction-type-other');

            let effectiveType = type; // The type to be stored and used for logic
            let finalType = type;     // The type to be displayed (might be custom)

            // Handle custom transaction types
            if (type === 'other') {
                const customType = otherInput.value.trim();
                if (!customType) {
                    showToast('Please specify the other transaction type', 'error');
                    return;
                }
                finalType = customType;
                effectiveType = customType;
                // Save custom type if it's new
                if (!savedOtherTransactionTypes[finalType]) {
                    savedOtherTransactionTypes[finalType] = finalType;
                    try {
                        localStorage.setItem('moneyManager_savedOtherTransactionTypes', JSON.stringify(savedOtherTransactionTypes));
                    } catch (e) {
                        console.error("Error saving custom transaction type:", e);
                    }
                    addOptionToSelect('transaction-type', finalType); // Add it to the dropdown
                }
            }

            const action = document.getElementById('transaction-action').value;
            const amount = parseFloat(document.getElementById('transaction-amount').value.replace(/,/g, ''));
            const commissionInput = document.getElementById('transaction-commission');
            const commission = commissionInput.value ? parseFloat(commissionInput.value.replace(/,/g, '')) : 0;
            const feeInput = document.getElementById('transaction-fee');
            const fee = feeInput.value ? parseFloat(feeInput.value.replace(/,/g, '')) : 0;

            let phone = document.getElementById('transaction-phone').value.trim();
            if (phone) phone = '09' + phone; // Prepend '09' if it's a valid phone number format
            const note = document.getElementById('transaction-note').value.trim();

            // Basic validation
            if (!id) { showToast('Transaction ID is required.', 'error'); return; }
            if (!date) { showToast('Date/Time is required.', 'error'); return; }
            if (!finalType) { showToast('Transaction Type is required.', 'error'); return; } // Should not happen due to 'other' logic
            if (!action) { showToast('Action is required.', 'error'); return; }
            if (isNaN(amount) || amount <= 0) { showToast('Amount must be a positive number.', 'error'); return; }
            if (isNaN(commission) || commission < 0) { showToast('Commission must be a non-negative number.', 'error'); return; }
            if (isNaN(fee) || fee < 0) { showToast('Fee must be a non-negative number.', 'error'); return; }

            // Check for duplicate transaction ID
            if (transactions.some(t => t.id === id)) {
                showToast('Transaction ID already exists. Please use a unique ID.', 'error');
                return;
            }

            // Save commission and fee data for potential auto-fill
            saveCommissionAndFee(effectiveType, action, amount, commission, fee);

            // Create the transaction object
            const transaction = {
                id, date, type: finalType, action, amount, commission, fee, phone, note
            };

            transactions.unshift(transaction); // Add to the beginning of the array

            // Save updated transactions to localStorage
            try {
                localStorage.setItem('moneyManager_transactions', JSON.stringify(transactions));
                showToast('Transaction added successfully!');
            } catch (e) {
                console.error("Error saving transactions:", e);
                showToast('Error saving transaction', 'error');
            }

            updateSummariesBasedOnCurrentView(); // Update summary calculations
            updateTransactionList(); // Refresh the displayed list
            clearTransactionForm(); // Clear the form for the next entry
        }

        // Clears and resets the transaction form fields
        function clearTransactionForm() {
            document.getElementById('transaction-id').value = '';
            updateDateTimeFields(); // Reset date/time to current
            document.getElementById('transaction-type').value = 'Wave Money'; // Reset to default
            document.getElementById('transaction-type-other').value = ''; // Clear custom type input
            document.getElementById('transaction-type-other').style.display = 'none'; // Hide custom type input
            document.getElementById('transaction-action').value = 'Cash In'; // Reset to default
            document.getElementById('transaction-amount').value = '';
            document.getElementById('transaction-commission').value = '';
            document.getElementById('transaction-fee').value = '';
            document.getElementById('transaction-phone').value = '';
            document.getElementById('transaction-note').value = '';

            updateSavedCommissionAndFee(); // Update any auto-fill suggestions
        }

        // Updates the displayed balance figures in the transaction tab
        function updateTransactionTabBalances() {
            // Get daily changes calculated from transactions
            const dailyEMoneyChangeFromTransactions = parseFloat(document.getElementById('daily-e-money').textContent.replace(/,/g, '')) || 0;
            const dailyCashChangeFromTransactions = parseFloat(document.getElementById('daily-cash').textContent.replace(/,/g, '')) || 0;

            // Get opening balances
            const openingEMoney = parseFloat(openingBalances.eMoney) || 0;
            const openingCash = parseFloat(openingBalances.cash) || 0;

            // Calculate current balances
            const currentEMoneyBalance = openingEMoney + dailyEMoneyChangeFromTransactions;
            const currentCashBalance = openingCash + dailyCashChangeFromTransactions;
            const currentTotalBalance = currentEMoneyBalance + currentCashBalance;

            // Update the UI
            document.getElementById('e-money-balance').textContent = formatNumber(currentEMoneyBalance);
            document.getElementById('cash-balance').textContent = formatNumber(currentCashBalance);
            document.getElementById('total-balance').textContent = formatNumber(currentTotalBalance);
        }

        // Renders the transaction list, grouping transactions by date
        function updateTransactionList(filteredTransactions = null) {
            const listContainer = document.querySelector('#transaction-list .transaction-list-items');
            listContainer.innerHTML = ''; // Clear existing list

            const transactionsToShow = filteredTransactions !== null ? filteredTransactions : transactions; // Use filtered list if provided

            if (transactionsToShow.length === 0) {
                listContainer.innerHTML += '<p class="no-data">No transactions found.</p>'; // Display message if no data
                return;
            }

            // Group transactions by date for better readability
            const groupedTransactions = {};
            transactionsToShow.forEach((transaction, index) => {
                // Find the original index in the main `transactions` array for editing/deleting
                const originalIndex = transactions.findIndex(t => t.id === transaction.id && t.date === transaction.date);

                const dateKey = new Date(transaction.date).toISOString().split('T')[0]; // Get date part for grouping

                if (!groupedTransactions[dateKey]) {
                    groupedTransactions[dateKey] = {
                        items: [], // Store transactions for this date
                        details: { emoneyChange: 0, cashChange: 0, totalCommission: 0, totalFee: 0 } // Summary details for the day
                    };
                }
                groupedTransactions[dateKey].items.push({ ...transaction, originalIndex: originalIndex }); // Add transaction with its original index

                // Calculate daily summary details from each transaction
                const amount = parseFloat(transaction.amount);
                const commission = parseFloat(transaction.commission) || 0; // Ensure commission is a number
                const fee = parseFloat(transaction.fee) || 0;           // Ensure fee is a number

                // Adjust E-Money and Cash balances based on transaction action
                if (transaction.action === 'Cash In') {
                    groupedTransactions[dateKey].details.emoneyChange -= amount; // E-Money decreases
                    groupedTransactions[dateKey].details.cashChange += amount;   // Cash increases
                } else if (transaction.action === 'Cash Out') {
                    groupedTransactions[dateKey].details.emoneyChange += amount; // E-Money increases
                    groupedTransactions[dateKey].details.cashChange -= amount;   // Cash decreases
                } else if (
                    transaction.action === 'Send Money' ||
                    transaction.action === 'Payment' ||
                    transaction.action === 'Phone Bill'
                ) {
                    groupedTransactions[dateKey].details.emoneyChange -= amount; // Deduct amount from E-Money
                } else if (transaction.action === 'Received Money') {
                    groupedTransactions[dateKey].details.emoneyChange += amount; // Add amount to E-Money
                }
                // Accumulate commission and fee earned
                groupedTransactions[dateKey].details.totalCommission += commission;
                groupedTransactions[dateKey].details.totalFee += fee;
            });

            // Sort dates in descending order (most recent first)
            const sortedDates = Object.keys(groupedTransactions).sort().reverse();

            // Render each day's group
            for (const dateKey of sortedDates) {
                const groupData = groupedTransactions[dateKey];
                const displayDate = new Date(dateKey).toDateString(); // Format date for display
                const summary = groupData.details;

                const groupElement = document.createElement('div');
                groupElement.className = 'grouped-transaction';

                // Construct HTML for the group header and its items
                groupElement.innerHTML = `
                    <div class="group-header" onclick="toggleGroup(this.parentElement)">
                        <span>${displayDate}</span>
                        <span>E-Chg: ${formatNumber(summary.emoneyChange)} | C-Chg: ${formatNumber(summary.cashChange)} | Comm: ${formatNumber(summary.totalCommission)} | Fee: ${formatNumber(summary.totalFee)}</span>
                    </div>
                    <div class="group-details">
                        ${groupData.items.map(item => {
                            // Determine amount class for styling (positive/negative)
                            const amountClass = (item.action === 'Cash In' || item.action === 'Received Money') ? 'positive' : 'negative';
                            // Generate details HTML (commission, fee, phone, note)
                            let detailsHtml = '';
                            if (item.commission > 0) detailsHtml += `<span class="transaction-info-item"><strong>Comm:</strong> ${formatNumber(item.commission)}</span>`;
                            if (item.fee > 0) detailsHtml += `<span class="transaction-info-item"><strong>Fee:</strong> ${formatNumber(item.fee)}</span>`;
                            if (item.phone) detailsHtml += `<span class="transaction-info-item"><strong>Phone:</strong> ${item.phone}</span>`;
                            if (item.note) {
                                const truncatedNote = item.note.length > 50 ? item.note.substring(0, 50) + '...' : item.note; // Truncate long notes
                                detailsHtml += `<span class="transaction-info-item"><strong>Note:</strong> ${truncatedNote}</span>`;
                            }

                            return `
                                <div class="transaction-item">
                                    <div class="transaction-header">
                                        <span class="transaction-type">${item.type} - ${item.action}</span>
                                        <span class="transaction-amount ${amountClass}">${formatNumber(item.amount)}</span>
                                    </div>
                                    <div class="transaction-details-mobile">
                                        <span class="transaction-date">${new Date(item.date).toLocaleTimeString()}</span>
                                        <span class="transaction-info-item"><strong>ID:</strong> ${item.id}</span>
                                        ${detailsHtml}
                                    </div>
                                    <div class="transaction-actions">
                                        <button class="action-button-text edit" onclick="editTransaction(${item.originalIndex})">Edit</button>
                                        <button class="action-button-text delete" onclick="deleteTransaction(${item.originalIndex})">Delete</button>
                                    </div>
                                </div>
                            `;
                        }).join('')}
                    </div>
                `;
                listContainer.appendChild(groupElement); // Add the group to the list
            }
        }

        // Loads a transaction into the form for editing
        function editTransaction(index) {
            if (index < 0 || index >= transactions.length) {
                console.error("Invalid index for editTransaction:", index);
                showToast("Error loading transaction for editing.", "error");
                return;
            }
            const transaction = transactions[index];

            // Populate form fields
            document.getElementById('transaction-id').value = transaction.id;
            document.getElementById('transaction-date').value = transaction.date;

            const typeSelect = document.getElementById('transaction-type');
            const otherInput = document.getElementById('transaction-type-other');

            // Check if the transaction type is a custom one
            if (savedOtherTransactionTypes[transaction.type]) {
                typeSelect.value = 'other';
                otherInput.value = transaction.type;
                otherInput.style.display = 'block';
            } else {
                // Check if it's a predefined type
                const predefinedTypes = ["Wave Money", "Wave Pay", "KBZ Pay", "Aya Pay"];
                if (predefinedTypes.includes(transaction.type)) {
                    typeSelect.value = transaction.type;
                    otherInput.style.display = 'none';
                    otherInput.value = '';
                } else {
                    // If not predefined and not custom, treat as custom and add it
                    typeSelect.value = 'other';
                    otherInput.value = transaction.type;
                    otherInput.style.display = 'block';
                    if (!savedOtherTransactionTypes[transaction.type]) {
                        savedOtherTransactionTypes[transaction.type] = transaction.type;
                        try {
                            localStorage.setItem('moneyManager_savedOtherTransactionTypes', JSON.stringify(savedOtherTransactionTypes));
                        } catch (e) {
                            console.error("Error saving custom transaction type during edit:", e);
                        }
                        addOptionToSelect('transaction-type', transaction.type);
                    }
                }
            }

            document.getElementById('transaction-action').value = transaction.action;
            document.getElementById('transaction-amount').value = formatNumber(transaction.amount);
            document.getElementById('transaction-commission').value = transaction.commission ? formatNumber(transaction.commission) : '';
            document.getElementById('transaction-fee').value = transaction.fee ? formatNumber(transaction.fee) : '';

            // Format phone number for input
            if (transaction.phone && transaction.phone.startsWith('09')) {
                document.getElementById('transaction-phone').value = transaction.phone.substring(2);
            } else {
                document.getElementById('transaction-phone').value = transaction.phone || '';
            }

            document.getElementById('transaction-note').value = transaction.note || '';

            // Remove the transaction from the list temporarily while editing
            transactions.splice(index, 1);
            updateSummariesBasedOnCurrentView();
            updateTransactionList();
            showToast('Transaction loaded for editing');
            window.scrollTo(0, 0); // Scroll to top to focus on the form
        }

        // Deletes a transaction at the specified index after confirmation
        function deleteTransaction(index) {
            if (index < 0 || index >= transactions.length) {
                console.error("Invalid index for deleteTransaction:", index);
                showToast("Error deleting transaction.", "error");
                return;
            }

            if (confirm('Are you sure you want to delete this transaction? This action cannot be undone.')) {
                transactions.splice(index, 1); // Remove the transaction

                // Save the updated list
                try {
                    localStorage.setItem('moneyManager_transactions', JSON.stringify(transactions));
                    showToast('Transaction deleted successfully');
                } catch (e) {
                    console.error("Error saving transactions after delete:", e);
                    showToast('Error saving changes after deletion', 'error');
                }

                updateSummariesBasedOnCurrentView(); // Update summaries
                updateTransactionList(); // Refresh the displayed list
            }
        }

        // Filters the transaction list based on selected criteria (type, action, date)
        function filterTransactions() {
            const typeFilter = document.getElementById('transaction-filter-type').value;
            const actionFilter = document.getElementById('transaction-filter-action').value;
            const dateFilterValue = document.getElementById('transaction-filter-date').value;

            let filtered = transactions; // Start with all transactions

            // Apply type filter
            if (typeFilter !== 'all') {
                filtered = filtered.filter(t => t.type === typeFilter);
            }

            // Apply action filter
            if (actionFilter !== 'all') {
                filtered = filtered.filter(t => t.action === actionFilter);
            }

            // Apply date filter
            if (dateFilterValue) {
                try {
                    const filterDate = new Date(dateFilterValue);
                    filterDate.setHours(0, 0, 0, 0); // Set to start of day for comparison

                    filtered = filtered.filter(t => {
                        const transactionDateTime = new Date(t.date);
                        if (isNaN(transactionDateTime.getTime())) return false; // Skip if date is invalid
                        // Compare date parts only
                        return transactionDateTime.getFullYear() === filterDate.getFullYear() &&
                               transactionDateTime.getMonth() === filterDate.getMonth() &&
                               transactionDateTime.getDate() === filterDate.getDate();
                    });
                } catch (e) {
                    console.error("Error applying date filter:", e);
                    showToast("Error applying date filter.", "error");
                    filtered = []; // Clear filtered list on error
                }
            }

            currentFilteredTransactions = filtered; // Store the filtered list for summary updates
            updateTransactionList(filtered); // Update the displayed list with filtered results
            updateSummariesBasedOnCurrentView(); // Refresh summaries based on filtered data
        }

        // Resets all transaction filters to their default values and reloads the full list
        function resetTransactionFilters() {
            document.getElementById('transaction-filter-type').value = 'all';
            document.getElementById('transaction-filter-action').value = 'all';
            document.getElementById('transaction-filter-date').value = '';
            currentFilteredTransactions = []; // Clear the stored filtered list
            updateTransactionList(); // Reload the full list
            updateSummariesBasedOnCurrentView(); // Update summaries
        }

        // --- DAILY MONEY TAB FUNCTIONS ---

        // Toggles the visibility of the commission percentage input field based on the selected action
        function toggleCommissionField() {
            const action = document.getElementById('money-action').value;
            const commissionGroup = document.getElementById('money-commission-group');

            if (action === 'Emoney In') {
                commissionGroup.style.display = 'block'; // Show if E-Money In
            } else {
                commissionGroup.style.display = 'none'; // Hide otherwise
                document.getElementById('money-commission').value = ''; // Clear value when hidden
            }
        }

        // Calculates and formats the commission percentage input (allows only numbers and one decimal point)
        function calculateMoneyCommission() {
            const action = document.getElementById('money-action').value;
            const commissionPercentInput = document.getElementById('money-commission');
            const commissionGroup = document.getElementById('money-commission-group');

            if (action === 'Emoney In') {
                commissionGroup.style.display = 'block'; // Ensure visible
                let currentValue = commissionPercentInput.value;
                let cleanedValue = '';
                let dotFound = false; // To allow only one decimal point
                for (let i = 0; i < currentValue.length; i++) {
                    const char = currentValue[i];
                    if (char >= '0' && char <= '9') {
                        cleanedValue += char;
                    } else if (char === '.' && !dotFound) {
                        cleanedValue += '.';
                        dotFound = true;
                    }
                }
                commissionPercentInput.value = cleanedValue; // Update input with cleaned value
            } else {
                 commissionPercentInput.value = ''; // Clear if not E-Money In
                 commissionGroup.style.display = 'none';
            }
        }

        // Updates the visibility of the 'Other (Manual)' input for money record types
        function updateMoneyType() {
            const typeSelect = document.getElementById('money-type');
            const otherInput = document.getElementById('money-type-other');

            if (typeSelect.value === 'other') {
                otherInput.style.display = 'block'; // Show input
                otherInput.focus();
            } else {
                otherInput.style.display = 'none'; // Hide input
                otherInput.value = ''; // Clear input value
            }
        }

        // Adds a new money record based on form input
        function addMoneyRecord() {
            const date = document.getElementById('money-date').value;
            const amount = parseFloat(document.getElementById('money-amount').value.replace(/,/g, '')); // Parse amount
            const action = document.getElementById('money-action').value;
            let type = document.getElementById('money-type').value;
            const otherInput = document.getElementById('money-type-other');

            let finalType = type; // Type to be stored
            // Handle custom money record types
            if (type === 'other') {
                const customType = otherInput.value.trim();
                if (!customType) {
                    showToast('Please specify the other money record type', 'error');
                    return;
                }
                finalType = customType;
                // Save custom type if new
                if (!savedOtherMoneyTypes[finalType]) {
                    savedOtherMoneyTypes[finalType] = finalType;
                    try {
                        localStorage.setItem('moneyManager_savedOtherMoneyTypes', JSON.stringify(savedOtherMoneyTypes));
                    } catch (e) {
                        console.error("Error saving custom money type:", e);
                    }
                    addOptionToSelect('money-type', finalType); // Add to dropdown
                }
            }

            // Calculate actual commission for 'Emoney In'
            const commissionPercentage = parseFloat(document.getElementById('money-commission').value.replace(/,/g, ''));
            let actualCommission = 0;
            if (action === 'Emoney In' && !isNaN(amount) && amount > 0 && !isNaN(commissionPercentage) && commissionPercentage >= 0) {
                actualCommission = (amount * commissionPercentage) / 100;
            }

            const note = document.getElementById('money-note').value.trim();

            // Validation
            if (!date) { showToast('Date/Time is required.', 'error'); return; }
            if (!finalType) { showToast('Type is required.', 'error'); return; }
            if (isNaN(amount) || amount <= 0) { showToast('Amount must be a positive number.', 'error'); return; }

            // Create the record object
            const record = {
                date, amount, action, type: finalType, commission: actualCommission, note
            };

            moneyRecords.unshift(record); // Add to the beginning

            // Save to localStorage
            try {
                localStorage.setItem('moneyManager_moneyRecords', JSON.stringify(moneyRecords));
                showToast('Money record added successfully!');
            } catch (e) {
                console.error("Error saving money records:", e);
                showToast('Error saving money record', 'error');
            }

            updateSummariesBasedOnCurrentView(); // Update UI
            updateMoneyList(); // Refresh list display
            clearMoneyForm(); // Clear form
        }

        // Clears and resets the money record form fields
        function clearMoneyForm() {
            document.getElementById('money-amount').value = '';
            document.getElementById('money-action').value = 'Emoney In';
            document.getElementById('money-type').value = 'Wave Money';
            document.getElementById('money-type-other').value = '';
            document.getElementById('money-type-other').style.display = 'none';
            document.getElementById('money-commission').value = '';
            document.getElementById('money-commission-group').style.display = 'none'; // Ensure commission field is hidden by default
            document.getElementById('money-note').value = '';
            updateDateTimeFields(); // Reset date/time
        }

        // Renders the money records list, grouping them by date
        function updateMoneyList(filteredRecords = null) {
            const listContainer = document.querySelector('#money-list .transaction-list-items');
            listContainer.innerHTML = ''; // Clear existing list

            const recordsToShow = filteredRecords !== null ? filteredRecords : moneyRecords; // Use filtered list if available

            if (recordsToShow.length === 0) {
                listContainer.innerHTML += '<p class="no-data">No money records found.</p>';
                return;
            }

            // Group records by date
            const groupedRecords = {};
            recordsToShow.forEach((record, index) => {
                const dateKey = new Date(record.date).toISOString().split('T')[0]; // Date for grouping

                if (!groupedRecords[dateKey]) {
                    groupedRecords[dateKey] = {
                        items: [], // Store records for this date
                        details: { emoneyIn: 0, emoneyOut: 0, cashIn: 0, cashOut: 0, commission: 0 } // Daily summary totals
                    };
                }
                // Find original index for edit/delete
                const originalIndex = moneyRecords.findIndex(r => r.date === record.date && r.amount === record.amount && r.action === record.action);
                groupedRecords[dateKey].items.push({ ...record, originalIndex: originalIndex });

                // Calculate daily summary totals
                const recordAmount = parseFloat(record.amount);
                if (record.action === 'Emoney In') {
                    groupedRecords[dateKey].details.emoneyIn += recordAmount;
                    groupedRecords[dateKey].details.commission += parseFloat(record.commission); // Add commission
                } else if (record.action === 'Emoney Out') {
                    groupedRecords[dateKey].details.emoneyOut += recordAmount;
                } else if (record.action === 'Cash In') {
                    groupedRecords[dateKey].details.cashIn += recordAmount;
                } else if (record.action === 'Cash Out') {
                    groupedRecords[dateKey].details.cashOut += recordAmount;
                }
            });

            // Sort dates descending
            const sortedDates = Object.keys(groupedRecords).sort().reverse();

            // Render each day's group
            for (const dateKey of sortedDates) {
                const groupData = groupedRecords[dateKey];
                const displayDate = new Date(dateKey).toDateString();
                const summary = groupData.details;

                const groupElement = document.createElement('div');
                groupElement.className = 'grouped-transaction';

                groupElement.innerHTML = `
                    <div class="group-header" onclick="toggleGroup(this.parentElement)">
                        <span>${displayDate}</span>
                        <span>E-In: ${formatNumber(summary.emoneyIn)} | E-Out: ${formatNumber(summary.emoneyOut)} | C-In: ${formatNumber(summary.cashIn)} | C-Out: ${formatNumber(summary.cashOut)}</span>
                    </div>
                    <div class="group-details">
                        ${groupData.items.map(item => {
                            let detailsHtml = '';
                            // Show commission if > 0
                            if (item.commission > 0) detailsHtml += `<span class="transaction-info-item"><strong>Comm:</strong> ${formatNumber(item.commission)}</span>`;
                            // Show note if present
                            if (item.note) {
                                const truncatedNote = item.note.length > 50 ? item.note.substring(0, 50) + '...' : item.note;
                                detailsHtml += `<span class="transaction-info-item"><strong>Note:</strong> ${truncatedNote}</span>`;
                            }
                            return `
                                <div class="transaction-item">
                                    <div class="transaction-header">
                                        <span class="transaction-type">${item.type}</span>
                                        <span class="transaction-amount">${formatNumber(item.amount)}</span>
                                    </div>
                                    <div class="transaction-details-mobile">
                                        <span class="transaction-date">${new Date(item.date).toLocaleTimeString()}</span>
                                        <span class="transaction-info-item"><strong>Type:</strong> ${item.action}</span>
                                        ${detailsHtml}
                                    </div>
                                    <div class="transaction-actions">
                                        <button class="action-button-text edit" onclick="editMoneyRecord(${item.originalIndex})">Edit</button>
                                        <button class="action-button-text delete" onclick="deleteMoneyRecord(${item.originalIndex})">Delete</button>
                                    </div>
                                </div>
                            `;
                        }).join('')}
                    </div>
                `;
                listContainer.appendChild(groupElement);
            }
        }

        // Loads a money record into the form for editing
        function editMoneyRecord(index) {
            if (index < 0 || index >= moneyRecords.length) {
                console.error("Invalid index for editMoneyRecord:", index);
                showToast("Error loading money record for editing.", "error");
                return;
            }
            const record = moneyRecords[index];

            // Populate form
            document.getElementById('money-date').value = record.date;
            document.getElementById('money-amount').value = formatNumber(record.amount);
            document.getElementById('money-action').value = record.action;

            const typeSelect = document.getElementById('money-type');
            const otherInput = document.getElementById('money-type-other');

            // Handle custom type visibility
            if (savedOtherMoneyTypes[record.type]) {
                typeSelect.value = 'other';
                otherInput.value = record.type;
                otherInput.style.display = 'block';
            } else {
                 const predefinedTypes = ["Wave Money", "KBZ Pay", "Aya Pay"];
                if (predefinedTypes.includes(record.type)) {
                    typeSelect.value = record.type;
                    otherInput.style.display = 'none';
                    otherInput.value = '';
                } else {
                    // Treat as custom if not predefined and not already saved
                    typeSelect.value = 'other';
                    otherInput.value = record.type;
                    otherInput.style.display = 'block';
                    if (!savedOtherMoneyTypes[record.type]) {
                        savedOtherMoneyTypes[record.type] = record.type;
                        try {
                            localStorage.setItem('moneyManager_savedOtherMoneyTypes', JSON.stringify(savedOtherMoneyTypes));
                        } catch (e) {
                            console.error("Error saving custom money type during edit:", e);
                        }
                        addOptionToSelect('money-type', record.type);
                    }
                }
            }

            toggleCommissionField(); // Adjust commission field visibility
            if (record.action === 'Emoney In') {
                document.getElementById('money-commission').value = record.commission ? formatNumber(record.commission) : '';
            } else {
                document.getElementById('money-commission').value = '';
            }

            document.getElementById('money-note').value = record.note || '';

            // Remove record from list temporarily
            moneyRecords.splice(index, 1);
            updateSummariesBasedOnCurrentView();
            updateMoneyList();
            showToast('Money record loaded for editing');
            window.scrollTo(0, 0); // Scroll to form
        }

        // Deletes a money record at the specified index after confirmation
        function deleteMoneyRecord(index) {
            if (index < 0 || index >= moneyRecords.length) {
                console.error("Invalid index for deleteMoneyRecord:", index);
                showToast("Error deleting money record.", "error");
                return;
            }

            if (confirm('Are you sure you want to delete this record? This action cannot be undone.')) {
                moneyRecords.splice(index, 1); // Remove record

                // Save changes
                try {
                    localStorage.setItem('moneyManager_moneyRecords', JSON.stringify(moneyRecords));
                    showToast('Money record deleted successfully');
                } catch (e) {
                    console.error("Error saving money records after delete:", e);
                    showToast('Error saving changes after deletion', 'error');
                }

                updateSummariesBasedOnCurrentView(); // Update summaries
                updateMoneyList(); // Refresh list display
            }
        }

        // Filters the money records list based on selected criteria (action, date)
        function filterMoneyRecords() {
            const moneyActionFilter = document.getElementById('money-filter-action').value;
            const dateFilterValue = document.getElementById('money-filter-date').value;

            let filtered = moneyRecords; // Start with all records

            // Apply action filter
            if (moneyActionFilter !== 'all') {
                filtered = filtered.filter(r => r.action === moneyActionFilter);
            }

            // Apply date filter
            if (dateFilterValue) {
                try {
                    const filterDate = new Date(dateFilterValue);
                    filterDate.setHours(0, 0, 0, 0); // Start of day

                    filtered = filtered.filter(r => {
                        const recordDateTime = new Date(r.date);
                        if (isNaN(recordDateTime.getTime())) return false; // Skip invalid dates
                        // Compare date parts
                        return recordDateTime.getFullYear() === filterDate.getFullYear() &&
                               recordDateTime.getMonth() === filterDate.getMonth() &&
                               recordDateTime.getDate() === filterDate.getDate();
                    });
                } catch (e) {
                    console.error("Error applying date filter for money records:", e);
                    showToast("Error applying date filter.", "error");
                    filtered = []; // Clear list on error
                }
            }

            updateMoneyList(filtered); // Update list display
            updateSummariesBasedOnCurrentView(); // Update summaries
        }

        // Resets all money record filters and reloads the full list
        function resetMoneyFilters() {
            document.getElementById('money-filter-action').value = 'all';
            document.getElementById('money-filter-date').value = '';
            updateMoneyList(); // Reload full list
            updateSummariesBasedOnCurrentView(); // Update summaries
        }

        // --- UPDATE DAILY SUMMARIES ---

        // Updates various daily summary calculations for transactions and money records
        function updateDailySummaries(transactionsToProcess = null, recordsToSummarize = null) {
            // Determine the date for which to calculate summaries (from filters or today)
            const transactionFilterDateValue = document.getElementById('transaction-filter-date').value;
            const moneyFilterDateValue = document.getElementById('money-filter-date').value;
            let relevantDateFilterValue = moneyFilterDateValue || transactionFilterDateValue; // Use money filter date if available, otherwise transaction filter date

            let summaryStartDate, summaryEndDate;

            if (relevantDateFilterValue) {
                const filterDate = new Date(relevantDateFilterValue);
                summaryStartDate = new Date(filterDate);
                summaryStartDate.setHours(0, 0, 0, 0); // Start of the selected day
                summaryEndDate = new Date(filterDate);
                summaryEndDate.setHours(23, 59, 59, 999); // End of the selected day
            } else {
                // If no filter date is set, use today
                const today = new Date();
                summaryStartDate = new Date(today);
                summaryStartDate.setHours(0, 0, 0, 0); // Start of today
                summaryEndDate = new Date(today);
                summaryEndDate.setHours(23, 59, 59, 999); // End of today
            }

            // --- Transaction Tab Daily Changes Calculation ---
            let dailyEMoneyChangeFromTransactions = 0;
            let dailyCashChangeFromTransactions = 0;
            let totalDailyCommissionFromTransactions = 0;
            let totalDailyFeeFromTransactions = 0;

            const transactionsData = transactionsToProcess !== null ? transactionsToProcess : transactions; // Use provided filtered list or all transactions

            transactionsData.forEach(t => {
                const transactionDateTime = new Date(t.date);
                // Check if transaction falls within the summary date range
                if (transactionDateTime >= summaryStartDate && transactionDateTime <= summaryEndDate) {
                    const amount = parseFloat(t.amount);
                    const commission = parseFloat(t.commission) || 0;
                    const fee = parseFloat(t.fee) || 0;

                    // Track commission and fee earned
                    totalDailyCommissionFromTransactions += commission;
                    totalDailyFeeFromTransactions += fee;

                    // Adjust E-Money/Cash balances based on transaction action
                    if (t.action === 'Cash In') {
                        dailyEMoneyChangeFromTransactions -= amount; dailyCashChangeFromTransactions += amount;
                    } else if (t.action === 'Cash Out') {
                        dailyEMoneyChangeFromTransactions += amount; dailyCashChangeFromTransactions -= amount;
                    } else if (t.action === 'Send Money' || t.action === 'Payment' || t.action === 'Phone Bill') {
                        dailyEMoneyChangeFromTransactions -= amount; // Deduct from E-Money
                    } else if (t.action === 'Received Money') {
                        dailyEMoneyChangeFromTransactions += amount; // Add to E-Money
                    }
                    // Note: Commission and Fee are not directly added/subtracted from E-Money/Cash balances here.
                }
            });

            // Update transaction tab's daily summary spans
            document.getElementById('daily-e-money').textContent = formatNumber(dailyEMoneyChangeFromTransactions);
            document.getElementById('daily-cash').textContent = formatNumber(dailyCashChangeFromTransactions);
            document.getElementById('total-commission-summary').textContent = formatNumber(totalDailyCommissionFromTransactions);
            document.getElementById('total-fee-summary').textContent = formatNumber(totalDailyFeeFromTransactions);

            // --- Daily Money Tab Specific Summaries Calculation ---
            const dailySummaryForMoneyRecords = {
                emoneyIn: 0, emoneyOut: 0, cashIn: 0, cashOut: 0, commission: 0
            };

            const moneyRecordsData = recordsToSummarize !== null ? recordsToSummarize : moneyRecords; // Use provided filtered list or all records

            moneyRecordsData.forEach(r => {
                const recordDateTime = new Date(r.date);
                // Check if record falls within the summary date range
                if (recordDateTime >= summaryStartDate && recordDateTime <= summaryEndDate) {
                    const recordAmount = parseFloat(r.amount);
                    // Categorize and sum up amounts and commissions
                    if (r.action === 'Emoney In') {
                        dailySummaryForMoneyRecords.emoneyIn += recordAmount;
                        dailySummaryForMoneyRecords.commission += parseFloat(r.commission);
                    } else if (r.action === 'Emoney Out') {
                        dailySummaryForMoneyRecords.emoneyOut += recordAmount;
                    } else if (r.action === 'Cash In') {
                        dailySummaryForMoneyRecords.cashIn += recordAmount;
                    } else if (r.action === 'Cash Out') {
                        dailySummaryForMoneyRecords.cashOut += recordAmount;
                    }
                }
            });

            // Update daily money tab summary spans
            document.getElementById('daily-emoney-in').textContent = formatNumber(dailySummaryForMoneyRecords.emoneyIn);
            document.getElementById('daily-emoney-out').textContent = formatNumber(dailySummaryForMoneyRecords.emoneyOut);
            document.getElementById('daily-cash-in').textContent = formatNumber(dailySummaryForMoneyRecords.cashIn);
            document.getElementById('daily-cash-out').textContent = formatNumber(dailySummaryForMoneyRecords.cashOut);

            // Calculate and update remaining balance based on money records
            let dailyEMoneyBalanceChangeFromMoneyRecords = 0;
            let dailyCashBalanceChangeFromMoneyRecords = 0;
            moneyRecordsData.forEach(r => {
                const recordDateTime = new Date(r.date);
                if (recordDateTime >= summaryStartDate && recordDateTime <= summaryEndDate) {
                    const recordAmount = parseFloat(r.amount);
                    if (r.action === 'Emoney In') dailyEMoneyBalanceChangeFromMoneyRecords += recordAmount;
                    else if (r.action === 'Emoney Out') dailyEMoneyBalanceChangeFromMoneyRecords -= recordAmount;
                    else if (r.action === 'Cash In') dailyCashBalanceChangeFromMoneyRecords += recordAmount;
                    else if (r.action === 'Cash Out') dailyCashBalanceChangeFromMoneyRecords -= recordAmount;
                }
            });

            const totalDailyRemainingBalance = dailyEMoneyBalanceChangeFromMoneyRecords + dailyCashBalanceChangeFromMoneyRecords;
            document.getElementById('daily-remaining').textContent = formatNumber(totalDailyRemainingBalance);

            // Show commission if it's greater than zero
            if (dailySummaryForMoneyRecords.commission > 0) {
                document.getElementById('daily-money-commission-item').style.display = 'flex';
                document.getElementById('daily-money-commission').textContent = formatNumber(dailySummaryForMoneyRecords.commission);
            } else {
                document.getElementById('daily-money-commission-item').style.display = 'none';
            }

            // Auto-expand summary sections if they contain relevant data
            const transactionSummarySection = document.getElementById('transaction').querySelector('.summary-section');
            if (transactionSummarySection) {
                const hasTransactionData = (transactionsData.length > 0 || dailyEMoneyChangeFromTransactions !== 0 || dailyCashChangeFromTransactions !== 0 || totalDailyCommissionFromTransactions !== 0 || totalDailyFeeFromTransactions !== 0);
                // Expand if data exists and section is collapsed, or collapse if no data and section is expanded
                if (hasTransactionData && !transactionSummarySection.classList.contains('expanded')) {
                     toggleExpand(transactionSummarySection);
                } else if (!hasTransactionData && transactionSummarySection.classList.contains('expanded')) {
                    toggleExpand(transactionSummarySection);
                }
            }

            const dailyMoneySummarySection = document.querySelector('#daily-money .summary-section');
            if (dailyMoneySummarySection) {
                const hasMoneyRecordData = (moneyRecordsData.length > 0 || dailySummaryForMoneyRecords.emoneyIn !== 0 || dailySummaryForMoneyRecords.emoneyOut !== 0 || dailySummaryForMoneyRecords.cashIn !== 0 || dailySummaryForMoneyRecords.cashOut !== 0 || dailySummaryForMoneyRecords.commission !== 0);
                // Expand if data exists and section is collapsed, or collapse if no data and section is expanded
                if (hasMoneyRecordData && !dailyMoneySummarySection.classList.contains('expanded')) {
                    toggleExpand(dailyMoneySummarySection);
                } else if (!hasMoneyRecordData && dailyMoneySummarySection.classList.contains('expanded')) {
                    toggleExpand(dailyMoneySummarySection);
                }
            }
        }

        // Helper function to toggle the expanded/collapsed state of a summary section
        function toggleExpand(element) {
            element.classList.toggle('expanded'); // Toggle the 'expanded' class
            const summaryList = element.querySelector('.summary-list');
            if (summaryList) {
                summaryList.style.display = element.classList.contains('expanded') ? 'block' : 'none'; // Show/hide the list
            }
            // Update the arrow icon's rotation
            const arrow = element.querySelector('h2 .arrow');
            if (arrow) {
                arrow.style.transform = element.classList.contains('expanded') ? 'rotate(180deg)' : 'rotate(0deg)';
            }
        }

        // Helper function to ensure summaries are updated correctly, considering current filters
        function updateSummariesBasedOnCurrentView() {
            let filteredTransactionsForSummary = transactions; // Start with all transactions
            const transactionFilterDateValue = document.getElementById('transaction-filter-date').value;
            // If a date filter is active for transactions, apply it for summary calculation
            if (transactionFilterDateValue) {
                try {
                    const filterDate = new Date(transactionFilterDateValue);
                    filterDate.setHours(0, 0, 0, 0);

                    filteredTransactionsForSummary = transactions.filter(t => {
                        const transactionDateTime = new Date(t.date);
                        if (isNaN(transactionDateTime.getTime())) return false;
                        return transactionDateTime.getFullYear() === filterDate.getFullYear() &&
                               transactionDateTime.getMonth() === filterDate.getMonth() &&
                               transactionDateTime.getDate() === filterDate.getDate();
                    });
                } catch (e) {
                    console.error("Error during transaction filtering for summary update:", e);
                    filteredTransactionsForSummary = [];
                }
            }

            let filteredMoneyRecordsForSummary = moneyRecords; // Start with all money records
            const moneyActionFilterValue = document.getElementById('money-filter-action').value;
            const moneyDateFilterValue = document.getElementById('money-filter-date').value;

            // Apply money record filters if they are active
            if (moneyActionFilterValue !== 'all') {
                filteredMoneyRecordsForSummary = filteredMoneyRecordsForSummary.filter(r => r.action === moneyActionFilterValue);
            }

            if (moneyDateFilterValue) {
                try {
                    const filterDate = new Date(moneyDateFilterValue);
                    filterDate.setHours(0, 0, 0, 0);

                    filteredMoneyRecordsForSummary = filteredMoneyRecordsForSummary.filter(r => {
                        const recordDateTime = new Date(r.date);
                        if (isNaN(recordDateTime.getTime())) return false;
                        return recordDateTime.getFullYear() === filterDate.getFullYear() &&
                               recordDateTime.getMonth() === filterDate.getMonth() &&
                               recordDateTime.getDate() === filterDate.getDate();
                    });
                } catch (e) {
                    console.error("Error during money record filtering for summary update:", e);
                    filteredMoneyRecordsForSummary = [];
                }
            }

            // Re-render lists if they are currently visible and expanded to reflect filter changes
            if (document.getElementById('daily-money').classList.contains('active') && document.getElementById('money-list').classList.contains('expanded')) {
                updateMoneyList(filteredMoneyRecordsForSummary); // Update money list with filtered data
            }
            if (document.getElementById('transaction').classList.contains('active') && document.getElementById('transaction-list').classList.contains('expanded')) {
                updateTransactionList(currentFilteredTransactions); // Update transaction list with currently filtered data
            }

            // Update all summaries regardless of whether lists are expanded
            updateDailySummaries(filteredTransactionsForSummary, filteredMoneyRecordsForSummary);
            updateTransactionTabBalances(); // Update balances on the transaction tab

            // Update expense summaries if expense tab is active
            if (document.getElementById('expense').classList.contains('active')) {
                updateExpenseSummaries();
                updatePeriodicalExpenseSummaries();
            }
        }

        // --- EXPORT FUNCTIONS (EXCEL & PDF) ---

        // Exports the transaction data to an Excel file (.xlsx)
        function exportToExcel() {
            if (transactions.length === 0) {
                showToast('No transactions to export', 'error');
                return;
            }

            // Prepare data for Excel sheet
            const dataForExcel = transactions.map(t => ({
                'Transaction ID': t.id,
                'Date': new Date(t.date).toLocaleString(), // Format date/time
                'Type': t.type,
                'Action': t.action,
                'Amount': t.amount,
                'Commission': t.commission,
                'Fee': t.fee,
                'Phone': t.phone,
                'Note': t.note
            }));

            // Create worksheet and workbook using XLSX library
            const ws = XLSX.utils.json_to_sheet(dataForExcel);
            const wb = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(wb, ws, "Transactions"); // Add sheet to workbook

            try {
                XLSX.writeFile(wb, "MoneyManager_Transactions.xlsx"); // Trigger download
                showToast('Transactions exported to Excel!');
            } catch (e) {
                console.error("Error during Excel export:", e);
                showToast("Error exporting to Excel", "error");
            }
        }

        // Exports the transaction list to a PDF document using html2canvas and jsPDF
        function exportToPDF() {
            if (transactions.length === 0) {
                showToast('No transactions to export', 'error');
                return;
            }

            const transactionListSection = document.getElementById('transaction-list');
            if (!transactionListSection) {
                showToast('Transaction list section not found', 'error');
                return;
            }

            // Ensure the transaction list is expanded and rendered before capturing
            if (transactionListSection.classList.contains('expanded') === false) {
                 toggleTransactionList(); // Expand if collapsed
            }
            // Re-render if list is empty or shows "no data" message, but there are actual transactions
            if (transactionListSection.querySelector('.transaction-list-items').innerHTML.trim() === '' || transactionListSection.querySelector('.no-data')) {
                 if (transactions.length > 0) {
                    updateTransactionList(); // Render the list if it's empty
                 }
            }

            // Use a short delay to ensure rendering/expansion is complete
            setTimeout(() => {
                const captureTarget = document.getElementById('transaction'); // Target the whole tab content for capture
                if (!captureTarget) {
                    showToast('Transaction tab content not found for capture', 'error');
                    return;
                }

                // Create a temporary wrapper to isolate the content to be captured
                const tempWrapper = document.createElement('div');
                tempWrapper.style.cssText = 'position: absolute; left: -9999px; top: 0; opacity: 1; width: auto; height: auto; visibility: visible; padding: 20px; background-color: #ffffff; z-index: 10000; font-family: Arial, sans-serif;';

                // Clone the transaction list items, remove action buttons, and add a title
                const clonedListItems = transactionListSection.querySelector('.transaction-list-items').cloneNode(true);
                const actionButtons = clonedListItems.querySelectorAll('.transaction-actions');
                actionButtons.forEach(el => el.style.display = 'none'); // Hide edit/delete buttons

                const activeItems = clonedListItems.querySelectorAll('.transaction-item.active');
                activeItems.forEach(item => item.classList.remove('active')); // Remove active state for cleaner capture

                tempWrapper.innerHTML = `
                    <h2 style="text-align: center; margin-bottom: 25px; color: #4CAF50; font-size: 24px; border-bottom: 2px solid #4CAF50; padding-bottom: 10px;">Transaction History</h2>
                    <div style="margin-bottom: 20px; font-size: 14px;">
                        ${clonedListItems.innerHTML}
                    </div>
                `;
                document.body.appendChild(tempWrapper); // Add wrapper to DOM for capture

                // Use html2canvas to capture the wrapper content as an image
                html2canvas(tempWrapper, {
                    useCORS: true, // Use CORS for images if any are loaded
                    logging: true, // Enable logging for debugging
                    letterRendering: true, // Improve text rendering
                    scale: 2, // Increase scale for better resolution
                    backgroundColor: '#ffffff' // Ensure background is white
                })
                .then(canvas => {
                    if (tempWrapper.parentNode) {
                        document.body.removeChild(tempWrapper); // Remove wrapper after capture
                    }

                    const imgData = canvas.toDataURL('image/png'); // Get image data URL
                    let pdf;

                    try {
                        // Check if jsPDF is loaded correctly
                        if (typeof jspdf === 'undefined' || typeof jspdf.jsPDF === 'undefined') {
                            throw new Error("jsPDF library is not loaded or accessible.");
                        }
                        pdf = new jspdf.jsPDF('p', 'mm', 'a4'); // Initialize PDF document (portrait, mm, A4)
                    } catch (e) {
                        console.error("PDF initialization error:", e);
                        showToast("Error initializing PDF generator. Ensure jsPDF is loaded correctly.", "error");
                        return;
                    }

                    const imgProps = canvas; // Image properties from html2canvas
                    const pdfWidth = pdf.internal.pageSize.getWidth(); // PDF page width
                    const pdfHeight = pdf.internal.pageSize.getHeight(); // PDF page height

                    // Calculate scaled image height to fit PDF page width while maintaining aspect ratio
                    const aspectRatio = imgProps.height / imgProps.width;
                    let scaledHeight = pdfWidth * aspectRatio;

                    const pageMargin = 15; // Define page margins

                    // Adjust scaled height if it exceeds page height minus margins
                    if (scaledHeight > pdfHeight - (2 * pageMargin)) {
                        scaledHeight = pdfHeight - (2 * pageMargin);
                    }

                    // Add the captured image to the PDF
                    pdf.addImage(imgData, 'PNG', 0, pageMargin, pdfWidth, scaledHeight);

                    try {
                        pdf.save("MoneyManager_Transactions.pdf"); // Save the PDF file
                        showToast('Transactions exported to PDF!');
                    } catch (e) {
                        console.error("Error saving PDF:", e);
                        showToast("Error saving PDF", "error");
                    }
                })
                .catch(error => {
                    // Handle errors during canvas capture
                    if (tempWrapper.parentNode) {
                        document.body.removeChild(tempWrapper);
                    }
                    console.error("Error capturing transactions for PDF: ", error);
                    showToast('Failed to export transactions to PDF: ' + error.message, 'error');
                });
            }, 300); // Delay ensures rendering is complete
        }

        // --- TOGGLE VISIBILITY OF COLLAPSIBLE LISTS ---

        // Toggles the expanded/collapsed state of the transaction list
        function toggleTransactionList() {
            const listContainer = document.getElementById('transaction-list');
            listContainer.classList.toggle('expanded'); // Toggle the 'expanded' class
            // If expanded and list is currently empty or showing 'no data', re-render it
            if (listContainer.classList.contains('expanded') && (listContainer.querySelector('.grouped-transaction') === null || listContainer.querySelector('.no-data'))) {
                 if (transactions.length > 0) {
                    updateTransactionList(); // Render the list if there are transactions
                 }
            }
        }

        // Toggles the expanded/collapsed state of the money records list
        function toggleMoneyList() {
            const listContainer = document.getElementById('money-list');
            listContainer.classList.toggle('expanded'); // Toggle the 'expanded' class
            // If expanded and list is currently empty or showing 'no data', re-render it
            if (listContainer.classList.contains('expanded') && (listContainer.querySelector('.grouped-transaction') === null || listContainer.querySelector('.no-data'))) {
                 if (moneyRecords.length > 0) {
                    updateMoneyList(); // Render the list if there are records
                 }
            }
        }

        // Toggles the expanded/collapsed state of the daily transaction summaries section
        function toggleTransactionSummary() {
            const summaryContainer = document.getElementById('transaction').querySelector('.summary-section');
            toggleExpand(summaryContainer);
        }

        // Toggles the expanded/collapsed state of the daily money record summaries section
        function toggleDailyMoneySummary() {
            const summaryContainer = document.getElementById('daily-money').querySelector('.summary-section');
            toggleExpand(summaryContainer);
        }

        // Generic function to toggle the expanded/collapsed state of a group (used for transactions/records)
        function toggleGroup(groupElement) {
            groupElement.classList.toggle('expanded'); // Toggle the 'expanded' class on the parent .grouped-transaction element
        }

        // --- DEBT/CREDIT TAB FUNCTIONS ---

        // Updates the `existingDebtNames` array with unique names from the current `debts` data for autocomplete
        function updateExistingDebtNames() {
            const nameSet = new Set(); // Use a Set to store unique names efficiently
            debts.forEach(debtGroup => {
                nameSet.add(debtGroup.name.toLowerCase()); // Add names in lowercase for case-insensitive matching
            });
            existingDebtNames = Array.from(nameSet); // Convert Set back to array
        }

        // Handles input in the debt name field to show autocomplete suggestions
        function handleDebtNameInput(event) {
            const inputField = event.target;
            const name = inputField.value.trim();
            const suggestionsContainer = document.getElementById('debt-name-suggestions');

            // Clear previous suggestions and hide the container initially
            if (suggestionsContainer) {
                suggestionsContainer.innerHTML = '';
                suggestionsContainer.style.display = 'none';
            }

            if (name.length < 2) return; // Don't show suggestions for very short inputs

            // Find matching names from existing debt names
            const matchingNames = existingDebtNames
                .filter(existingName => existingName.includes(name.toLowerCase())) // Filter names containing the input
                .slice(0, 5); // Limit to top 5 suggestions

            // If matches are found and suggestions container exists, display them
            if (matchingNames.length > 0 && suggestionsContainer) {
                suggestionsContainer.style.display = 'block';
                matchingNames.forEach(match => {
                    const suggestionItem = document.createElement('div');
                    suggestionItem.className = 'debt-suggestion-item';
                    // Capitalize the first letter of the suggestion for display
                    suggestionItem.textContent = match.charAt(0).toUpperCase() + match.slice(1);
                    // Set click handler to populate input and hide suggestions
                    suggestionItem.onclick = () => {
                        inputField.value = suggestionItem.textContent;
                        if (suggestionsContainer) suggestionsContainer.style.display = 'none';
                        // Remove the global click listener if it exists
                        if (hideSuggestionsOnClickOutside) {
                            document.removeEventListener('click', hideSuggestionsOnClickOutside);
                            hideSuggestionsOnClickOutside = null;
                        }
                    };
                    suggestionsContainer.appendChild(suggestionItem);
                });

                // Add a global click listener to close suggestions when clicking outside
                if (!hideSuggestionsOnClickOutside) {
                    hideSuggestionsOnClickOutside = (e) => {
                        // Check if the click was outside the input and suggestions container
                        if (suggestionsContainer && !suggestionsContainer.contains(e.target) && !inputField.contains(e.target)) {
                            suggestionsContainer.style.display = 'none'; // Hide suggestions
                            document.removeEventListener('click', hideSuggestionsOnClickOutside); // Remove listener
                            hideSuggestionsOnClickOutside = null;
                        }
                    };
                    document.addEventListener('click', hideSuggestionsOnClickOutside);
                }
            }
        }

        // Handles adding a new debt/credit entry or updating an existing one
        function addOrUpdateDebtEntry() {
            const nameInput = document.getElementById('debt-name');
            const name = nameInput.value.trim();

            const type = document.getElementById('debt-type').value; // 'payable' or 'receivable'
            const amountStr = document.getElementById('debt-amount').value;
            const amount = parseFloat(amountStr.replace(/,/g, '')); // Parse amount
            const date = document.getElementById('debt-date').value;
            const note = document.getElementById('debt-note').value.trim();

            // Validation
            if (!name) { showToast("Name is required.", "error"); return; }
            if (isNaN(amount) || amount <= 0) { showToast("Amount must be a positive number.", "error"); return; }
            if (!date) { showToast("Date/Time is required.", "error"); return; }

            // Determine the type of the history entry
            let historyEntryType;
            if (editingDebtEntry) { // If editing, use the original type of the entry
                historyEntryType = editingDebtEntry.type;
            } else { // If adding new, determine type based on the selected group type
                historyEntryType = type === 'payable' ? 'initial_payable' : 'initial_receivable';
            }

            // Create the new or updated history entry object
            const newOrUpdatedEntry = {
                id: editingDebtEntry ? editingDebtEntry.id : Date.now().toString(), // Use existing ID if editing, otherwise generate new
                date: date,
                amount: amount,
                type: historyEntryType, // Type of this specific transaction (initial/payment)
                note: note
            };

            // Find the index of the debt group for the given name and type
            let debtGroupIndex = debts.findIndex(debt => debt.name === name && debt.type === type);
            let targetGroupType = type; // The type of the group we are working with

            // If the debt group doesn't exist, create it
            if (debtGroupIndex === -1) {
                // Generate a unique ID for the group itself
                debts.push({ name: name, type: targetGroupType, history: [], id: `debtGroup_${Date.now()}` });
                debtGroupIndex = debts.length - 1; // Get the index of the newly added group
            }

            // Handle cases where editing might change the group type (e.g., payable to receivable)
            let needsReconciliation = false;
            if (editingDebtEntry && editingDebtEntry.groupType !== targetGroupType) {
                needsReconciliation = true; // Indicate that the entry needs to be moved to a different group
            }

            // Logic for updating or adding the entry
            if (editingDebtEntry && needsReconciliation) {
                // Find the original group and remove the entry from it
                const originalGroupIndex = debts.findIndex(debt => debt.name === name && debt.type === editingDebtEntry.groupType);
                if (originalGroupIndex !== -1) {
                    const originalEntryIndex = debts[originalGroupIndex].history.findIndex(entry => entry.id.toString() === editingDebtEntry.id.toString());
                    if (originalEntryIndex !== -1) {
                        debts[originalGroupIndex].history.splice(originalEntryIndex, 1); // Remove entry
                        // If the group becomes empty, remove the group itself
                        if (debts[originalGroupIndex].history.length === 0) {
                            debts.splice(originalGroupIndex, 1);
                        }
                    }
                }
                // Add the entry to the new (target) group
                debts[debtGroupIndex].history.push(newOrUpdatedEntry);
            } else if (editingDebtEntry) {
                // If editing within the same group, find the entry and update it
                const entryIndexInGroup = debts[debtGroupIndex].history.findIndex(entry => entry.id.toString() === editingDebtEntry.id.toString());
                if (entryIndexInGroup !== -1) {
                    debts[debtGroupIndex].history[entryIndexInGroup] = newOrUpdatedEntry; // Update the entry
                } else {
                    // If for some reason the entry wasn't found (e.g., group was created during edit), just add it
                    debts[debtGroupIndex].history.push(newOrUpdatedEntry);
                }
            } else {
                // If adding a new entry to an existing or newly created group
                debts[debtGroupIndex].history.push(newOrUpdatedEntry);
            }

            updateExistingDebtNames(); // Update the list of names for autocomplete
            saveData(); // Save changes to localStorage
            renderDebts(); // Re-render the debt lists
            clearDebtForm(); // Clear the form
            showToast(editingDebtEntry ? 'Debt/Credit entry updated successfully!' : 'Debt/Credit added successfully!'); // Show success message
            editingDebtEntry = null; // Reset editing state
            updateAddUpdateButtonText(); // Update button text
        }

        // Updates the text and icon of the "Add/Update Debt/Credit" button based on editing state
        function updateAddUpdateButtonText() {
            const button = document.getElementById('add-update-debt-button');
            if (editingDebtEntry) {
                button.textContent = 'Update Entry'; // Change text to 'Update' if editing
            } else {
                button.textContent = 'Add Debt/Credit'; // Default text
            }
        }

        // Clears and resets the debt/credit form fields
        function clearDebtForm() {
            document.getElementById('debt-name').value = '';
            const suggestionsContainer = document.getElementById('debt-name-suggestions');
            if (suggestionsContainer) {
                suggestionsContainer.innerHTML = ''; // Clear suggestions
                suggestionsContainer.style.display = 'none'; // Hide container
            }
            // Remove the global click listener for suggestions if it exists
            if (hideSuggestionsOnClickOutside) {
                document.removeEventListener('click', hideSuggestionsOnClickOutside);
                hideSuggestionsOnClickOutside = null;
            }

            document.getElementById('debt-type').value = 'payable'; // Reset type
            document.getElementById('debt-amount').value = '';
            updateDateTimeFields(); // Reset date/time
            document.getElementById('debt-note').value = '';
            updateDebtFormVisibility(); // Update UI based on type (if any)

            editingDebtEntry = null; // Clear editing state
            updateAddUpdateButtonText(); // Reset button text
        }

        // Renders the debts and credits lists, organized by name and type, calculating current balances
        function renderDebts() {
            const payableList = document.querySelector('#payable-debts-list .transaction-list-items');
            const receivableList = document.querySelector('#receivable-debts-list .transaction-list-items');
            payableList.innerHTML = ''; // Clear existing lists
            receivableList.innerHTML = '';

            let totalPayable = 0; // Total amount you owe
            let totalReceivable = 0; // Total amount others owe you

            // Aggregate debts by name and type to calculate balances
            const aggregatedDebts = {};

            debts.forEach(debtGroup => {
                const { name, type, history, id } = debtGroup;
                // Initialize aggregation for the name if it doesn't exist
                if (!aggregatedDebts[name]) {
                    aggregatedDebts[name] = {
                        payableHistory: [], // History for when you owe money
                        receivableHistory: [], // History for when others owe you
                    };
                }
                // Add history entries to the correct list based on group type
                if (type === 'payable') {
                    aggregatedDebts[name].payableHistory.push(...history.map(h => ({...h, groupId: id}))); // Include group ID for reference
                } else {
                    aggregatedDebts[name].receivableHistory.push(...history.map(h => ({...h, groupId: id})));
                }
            });

            // Sort names alphabetically for consistent display
            const sortedNames = Object.keys(aggregatedDebts).sort();

            // Process each aggregated debt entry
            sortedNames.forEach(name => {
                const debtAggregation = aggregatedDebts[name];

                // Process Payable Debts
                if (debtAggregation.payableHistory.length > 0) {
                    let currentPayableTotal = 0; // Track the net amount owed for this name
                    debtAggregation.payableHistory.sort((a, b) => new Date(a.date) - new Date(b.date)); // Sort history by date
                    debtAggregation.payableHistory.forEach(entry => {
                        // Adjust total based on transaction type
                        if (entry.type === 'initial_payable' || entry.type === 'payment_out') {
                            currentPayableTotal += entry.amount; // Add to amount owed if it's an initial debt or a payment made
                        } else if (entry.type === 'initial_receivable' || entry.type === 'payment_in') {
                            currentPayableTotal -= entry.amount; // Subtract if it's a payment received (reducing what you owe)
                        }
                    });
                    currentPayableTotal = Math.max(0, currentPayableTotal); // Ensure total doesn't go below zero

                    if (currentPayableTotal > 0) {
                        totalPayable += currentPayableTotal; // Add to overall total payable
                        // Create and append the list item for payable debt
                        const payableDiv = createDebtListItem(name, 'payable', currentPayableTotal, debtAggregation.payableHistory);
                        payableList.appendChild(payableDiv);
                    }
                }

                // Process Receivable Credits
                if (debtAggregation.receivableHistory.length > 0) {
                    let currentReceivableTotal = 0; // Track the net amount owed to you
                    debtAggregation.receivableHistory.sort((a, b) => new Date(a.date) - new Date(b.date)); // Sort history by date
                    debtAggregation.receivableHistory.forEach(entry => {
                        // Adjust total based on transaction type
                        if (entry.type === 'initial_receivable' || entry.type === 'payment_in') {
                            currentReceivableTotal += entry.amount; // Add to amount owed to you
                        } else if (entry.type === 'initial_payable' || entry.type === 'payment_out') {
                            currentReceivableTotal -= entry.amount; // Subtract if it's a payment made (reducing what you're owed)
                        }
                    });
                    currentReceivableTotal = Math.max(0, currentReceivableTotal); // Ensure total doesn't go below zero

                    if (currentReceivableTotal > 0) {
                        totalReceivable += currentReceivableTotal; // Add to overall total receivable
                        // Create and append the list item for receivable credit
                        const receivableDiv = createDebtListItem(name, 'receivable', currentReceivableTotal, debtAggregation.receivableHistory);
                        receivableList.appendChild(receivableDiv);
                    }
                }
            });

            // Update the display of total payable and receivable amounts
            document.getElementById('total-payable-amount').textContent = formatNumber(totalPayable);
            document.getElementById('total-receivable-amount').textContent = formatNumber(totalReceivable);

            // Display "No data" messages if lists are empty
            if (payableList.children.length === 0) {
                payableList.innerHTML = '<p class="no-data">No payable debts found.</p>';
            }
            if (receivableList.children.length === 0) {
                receivableList.innerHTML = '<p class="no-data">No receivable credits found.</p>';
            }
        }

        // Helper function to create the HTML structure for a debt list item (group)
        function createDebtListItem(name, type, amount, history) {
            const debtDiv = document.createElement('div');
            debtDiv.className = 'debt-list-item';
            debtDiv.dataset.name = name; // Store name for potential use
            debtDiv.dataset.type = type; // Store type for potential use

            // Determine amount class for styling (positive/negative)
            const amountClass = type === 'payable' ? 'negative' : 'positive';
            const formattedAmount = formatNumber(amount); // Format amount

            const historyHtml = generateHistoryHtml(history); // Generate HTML for history entries

            // Create the HTML structure for the debt list item
            debtDiv.innerHTML = `
                <div class="debt-item-summary" onclick="toggleDebtDetails(event, '${name.replace(/'/g, "\\'")}', '${type}')">
                    <div class="debt-name">${name}</div>
                    <span class="debt-amount ${amountClass}">${formattedAmount}</span>
                </div>
                <div class="debt-item-details-expanded" id="debt-details-${name.replace(/'/g, "\\'")}-${type}">
                    <div class="debt-actions">
                        <button class="action-button-text delete" onclick="deleteDebtGroup('${name.replace(/'/g, "\\'")}','${type}')"><i class="fas fa-trash-alt"></i> Delete Group</button>
                        <button class="action-button-text secondary" onclick="toggleDetailsButtonAction('${name.replace(/'/g, "\\'")}', '${type}')"><i class="fas fa-ellipsis-h"></i> Details</button>
                    </div>
                    <div class="debt-details">
                        <span class="debt-type">${type === 'payable' ? 'You owe' : 'Owed to you'}</span>
                        ${historyHtml ? `<span class="debt-note">${history.length} entries</span>` : ''}
                    </div>
                    ${historyHtml}
                </div>
            `;
            return debtDiv;
        }

        // Toggles the visibility of the detailed history for a debt entry when the summary is clicked
        function toggleDebtDetails(event, name, type) {
            // Prevent toggling if the click was on an action button
            if (event.target.closest('.debt-actions') || event.target.closest('button')) {
                return;
            }

            const detailsDiv = document.getElementById(`debt-details-${name}-${type}`); // Get the details container
            if (detailsDiv) {
                detailsDiv.classList.toggle('visible'); // Toggle the 'visible' class
                updateToggleButtonIconAndText(name, type); // Update the 'Details' button appearance
            }
        }

        // Handles the click event for the 'Details' button within a debt item's actions
        function toggleDetailsButtonAction(name, type) {
            const detailsDiv = document.getElementById(`debt-details-${name}-${type}`);
            const toggleButton = detailsDiv ? detailsDiv.querySelector('.debt-actions button[onclick*="toggleDetailsButtonAction"]') : null;

            if (toggleButton && detailsDiv) {
                detailsDiv.classList.toggle('visible'); // Toggle visibility
                updateToggleButtonIconAndText(name, type); // Update button appearance
            }
        }

        // Updates the icon and text of the 'Details' button based on the visibility of the history
        function updateToggleButtonIconAndText(name, type) {
            const detailsDiv = document.getElementById(`details-${name}-${type}`);
            const toggleButton = detailsDiv ? detailsDiv.querySelector('.debt-actions button[onclick*="toggleDetailsButtonAction"]') : null;

            if (toggleButton && detailsDiv) {
                const iconElement = toggleButton.querySelector('.fa-ellipsis-h, .fa-times'); // Find the icon
                if (detailsDiv.classList.contains('visible')) {
                    // If visible, change icon to 'times' and text to 'Hide Details'
                    if (iconElement) iconElement.classList.replace('fa-ellipsis-h', 'fa-times');
                    toggleButton.textContent = ' Hide Details';
                } else {
                    // If hidden, change icon back to 'ellipsis-h' and text to 'Details'
                    if (iconElement) iconElement.classList.replace('fa-times', 'fa-ellipsis-h');
                    toggleButton.textContent = ' Details';
                }
            }
        }

        // Loads a specific history entry into the form for editing
        function editDebtHistoryEntry(entryId) {
            // Iterate through debts to find the entry by ID
            for (let i = 0; i < debts.length; i++) {
                const debtGroup = debts[i];
                const historyEntryIndex = debtGroup.history.findIndex(entry => entry.id.toString() === entryId.toString());

                if (historyEntryIndex !== -1) {
                    const entryToEdit = debtGroup.history[historyEntryIndex];

                    // Populate the form with the entry's data
                    document.getElementById('debt-name').value = debtGroup.name;
                    document.getElementById('debt-type').value = debtGroup.type;
                    document.getElementById('debt-amount').value = formatNumber(entryToEdit.amount);
                    document.getElementById('debt-date').value = entryToEdit.date;
                    document.getElementById('debt-note').value = entryToEdit.note || '';
                    updateDebtFormVisibility(); // Update UI if type affects it

                    // Set editing state
                    editingDebtEntry = {
                        id: entryToEdit.id,
                        type: entryToEdit.type,
                        groupType: debtGroup.type, // Store original group type
                        groupIdx: i, // Store original group index
                        entryIdx: historyEntryIndex // Store original entry index
                    };
                    updateAddUpdateButtonText(); // Change button text to 'Update'

                    // Remove the entry from its original location temporarily
                    debtGroup.history.splice(historyEntryIndex, 1);

                    // If the group becomes empty, remove the group itself
                    if (debtGroup.history.length === 0) {
                        debts.splice(i, 1);
                    }

                    saveData(); // Save changes
                    renderDebts(); // Re-render lists
                    showToast('Entry loaded for editing. Update form and click Update.');
                    window.scrollTo(0, 0); // Scroll to form
                    return; // Exit loop once found
                }
            }
            showToast("Entry not found for editing.", "error"); // Show error if entry not found
        }

        // Deletes a specific history entry from a debt group after confirmation
        function deleteDebtHistoryEntry(entryId) {
            if (!confirm('Are you sure you want to delete this history entry?')) {
                return;
            }

            // Find the entry and delete it
            for (let i = 0; i < debts.length; i++) {
                const debtGroup = debts[i];
                const historyEntryIndex = debtGroup.history.findIndex(entry => entry.id.toString() === entryId.toString());

                if (historyEntryIndex !== -1) {
                    debtGroup.history.splice(historyEntryIndex, 1); // Remove the entry

                    // If the group becomes empty, remove the group
                    if (debtGroup.history.length === 0) {
                        debts.splice(i, 1);
                    }

                    saveData(); // Save changes
                    renderDebts(); // Re-render lists
                    showToast('History entry deleted successfully.');
                    return; // Exit loop
                }
            }
            showToast("Entry not found for deletion.", "error"); // Show error if not found
        }

        // Deletes an entire debt group after confirmation
        function deleteDebtGroup(name, type) {
             if (!confirm(`Are you sure you want to delete the entire group for "${name}" (${type})? This action cannot be undone.`)) {
                return;
            }

            // Find the group to delete
            const groupIndexToDelete = debts.findIndex(debt => debt.name === name && debt.type === type);

            if (groupIndexToDelete !== -1) {
                debts.splice(groupIndexToDelete, 1); // Remove the group
                saveData(); // Save changes
                renderDebts(); // Re-render lists
                showToast('Debt group deleted successfully.');
            } else {
                showToast('Group not found for deletion.', 'error');
            }
        }

        // Placeholder function for UI changes based on debt type selection (can be expanded later)
        function updateDebtFormVisibility() {
            // Currently no specific UI changes based on debt type selection in the form
        }

        // Filters the debt/credit lists based on a name search input
        function filterDebts() {
            const nameFilter = document.getElementById('debt-filter-name').value.toLowerCase(); // Get filter text
            let filteredDebts = debts;

            if (nameFilter) {
                // Filter debts where the name includes the filter text
                filteredDebts = filteredDebts.filter(debtGroup => debtGroup.name.toLowerCase().includes(nameFilter));
            }

            renderDebtsFiltered(filteredDebts); // Render the filtered list
        }

        // Resets the debt/credit filters and shows all debts
        function resetDebtFilters() {
            document.getElementById('debt-filter-name').value = ''; // Clear the filter input
            renderDebts(); // Show all debts again
        }

        // Generates the HTML for the history entries of a debt group
        function generateHistoryHtml(history) {
            if (!history || history.length === 0) return ''; // Return empty string if no history

            let historyHtml = '<div class="debt-history-list">';
            const sortedHistory = [...history].sort((a, b) => new Date(a.date) - new Date(b.date)); // Sort history by date

            // Iterate through sorted history entries
            sortedHistory.forEach(entry => {
                const entryDateTime = new Date(entry.date);
                const entryDisplay = entryDateTime.toLocaleString(); // Formatted date and time

                let amountClass = ''; // Class for styling amount (positive/negative)
                let entryTypeLabel = ''; // Label for the type of history entry

                // Determine label and class based on entry type
                switch (entry.type) {
                    case 'initial_payable': amountClass = 'negative'; entryTypeLabel = 'Initial Debt'; break;
                    case 'initial_receivable': amountClass = 'positive'; entryTypeLabel = 'Initial Credit'; break;
                    case 'payment_out': amountClass = 'negative'; entryTypeLabel = 'Paid'; break;
                    case 'payment_in': amountClass = 'positive'; entryTypeLabel = 'Received'; break;
                    default: // Handle any other custom types
                        amountClass = '';
                        entryTypeLabel = entry.type.charAt(0).toUpperCase() + entry.type.slice(1).replace('_', ' '); // Capitalize and replace underscores
                        break;
                }

                const noteDisplay = entry.note ? ` - ${entry.note}` : ''; // Display note if present

                // Create HTML for the history item
                historyHtml += `
                    <div class="debt-history-item">
                        <span>${entryDisplay} - ${entryTypeLabel}${noteDisplay}</span>
                        <span class="${amountClass}">${formatNumber(entry.amount)}</span>
                        <div class="debt-history-actions">
                            <button class="action-button-text edit" onclick="editDebtHistoryEntry('${entry.id}')"><i class="fas fa-edit"></i></button>
                            <button class="action-button-text delete" onclick="deleteDebtHistoryEntry('${entry.id}')"><i class="fas fa-trash-alt"></i></button>
                        </div>
                    </div>
                `;
            });
            historyHtml += '</div>'; // Close the history list div
            return historyHtml;
        }

        // Helper function to render the debt/credit lists, potentially filtered
        function renderDebtsFiltered(filteredDebts) {
            const payableList = document.querySelector('#payable-debts-list .transaction-list-items');
            const receivableList = document.querySelector('#receivable-debts-list .transaction-list-items');
            payableList.innerHTML = ''; // Clear lists
            receivableList.innerHTML = '';

            let totalPayable = 0;
            let totalReceivable = 0;

            // Aggregate debts by name and type for processing
            const aggregatedDebts = {};

            filteredDebts.forEach(debtGroup => {
                const { name, type, history, id } = debtGroup;
                if (!aggregatedDebts[name]) {
                    aggregatedDebts[name] = { payableHistory: [], receivableHistory: [] };
                }
                if (type === 'payable') {
                    aggregatedDebts[name].payableHistory.push(...history.map(h => ({...h, groupId: id})));
                } else {
                    aggregatedDebts[name].receivableHistory.push(...history.map(h => ({...h, groupId: id})));
                }
            });

            const sortedNames = Object.keys(aggregatedDebts).sort(); // Sort names alphabetically

            sortedNames.forEach(name => {
                const debtAggregation = aggregatedDebts[name];

                // Process Payable Debts
                if (debtAggregation.payableHistory.length > 0) {
                    let currentPayableTotal = 0;
                    debtAggregation.payableHistory.sort((a, b) => new Date(a.date) - new Date(b.date)); // Sort by date
                    debtAggregation.payableHistory.forEach(entry => {
                        if (entry.type === 'initial_payable' || entry.type === 'payment_out') {
                            currentPayableTotal += entry.amount;
                        } else if (entry.type === 'initial_receivable' || entry.type === 'payment_in') {
                            currentPayableTotal -= entry.amount;
                        }
                    });
                    currentPayableTotal = Math.max(0, currentPayableTotal); // Ensure non-negative

                    if (currentPayableTotal > 0) {
                        totalPayable += currentPayableTotal;
                        const payableDiv = createDebtListItem(name, 'payable', currentPayableTotal, debtAggregation.payableHistory);
                        payableList.appendChild(payableDiv);
                    }
                }

                // Process Receivable Credits
                if (debtAggregation.receivableHistory.length > 0) {
                    let currentReceivableTotal = 0;
                    debtAggregation.receivableHistory.sort((a, b) => new Date(a.date) - new Date(b.date)); // Sort by date
                    debtAggregation.receivableHistory.forEach(entry => {
                        if (entry.type === 'initial_receivable' || entry.type === 'payment_in') {
                            currentReceivableTotal += entry.amount;
                        } else if (entry.type === 'initial_payable' || entry.type === 'payment_out') {
                            currentReceivableTotal -= entry.amount;
                        }
                    });
                    currentReceivableTotal = Math.max(0, currentReceivableTotal); // Ensure non-negative

                    if (currentReceivableTotal > 0) {
                        totalReceivable += currentReceivableTotal;
                        const receivableDiv = createDebtListItem(name, 'receivable', currentReceivableTotal, debtAggregation.receivableHistory);
                        receivableList.appendChild(receivableDiv);
                    }
                }
            });

            // Update total amounts displayed
            document.getElementById('total-payable-amount').textContent = formatNumber(totalPayable);
            document.getElementById('total-receivable-amount').textContent = formatNumber(totalReceivable);

            // Display "No data" messages if lists are empty
            if (payableList.children.length === 0) {
                payableList.innerHTML = '<p class="no-data">No payable debts found.</p>';
            }
            if (receivableList.children.length === 0) {
                receivableList.innerHTML = '<p class="no-data">No receivable credits found.</p>';
            }
        }

        // --- EXPENSE TAB FUNCTIONS ---

        // Adds a new category option to the expense category select dropdown
        function addExpenseCategoryToSelect(category) {
            const categorySelect = document.getElementById('expense-category');
            const optionExists = Array.from(categorySelect.options).some(option => option.value.toLowerCase() === category.toLowerCase()); // Case-insensitive check
            if (!optionExists && category && category.trim() !== '' && category.trim().toLowerCase() !== 'other') {
                const newOption = document.createElement('option');
                newOption.value = category.trim();
                newOption.textContent = category.trim();

                const otherOption = categorySelect.querySelector('option[value="other"]'); // Find 'Other' option
                if (otherOption) {
                    categorySelect.insertBefore(newOption, otherOption); // Insert before 'Other'
                } else {
                    categorySelect.appendChild(newOption); // Append if 'Other' is not present (shouldn't happen)
                }
            }
        }

        // Populates the expense category select dropdown with saved custom categories
        function populateExpenseCategories() {
            const categorySelect = document.getElementById('expense-category');
            // Remove existing custom options (keep 'Other')
            while (categorySelect.options.length > 1) {
                // If the second option is not 'Other', remove it. Break if it is 'Other'.
                if (categorySelect.options[1].value !== 'other') {
                    categorySelect.remove(1);
                } else {
                    break;
                }
            }

            // Add saved custom categories from localStorage
            if (typeof savedExpenseCategories === 'object' && savedExpenseCategories !== null) {
                for (const category in savedExpenseCategories) {
                    if (Object.hasOwnProperty.call(savedExpenseCategories, category) && category.trim() !== '' && category.trim().toLowerCase() !== 'other') {
                        addExpenseCategoryToSelect(category);
                    }
                }
            }

            // Ensure 'Other' is always the last option
            const otherOption = categorySelect.querySelector('option[value="other"]');
            if (otherOption && otherOption.index !== categorySelect.options.length - 1) { // If 'Other' is not the last item
                const otherOptionValue = otherOption.value;
                categorySelect.remove(otherOption.index); // Remove it from its current position
                const newOtherOption = document.createElement('option'); // Create a new 'Other' option
                newOtherOption.value = otherOptionValue;
                newOtherOption.textContent = 'Other (Manual)';
                categorySelect.appendChild(newOtherOption); // Append it to the end
            } else if (!otherOption) { // If 'Other' option doesn't exist at all
                 const newOtherOption = document.createElement('option'); // Create and append it
                 newOtherOption.value = 'other';
                 newOtherOption.textContent = 'Other (Manual)';
                 categorySelect.appendChild(newOtherOption);
            }

            updateExpenseCategoryVisibility(); // Update visibility of the 'Other' input field
        }

        // Adds a new expense or income entry
        function addExpenseEntry() {
            const date = document.getElementById('expense-date').value;
            const type = document.getElementById('expense-type').value; // Expense or Income
            const categorySelect = document.getElementById('expense-category');
            const categoryOtherInput = document.getElementById('expense-category-other');
            const amount = parseFloat(document.getElementById('expense-amount').value.replace(/,/g, ''));
            const paymentMethod = document.getElementById('expense-payment-method').value;
            const paymentMethodOtherInput = document.getElementById('expense-payment-method-other');
            const note = document.getElementById('expense-note').value.trim();

            let actualCategory = categorySelect.value; // The category to be stored
            let actualPaymentMethod = paymentMethod; // The payment method to be stored

            // Handle 'Other' category input
            if (actualCategory === 'other') {
                actualCategory = categoryOtherInput.value.trim();
                if (!actualCategory) {
                    showToast('Please specify the other category.', 'error');
                    return;
                }
                // Save the new category if it doesn't exist
                if (!savedExpenseCategories[actualCategory]) {
                    savedExpenseCategories[actualCategory] = actualCategory;
                    try {
                        localStorage.setItem('moneyManager_savedExpenseCategories', JSON.stringify(savedExpenseCategories));
                    } catch (e) {
                        console.error("Error saving custom expense category:", e);
                    }
                    addExpenseCategoryToSelect(actualCategory); // Add to dropdown
                }
            } else if (!actualCategory) { // Ensure a category is selected or entered
                showToast('Category is required.', 'error');
                return;
            }

            // Handle 'Other' payment method input
            if (actualPaymentMethod === 'Other') {
                actualPaymentMethod = paymentMethodOtherInput.value.trim();
                if (!actualPaymentMethod) {
                    showToast('Please specify the other payment method.', 'error');
                    return;
                }
            }

            // Validation
            if (!date) { showToast('Date/Time is required.', 'error'); return; }
            if (isNaN(amount) || amount <= 0) { showToast('Amount must be a positive number.', 'error'); return; }

            // Create the new expense entry object
            const newEntry = {
                id: Date.now().toString(), // Unique ID for the entry
                date,
                type,
                category: actualCategory,
                amount,
                paymentMethod: actualPaymentMethod,
                note
            };

            expenseEntries.unshift(newEntry); // Add to the beginning of the array

            // Save to localStorage
            try {
                localStorage.setItem('moneyManager_expenseEntries', JSON.stringify(expenseEntries));
                showToast('Expense/Income entry added successfully!');
            } catch (e) {
                console.error("Error saving expense entries:", e);
                showToast('Error saving entry', 'error');
            }

            updateSummariesBasedOnCurrentView(); // Update summaries on screen
            renderExpenseEntries(); // Refresh the displayed list
            clearExpenseForm(); // Clear the form
        }

        // Loads an expense entry into the form for editing
        function editExpenseEntry(index) {
            if (index < 0 || index >= expenseEntries.length) {
                showToast("Error loading entry for editing.", "error");
                return;
            }
            const entry = expenseEntries[index];

            // Populate form fields
            document.getElementById('expense-date').value = entry.date;
            document.getElementById('expense-type').value = entry.type;

            const categorySelect = document.getElementById('expense-category');
            const categoryOtherInput = document.getElementById('expense-category-other');

            let foundInSelect = false;
            // Check if the category exists in the select dropdown
            for (let i = 0; i < categorySelect.options.length; i++) {
                if (categorySelect.options[i].value === entry.category) {
                    categorySelect.value = entry.category;
                    categoryOtherInput.style.display = 'none'; // Hide 'Other' input
                    categoryOtherInput.value = '';
                    foundInSelect = true;
                    break;
                }
            }

            // If category not found in select (and it's not 'other'), treat it as custom
            if (!foundInSelect && entry.category !== 'other') {
                categorySelect.value = 'other';
                categoryOtherInput.value = entry.category;
                categoryOtherInput.style.display = 'block';
                // Save this new custom category if not already saved
                if (!savedExpenseCategories[entry.category]) {
                    savedExpenseCategories[entry.category] = entry.category;
                    try {
                        localStorage.setItem('moneyManager_savedExpenseCategories', JSON.stringify(savedExpenseCategories));
                    } catch (e) {
                        console.error("Error saving custom expense category during edit:", e);
                    }
                    addExpenseCategoryToSelect(entry.category);
                }
            } else if (entry.category === 'other') { // If the stored category was 'other'
                categorySelect.value = 'other';
                categoryOtherInput.value = entry.category;
                categoryOtherInput.style.display = 'block';
            }

            document.getElementById('expense-amount').value = formatNumber(entry.amount);
            document.getElementById('expense-payment-method').value = entry.paymentMethod;

            // Handle visibility of 'Other' payment method input
            const paymentMethodOtherInput = document.getElementById('expense-payment-method-other');
            if (entry.paymentMethod === 'Other') {
                 paymentMethodOtherInput.value = entry.paymentMethod; // Populate if it was 'Other'
                 paymentMethodOtherInput.style.display = 'block';
            } else {
                 paymentMethodOtherInput.style.display = 'none'; // Hide otherwise
            }
            document.getElementById('expense-note').value = entry.note || '';

            // Update visibility states of related fields
            updateExpenseCategoryVisibility();
            updatePaymentMethodVisibility();

            // Remove the entry from the list temporarily while editing
            expenseEntries.splice(index, 1);
            updateSummariesBasedOnCurrentView();
            renderExpenseEntries();
            showToast('Entry loaded for editing.');
            window.scrollTo(0, 0); // Scroll to the form
        }

        // Deletes an expense entry at the specified index after confirmation
        function deleteExpenseEntry(index) {
            if (index < 0 || index >= expenseEntries.length) {
                showToast("Error deleting entry.", "error");
                return;
            }

            if (confirm('Are you sure you want to delete this entry?')) {
                expenseEntries.splice(index, 1); // Remove the entry
                try {
                    localStorage.setItem('moneyManager_expenseEntries', JSON.stringify(expenseEntries)); // Save changes
                    showToast('Entry deleted successfully');
                } catch (e) {
                    showToast('Error saving changes after deletion', 'error');
                }
                updateSummariesBasedOnCurrentView(); // Update summaries
                renderExpenseEntries(); // Refresh list display
            }
        }

        // Filters the expense entries based on selected criteria (type, category, date)
        function filterExpenses() {
            const typeFilter = document.getElementById('expense-filter-type').value;
            const categoryFilter = document.getElementById('expense-filter-category').value.toLowerCase();
            const dateFilterValue = document.getElementById('expense-filter-date').value;

            let filtered = expenseEntries; // Start with all entries

            // Apply type filter
            if (typeFilter !== 'all') {
                filtered = filtered.filter(e => e.type === typeFilter);
            }

            // Apply category filter (checks if category includes the filter text)
            if (categoryFilter) {
                filtered = filtered.filter(e => e.category.toLowerCase().includes(categoryFilter));
            }

            // Apply date filter
            if (dateFilterValue) {
                try {
                    const filterDate = new Date(dateFilterValue);
                    filterDate.setHours(0, 0, 0, 0);
                    filtered = filtered.filter(e => {
                        const entryDate = new Date(e.date);
                        if (isNaN(entryDate.getTime())) return false; // Skip invalid dates
                        // Compare date parts
                        return entryDate.getFullYear() === filterDate.getFullYear() &&
                               entryDate.getMonth() === filterDate.getMonth() &&
                               entryDate.getDate() === filterDate.getDate();
                    });
                } catch (e) {
                    console.error("Error applying date filter for expenses:", e);
                    showToast("Error applying date filter.", "error");
                    filtered = []; // Clear filtered list on error
                }
            }

            renderExpenseEntries(filtered); // Render the filtered list
            updateSummariesBasedOnCurrentView(); // Update summaries
        }

        // Resets all expense filters to default and shows all entries
        function resetExpenseFilters() {
            document.getElementById('expense-filter-type').value = 'all';
            document.getElementById('expense-filter-category').value = '';
            document.getElementById('expense-filter-date').value = '';
            renderExpenseEntries(); // Show all entries
            updateSummariesBasedOnCurrentView(); // Update summaries
        }

        // Updates the daily summary section for the expense tab (Income, Expense, Net)
        function updateExpenseSummaries() {
            const dailyIncomeSpan = document.getElementById('daily-total-income');
            const dailyExpenseSpan = document.getElementById('daily-total-expenses');
            const dailyNetSpan = document.getElementById('daily-net-balance');

            let totalIncomeToday = 0;
            let totalExpenseToday = 0;

            // Define today's date range
            const today = new Date();
            const startOfDay = new Date(today);
            startOfDay.setHours(0, 0, 0, 0);
            const endOfDay = new Date(today);
            endOfDay.setHours(23, 59, 59, 999);

            // Iterate through expense entries and sum up today's income and expenses
            expenseEntries.forEach(entry => {
                const entryDate = new Date(entry.date);
                if (entryDate >= startOfDay && entryDate <= endOfDay) {
                    const amount = parseFloat(entry.amount);
                    if (entry.type === 'Income') {
                        totalIncomeToday += amount;
                    } else {
                        totalExpenseToday += amount;
                    }
                }
            });

            // Update the UI with calculated values
            dailyIncomeSpan.textContent = formatNumber(totalIncomeToday);
            dailyExpenseSpan.textContent = formatNumber(totalExpenseToday);
            dailyNetSpan.textContent = formatNumber(totalIncomeToday - totalExpenseToday);

            // Auto-expand the summary section if it contains data
            const summarySection = document.getElementById('expense').querySelector('.summary-section');
            if (summarySection) {
                const hasData = (totalIncomeToday !== 0 || totalExpenseToday !== 0);
                // Expand if data exists and section is collapsed, or collapse if no data and section is expanded
                if (hasData && !summarySection.classList.contains('expanded')) {
                    toggleExpand(summarySection);
                } else if (!hasData && summarySection.classList.contains('expanded')) {
                    toggleExpand(summarySection);
                }
            }
        }

        // Updates the periodical summary section for the expense tab based on selected period (week, month, year)
        function updatePeriodicalExpenseSummaries() {
            const periodType = document.getElementById('period-type').value; // Get selected period type
            const today = new Date();
            let startDate, endDate;

            // Calculate start and end dates based on period type
            switch (periodType) {
                case 'week':
                    startDate = new Date(today);
                    startDate.setDate(today.getDate() - today.getDay()); // Start of week (Sunday)
                    startDate.setHours(0, 0, 0, 0);
                    endDate = new Date(today); // End of week (today)
                    endDate.setHours(23, 59, 59, 999);
                    break;
                case 'month':
                    startDate = new Date(today.getFullYear(), today.getMonth(), 1); // First day of the month
                    startDate.setHours(0, 0, 0, 0);
                    endDate = new Date(today.getFullYear(), today.getMonth() + 1, 0); // Last day of the month
                    endDate.setHours(23, 59, 59, 999);
                    break;
                case 'year':
                    startDate = new Date(today.getFullYear(), 0, 1); // First day of the year
                    startDate.setHours(0, 0, 0, 0);
                    endDate = new Date(today.getFullYear(), 11, 31); // Last day of the year
                    endDate.setHours(23, 59, 59, 999);
                    break;
                default: // Default to today if period type is unknown
                    startDate = new Date(today);
                    startDate.setHours(0, 0, 0, 0);
                    endDate = new Date(today);
                    endDate.setHours(23, 59, 59, 999);
                    break;
            }

            let periodIncome = 0;
            let periodExpense = 0;

            // Iterate through expense entries and sum up income/expenses within the period
            expenseEntries.forEach(entry => {
                const entryDate = new Date(entry.date);
                if (entryDate >= startDate && entryDate <= endDate) {
                    const amount = parseFloat(entry.amount);
                    if (entry.type === 'Income') {
                        periodIncome += amount;
                    } else {
                        periodExpense += amount;
                    }
                }
            });

            // Update the UI with periodical summary values
            document.getElementById('periodical-total-income').textContent = formatNumber(periodIncome);
            document.getElementById('periodical-total-expenses').textContent = formatNumber(periodExpense);
            document.getElementById('periodical-net-balance').textContent = formatNumber(periodIncome - periodExpense);
        }

        // Toggles the expanded/collapsed state of the expense list
        function toggleExpenseList() {
            const listContainer = document.getElementById('expense-list');
            listContainer.classList.toggle('expanded'); // Toggle the 'expanded' class
            // If expanded and list is empty or shows 'no data', re-render it
            if (listContainer.classList.contains('expanded') && (listContainer.querySelector('.grouped-transaction') === null || listContainer.querySelector('.no-data'))) {
                if (expenseEntries.length > 0) {
                    renderExpenseEntries(); // Render if there are entries
                }
            }
        }

        // --- HELPER FUNCTIONS FOR EXPENSE TAB UI ---

        // Updates the visibility of the 'Other (Manual)' category input field based on the select value
        function updateExpenseCategoryVisibility() {
            const categorySelect = document.getElementById('expense-category');
            const categoryOtherInput = document.getElementById('expense-category-other');

            if (categorySelect.value === 'other') {
                categoryOtherInput.style.display = 'block'; // Show input
                categoryOtherInput.focus();
            } else {
                categoryOtherInput.style.display = 'none'; // Hide input
                categoryOtherInput.value = ''; // Clear input value
            }
        }

        // Updates the visibility of the 'Other' payment method input field based on the select value
        function updatePaymentMethodVisibility() {
            const paymentMethodSelect = document.getElementById('expense-payment-method');
            const paymentMethodOtherInput = document.getElementById('expense-payment-method-other');

            if (paymentMethodSelect.value === 'Other') {
                paymentMethodOtherInput.style.display = 'block'; // Show input
                paymentMethodOtherInput.focus();
            } else {
                paymentMethodOtherInput.style.display = 'none'; // Hide input
                paymentMethodOtherInput.value = ''; // Clear input value
            }
        }

        // Clears and resets the expense form fields to their default states
        function clearExpenseForm() {
            document.getElementById('expense-date').value = ''; // Clear date
            updateDateTimeFields(); // Reset to current date/time

            document.getElementById('expense-type').value = 'Expense'; // Reset type

            document.getElementById('expense-category').value = 'other'; // Reset category to 'other'
            document.getElementById('expense-category-other').value = ''; // Clear custom category input
            updateExpenseCategoryVisibility(); // Update visibility of 'Other' input

            document.getElementById('expense-amount').value = ''; // Clear amount
            document.getElementById('expense-payment-method').value = 'E-Money'; // Reset payment method
            document.getElementById('expense-payment-method-other').value = ''; // Clear custom payment method input
            updatePaymentMethodVisibility(); // Update visibility of 'Other' payment method input
        }

        // Renders the expense entries list, optionally filtered
        function renderExpenseEntries(filteredEntries = null) {
            const listContainer = document.getElementById('expense-list').querySelector('.transaction-list-items');
            listContainer.innerHTML = ''; // Clear the list

            const entriesToShow = filteredEntries !== null ? filteredEntries : expenseEntries; // Use filtered list if provided

            if (entriesToShow.length === 0) {
                listContainer.innerHTML += '<p class="no-data">No expense/income entries found.</p>'; // Display message if no data
                return;
            }

            // Group entries by date for better readability
            const groupedEntries = {};
            entriesToShow.forEach((entry, index) => {
                const dateKey = new Date(entry.date).toISOString().split('T')[0]; // Date for grouping
                if (!groupedEntries[dateKey]) {
                    groupedEntries[dateKey] = {
                        items: [], // Store entries for this date
                        totalAmount: 0, // Sum of amounts for the day
                        type: entry.type // Type of the entries (Income/Expense)
                    };
                }
                // Find original index for edit/delete operations
                const originalIndex = expenseEntries.findIndex(e => e.id === entry.id && e.date === entry.date);
                groupedEntries[dateKey].items.push({ ...entry, originalIndex: originalIndex }); // Add entry with original index
                groupedEntries[dateKey].totalAmount += parseFloat(entry.amount); // Add amount to daily total
            });

            // Sort dates descending
            const sortedDates = Object.keys(groupedEntries).sort().reverse();

            // Render each day's group
            for (const dateKey of sortedDates) {
                const groupData = groupedEntries[dateKey];
                const displayDate = new Date(dateKey).toDateString();

                const groupElement = document.createElement('div');
                groupElement.className = 'grouped-transaction';

                // Create HTML structure for the group
                groupElement.innerHTML = `
                    <div class="group-header" onclick="toggleGroup(this.parentElement)">
                        <span>${displayDate}</span>
                        <span>${groupData.type}: ${formatNumber(groupData.totalAmount)}</span>
                    </div>
                    <div class="group-details">
                        ${groupData.items.map(item => {
                            const amountClass = item.type === 'Income' ? 'positive' : 'negative'; // Style amount based on type
                            // Generate details HTML (payment method, note)
                            let detailsHtml = '';
                            detailsHtml += `<span class="transaction-info-item"><strong>Method:</strong> ${item.paymentMethod}</span>`;
                            if (item.note) {
                                const truncatedNote = item.note.length > 50 ? item.note.substring(0, 50) + '...' : item.note; // Truncate long notes
                                detailsHtml += `<span class="transaction-info-item"><strong>Note:</strong> ${truncatedNote}</span>`;
                            }
                            return `
                                <div class="transaction-item">
                                    <div class="transaction-header">
                                        <span class="transaction-type">${item.category}</span>
                                        <span class="transaction-amount ${amountClass}">${formatNumber(item.amount)}</span>
                                    </div>
                                    <div class="transaction-details-mobile">
                                        <span class="transaction-date">${new Date(item.date).toLocaleTimeString()}</span>
                                        ${detailsHtml}
                                    </div>
                                    <div class="transaction-actions">
                                        <button class="action-button-text edit" onclick="editExpenseEntry(${item.originalIndex})">Edit</button>
                                        <button class="action-button-text delete" onclick="deleteExpenseEntry(${item.originalIndex})">Delete</button>
                                    </div>
                                </div>
                            `;
                        }).join('')}
                    </div>
                `;
                listContainer.appendChild(groupElement); // Add the group to the list
            }
        }

        // Toggles the expanded/collapsed state of the expense list
        function toggleExpenseList() {
            const listContainer = document.getElementById('expense-list');
            listContainer.classList.toggle('expanded'); // Toggle the 'expanded' class
            // If expanded and list is empty or shows 'no data', re-render it
            if (listContainer.classList.contains('expanded') && (listContainer.querySelector('.grouped-transaction') === null || listContainer.querySelector('.no-data'))) {
                if (expenseEntries.length > 0) {
                    renderExpenseEntries(); // Render the list if there are entries
                }
            }
        }

        // --- SAVE DATA ON PAGE UNLOAD ---
        // Ensure data is saved when the user navigates away or closes the tab
        window.addEventListener('beforeunload', saveData);

    </script>
</body>
</html>
