<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>My Money Manager</title>

    <!-- PWA Manifest Link -->
    <link rel="manifest" href="manifest.json">

    <!-- Theme Color for Mobile Browsers -->
    <meta name="theme-color" content="#007bff">

    <!-- Add Apple Touch Icon for iOS Homescreen Icons -->
    <link rel="apple-touch-icon" href="assets/icon-512x512.png">

    <style>
        /* --- Color Palette and Typography --- */
        :root {
            --primary: #007bff; /* Bootstrap primary blue */
            --primary-dark: #0056b3; /* Darker shade of primary */
            --secondary: #6c757d; /* Bootstrap secondary gray */
            --danger: #dc3545; /* Bootstrap danger red */
            --light-gray: #f8f9fa; /* Very light gray for backgrounds */
            --medium-gray: #e9ecef; /* Light gray for borders and dividers */
            --dark-gray: #495057; /* Dark gray for secondary text */
            --text: #212529; /* Bootstrap primary text color */
            --text-light: #6c757d; /* Lighter text color */
            --positive: #28a745; /* Bootstrap success green */
            --negative: #dc3545; /* Bootstrap danger red */
            --card-background: #ffffff; /* White background for cards and content blocks */
            --input-border-color: #ced4da; /* Standard input border color */
            --input-focus-border-color: var(--primary); /* Primary color on input focus */
            --button-hover-bg: var(--primary-dark); /* Darker primary on button hover */
            --transition-fast: 0.2s ease-in-out; /* Fast transition for smooth effects */
            --modal-background: rgba(0, 0, 0, 0.8); /* Semi-transparent dark background for modals */
            --border-radius-default: 6px; /* Standard border radius */
            --border-radius-large: 10px; /* Larger border radius for main containers */
            --shadow-sm: 0 1px 3px rgba(0,0,0,0.1); /* Small shadow for subtle depth */
            --shadow-md: 0 2px 5px rgba(0,0,0,0.15); /* Medium shadow for cards and headers */
        }

        /* --- Global Reset and Base Styles --- */
        * {
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent; /* Removes tap highlight on mobile */
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            margin: 0;
            padding: 0;
        }

        body {
            background-color: var(--light-gray); /* Light background for the entire page */
            color: var(--text); /* Default text color */
            line-height: 1.5; /* Comfortable line spacing */
            overflow-x: hidden; /* Prevent horizontal scrolling */
            font-size: 14px; /* Base font size, can be adjusted */
        }

        /* --- Lock Screen Styles --- */
        #lock-screen-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--modal-background); /* Dimmed background */
            color: white; /* Text color for lock screen */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10000; /* Ensure it's on top of everything */
            opacity: 0; /* Initially hidden */
            visibility: hidden; /* Initially not interactive */
            transition: opacity var(--transition-fast); /* Smooth fade effect */
            backdrop-filter: blur(5px); /* Apply blur effect to the background behind the overlay */
            -webkit-backdrop-filter: blur(5px); /* For Safari compatibility */
        }

        #lock-screen-overlay.visible {
            opacity: 1; /* Make visible */
            visibility: visible; /* Make interactive */
        }

        #lock-screen-content {
            text-align: center;
            background-color: rgba(255, 255, 255, 0.1); /* Slightly translucent white background */
            padding: 20px;
            border-radius: var(--border-radius-large); /* Rounded corners */
            width: 90%;
            max-width: 350px; /* Max width for content */
            box-shadow: 0 0 15px rgba(0,0,0,0.3); /* Shadow for depth */
        }

        #lock-screen-title {
            font-size: 1.8rem; /* Large font size for title */
            margin-bottom: 15px;
            font-weight: 600; /* Bold */
            color: white; /* White text */
        }

        #lock-screen-message {
            font-size: 1rem; /* Standard font size for message */
            margin-bottom: 20px;
            color: rgba(255, 255, 255, 0.9); /* Slightly transparent white */
        }

        #lock-screen-pin-input {
            font-size: 1.8rem; /* Large font for PIN display */
            letter-spacing: 10px; /* Space between PIN digits */
            padding: 12px 15px;
            border: 2px solid var(--primary); /* Primary colored border */
            border-radius: var(--border-radius-default);
            background-color: transparent; /* Transparent background */
            color: white; /* White text */
            width: 100%;
            max-width: 200px; /* Fixed width for PIN input */
            text-align: center;
            margin-bottom: 15px;
            caret-color: transparent; /* Hide caret */
        }

        #lock-screen-keyboard {
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #lock-screen-keyboard .key-row {
            display: flex;
            justify-content: center; /* Center keys horizontally */
            margin-bottom: 10px;
        }

        #lock-screen-keyboard button {
            width: 60px;
            height: 60px;
            font-size: 1.5rem; /* Large font for key numbers */
            background-color: rgba(255, 255, 255, 0.1); /* Translucent white keys */
            color: white;
            border: none;
            border-radius: 50%; /* Circular buttons */
            margin: 0 5px; /* Spacing between keys */
            display: flex;
            align-items: center;
            justify-content: center; /* Center content within button */
            cursor: pointer;
        }

        #lock-screen-keyboard button:active {
            background-color: rgba(255, 255, 255, 0.2); /* Slightly darker on press */
        }

        #lock-screen-keyboard .key-delete {
            background-color: var(--danger); /* Red background for delete key */
        }

        #lock-screen-keyboard .key-delete:active {
            background-color: #c82333; /* Darker red on press */
        }

        #lock-screen-error-message {
            color: #ffc107; /* Warning yellow for errors */
            min-height: 20px; /* Reserve space for error message */
            margin: 10px 0;
            font-size: 0.9rem;
        }

        #lock-screen-footer {
            margin-top: 20px; /* Space above footer */
            font-size: 0.8rem; /* Smaller font size for footer */
            color: rgba(255, 255, 255, 0.7); /* Slightly transparent white */
        }

        /* --- Main Layout and Navigation --- */
        .container {
            width: 100%;
            margin: 0 auto; /* Center the container */
            padding: 10px; /* Padding around the content */
            background-color: var(--card-background); /* White background */
        }

        .header {
            text-align: center;
            margin-bottom: 15px;
            background: linear-gradient(135deg, #007bff 0%, #0056b3 100%); /* Gradient header background */
            color: white; /* White text for header */
            padding: 20px 15px;
            border-radius: var(--border-radius-large); /* Rounded corners */
            box-shadow: var(--shadow-md); /* Medium shadow */
        }

        .header h1 {
            font-weight: 600; /* Semi-bold */
            margin-bottom: 10px;
            font-size: 1.8rem; /* Large font for title */
        }

        .header p {
            font-size: 1rem; /* Standard font size for subtitle */
            opacity: 0.9; /* Slightly transparent */
        }

        /* --- Tabs --- */
        .tabs-container, .tabs-container-bottom {
            display: flex; /* Use flexbox for tab layout */
            justify-content: space-around; /* Distribute tabs evenly */
            gap: 8px; /* Spacing between tabs */
            margin-bottom: 15px; /* Space below tabs */
            padding: 0 5px; /* Add some horizontal padding */
        }

        .tabs-container-bottom {
            justify-content: center; /* Center bottom tabs */
        }

        .tab {
            flex: 1; /* Allow tabs to grow and fill space */
            padding: 15px 10px; /* Larger padding for tabs */
            cursor: pointer; /* Indicate clickable element */
            text-align: center; /* Center text */
            font-weight: 500; /* Medium font weight */
            color: var(--dark-gray); /* Dark gray text */
            background-color: var(--light-gray); /* Light gray background */
            border-radius: var(--border-radius-default); /* Rounded corners */
            box-shadow: var(--shadow-sm); /* Small shadow */
            transition: color var(--transition-fast), background-color var(--transition-fast), border-color var(--transition-fast); /* Smooth transitions */
            font-size: 0.9rem; /* Slightly larger font for tabs */
            white-space: nowrap; /* Prevent text wrapping */
            border-bottom: 3px solid transparent; /* Transparent border for active indicator */
        }

        .tab.active {
            color: var(--primary); /* Primary color for active tab text */
            background-color: var(--card-background); /* White background for active tab */
            border-bottom-color: var(--primary); /* Primary border color as indicator */
            box-shadow: var(--shadow-md); /* Slightly larger shadow for active tab */
        }

        .tab:hover {
            background-color: var(--medium-gray); /* Light gray hover effect */
            color: var(--primary); /* Primary color on hover */
        }

        .tab.active:hover {
            background-color: var(--card-background); /* Maintain white background for active tab on hover */
        }


        .tab-content {
            display: none; /* Hide content by default */
            padding: 15px;
            background-color: var(--card-background); /* White background */
            border-radius: var(--border-radius-default); /* Rounded corners */
        }

        .tab-content.active {
            display: block; /* Show active tab content */
        }

        /* --- Card Styles --- */
        .card-container {
            display: grid; /* Use grid for card layout */
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); /* Responsive columns */
            gap: 10px; /* Spacing between cards */
            margin-bottom: 15px; /* Space below card container */
        }

        .card {
            background: var(--card-background); /* White background */
            border-radius: var(--border-radius-default); /* Rounded corners */
            box-shadow: var(--shadow-sm); /* Small shadow */
            padding: 15px; /* Padding inside card */
            text-align: center; /* Center content */
            border: 1px solid var(--medium-gray); /* Light gray border */
        }

        .card h3 {
            font-size: 0.9rem; /* Small font size for card title */
            color: var(--dark-gray); /* Dark gray text */
            margin-bottom: 8px;
            font-weight: 500; /* Medium font weight */
        }

        .card-amount {
            font-size: 1.4rem; /* Larger font size for amounts */
            font-weight: 600; /* Semi-bold */
        }

        /* --- Form Section Styles --- */
        .form-section {
            background: var(--card-background); /* White background */
            padding: 15px;
            border-radius: var(--border-radius-default); /* Rounded corners */
            margin-bottom: 15px; /* Space below section */
            box-shadow: var(--shadow-sm); /* Small shadow */
            border: 1px solid var(--medium-gray); /* Light gray border */
        }

        .form-section h2, .form-section h3 {
            margin-bottom: 15px; /* Space below section titles */
            color: var(--primary); /* Primary color for titles */
            font-weight: 600; /* Semi-bold */
            font-size: 1.3rem; /* Larger font for section titles */
        }

        .form-group {
            margin-bottom: 15px; /* Space between form groups */
        }

        .form-group label {
            display: block; /* Label on its own line */
            margin-bottom: 8px;
            font-weight: 500; /* Medium font weight */
            color: var(--text); /* Default text color */
        }

        /* Input and select styling */
        input[type="text"],
        input[type="password"],
        input[type="datetime-local"],
        input[type="date"],
        select,
        textarea {
            width: 100%; /* Full width */
            padding: 12px; /* Padding inside inputs */
            border: 1px solid var(--input-border-color); /* Default border color */
            border-radius: var(--border-radius-default); /* Rounded corners */
            font-size: 1rem; /* Standard font size */
            transition: border-color var(--transition-fast); /* Smooth border transition on focus */
            color: var(--text); /* Input text color */
            background-color: var(--card-background); /* White background */
        }

        input:focus, select:focus, textarea:focus {
            outline: none; /* Remove default outline */
            border-color: var(--input-focus-border-color); /* Highlight with primary color */
        }

        select {
            appearance: none; /* Remove default browser styling */
            /* Add custom dropdown arrow */
            background-image: url('data:image/svg+xml;charset=UTF-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="%236c757d"><path d="M7.293 10.293a1 1 0 0 1 1.414 0L10.5 12.586l2.293-2.293a1 1 0 0 1 1.414 1.414l-3.5 3.5a1 1 0 0 1-1.414 0l-3.5-3.5a1 1 0 0 1 0-1.414z"/></svg>');
            background-repeat: no-repeat;
            background-position: right 12px top 50%; /* Position arrow */
            background-size: 16px; /* Size of the arrow */
            padding-right: 35px; /* Space for the arrow */
        }

        /* Handle 'Other' inputs for select fields */
        .form-group input[type="text"][style*="display: block;"] {
            margin-top: 10px; /* Add margin if it's displayed */
        }

        /* Button styling */
        button {
            background-color: var(--primary); /* Primary button color */
            color: white; /* White text */
            border: none; /* No border */
            padding: 12px 20px; /* Padding */
            border-radius: var(--border-radius-default); /* Rounded corners */
            cursor: pointer; /* Indicate clickable */
            font-size: 1rem; /* Standard font size */
            font-weight: 500; /* Medium weight */
            transition: background-color var(--transition-fast); /* Smooth hover effect */
            display: inline-flex; /* Align items nicely */
            align-items: center;
            justify-content: center;
            gap: 8px; /* Space between icon and text */
            width: 100%; /* Full width by default */
            margin-bottom: 10px; /* Space below button */
        }

        button:active {
            background-color: var(--button-hover-bg); /* Darker color on press */
        }

        button.secondary {
            background-color: white; /* White background */
            color: var(--primary); /* Primary text color */
            border: 1px solid var(--primary); /* Primary border */
        }

        button.secondary:active {
            background-color: var(--light-gray); /* Light gray on press */
        }

        button.danger {
            background-color: var(--danger); /* Danger color */
        }

        button.danger:active {
            background-color: #c82333; /* Darker danger red on press */
        }

        .button-group {
            display: flex;
            flex-direction: column; /* Stack buttons vertically by default */
            gap: 10px; /* Space between buttons */
            margin-top: 15px; /* Space above the group */
        }

        /* --- Transaction List Styles --- */
        .transaction-list {
            margin-top: 15px; /* Space above the list */
        }

        .transaction-list h2, .summary-section h2 {
            margin-bottom: 10px; /* Space below section titles */
            color: var(--primary); /* Primary color for titles */
            font-weight: 600; /* Semi-bold */
            cursor: pointer; /* Indicate clickable */
            display: flex; /* Use flexbox for alignment */
            justify-content: space-between; /* Space out title and arrow */
            align-items: center; /* Vertically align items */
            padding: 12px 15px; /* Padding */
            background-color: var(--card-background); /* White background */
            border-radius: var(--border-radius-default); /* Rounded corners */
            box-shadow: var(--shadow-sm); /* Small shadow */
            border: 1px solid var(--medium-gray); /* Light gray border */
            font-size: 1.1rem; /* Larger font size */
        }

        .transaction-list h2 .arrow, .summary-section h2 .arrow {
            transition: transform var(--transition-fast); /* Smooth rotation for arrow */
            font-size: 0.9rem; /* Smaller font size for arrow */
        }

        .transaction-list.expanded h2 .arrow, .summary-section.expanded h2 .arrow {
            transform: rotate(180deg); /* Rotate arrow when expanded */
        }

        .transaction-list-items, .summary-list {
            display: none; /* Hide content by default */
            margin-top: 10px; /* Space above content */
        }

        .transaction-list.expanded .transaction-list-items, .summary-section.expanded .summary-list {
            display: block; /* Show content when expanded */
        }

        .grouped-transaction {
            margin-bottom: 15px; /* Space between date groups */
            background-color: var(--card-background); /* White background */
            border-radius: var(--border-radius-default); /* Rounded corners */
            box-shadow: var(--shadow-sm); /* Small shadow */
            overflow: hidden; /* Hide overflow content */
            border: 1px solid var(--medium-gray); /* Light gray border */
        }

        .group-header {
            background-color: var(--light-gray); /* Light gray background */
            padding: 12px 15px; /* Padding */
            display: flex;
            justify-content: space-between; /* Space out date and summary */
            align-items: center;
            cursor: pointer; /* Indicate clickable */
            font-weight: 500; /* Medium font weight */
            border-left: 4px solid var(--primary); /* Primary accent on the left */
            font-size: 0.9rem; /* Small font size */
        }

        .group-header span:last-child {
            font-size: 0.8rem; /* Smaller font for summary text */
            color: var(--dark-gray); /* Dark gray color */
        }

        .transaction-item {
            background-color: var(--card-background); /* White background */
            padding: 12px 15px; /* Padding */
            margin: 0 0 10px 0; /* Margin below each item */
            border-radius: var(--border-radius-default); /* Rounded corners */
            position: relative; /* For positioning actions */
            border-left: 4px solid var(--primary); /* Primary accent */
            border: 1px solid var(--medium-gray); /* Light gray border */
        }

        .transaction-item:last-child {
            margin-bottom: 0; /* No bottom margin for the last item */
        }

        .transaction-header {
            display: flex;
            justify-content: space-between; /* Space out type and amount */
            margin-bottom: 8px;
            align-items: center;
        }

        .transaction-type {
            font-weight: 500; /* Medium font weight */
            color: var(--primary); /* Primary color */
            font-size: 0.9rem; /* Small font size */
        }

        .transaction-amount {
            font-weight: 600; /* Semi-bold */
            font-size: 1rem; /* Standard font size */
        }

        .transaction-amount.positive { color: var(--positive); } /* Green for positive */
        .transaction-amount.negative { color: var(--negative); } /* Red for negative */

        .transaction-details-mobile {
            font-size: 0.8rem; /* Small font size */
            color: var(--dark-gray); /* Dark gray text */
            display: flex;
            flex-direction: column; /* Stack details vertically */
            gap: 4px; /* Spacing between detail lines */
        }

        .transaction-info-line {
            display: flex;
            gap: 10px; /* Spacing between info items */
            flex-wrap: wrap; /* Allow wrapping on small screens */
        }

        .transaction-info-line span {
            white-space: nowrap; /* Prevent wrapping within a detail */
        }

        .transaction-info-item {
            display: inline; /* Display as inline elements */
        }

        .transaction-actions {
            display: flex; /* Arrange buttons horizontally */
            justify-content: flex-end; /* Align to the right */
            gap: 8px; /* Spacing between buttons */
            margin-top: 10px; /* Space above buttons */
        }

        .action-button-text {
            padding: 6px 10px; /* Padding for buttons */
            border-radius: var(--border-radius-default); /* Rounded corners */
            font-weight: 500; /* Medium weight */
            font-size: 0.8rem; /* Small font size */
            display: inline-flex; /* Align icon and text */
            align-items: center;
            gap: 5px; /* Space between icon and text */
            text-decoration: none; /* Remove underline for text buttons */
            border: none; /* Remove default button border */
            cursor: pointer; /* Indicate clickable */
        }

        .action-button-text.edit {
            background-color: var(--primary); /* Primary color */
            color: white; /* White text */
        }

        .action-button-text.delete {
            background-color: var(--danger); /* Danger color */
            color: white; /* White text */
        }

        /* --- Summary Section --- */
        .summary-section {
            background: var(--card-background); /* White background */
            padding: 15px;
            border-radius: var(--border-radius-default); /* Rounded corners */
            margin-top: 15px; /* Space above section */
            box-shadow: var(--shadow-sm); /* Small shadow */
            border: 1px solid var(--medium-gray); /* Light gray border */
        }

        .summary-list {
            display: none; /* Hide content by default */
            margin-top: 10px; /* Space above list */
        }

        .summary-section.expanded .summary-list {
            display: block; /* Show content when expanded */
        }

        .summary-item {
            display: flex; /* Use flexbox for alignment */
            justify-content: space-between; /* Space out label and value */
            padding: 10px 0; /* Padding */
            border-bottom: 1px solid var(--medium-gray); /* Light gray divider */
            font-size: 0.9rem; /* Small font size */
        }

        .summary-item:last-child {
            border-bottom: none; /* No border for the last item */
        }

        .summary-label {
            font-weight: 500; /* Medium font weight */
            color: var(--dark-gray); /* Dark gray text */
        }

        /* --- Filter Section --- */
        .filter-section {
            display: flex; /* Use flexbox for filter controls */
            flex-direction: column; /* Stack controls vertically by default */
            gap: 10px; /* Spacing between controls */
            margin-bottom: 15px; /* Space below filter section */
            padding: 15px;
            background-color: var(--card-background); /* White background */
            border-radius: var(--border-radius-default); /* Rounded corners */
            box-shadow: var(--shadow-sm); /* Small shadow */
            border: 1px solid var(--medium-gray); /* Light gray border */
        }

        .filter-section button {
            margin-bottom: 0; /* Remove default bottom margin from buttons in filter */
        }

        /* --- Input Field Enhancements --- */
        .phone-input {
            position: relative;
        }

        .phone-input input {
            padding-left: 12px; /* Default padding */
        }

        /* --- Backup Section --- */
        .backup-section {
            background: var(--card-background); /* White background */
            padding: 15px;
            border-radius: var(--border-radius-default); /* Rounded corners */
            margin-top: 15px; /* Space above section */
            box-shadow: var(--shadow-sm); /* Small shadow */
            border: 1px solid var(--medium-gray); /* Light gray border */
        }

        .backup-textarea {
            width: 100%;
            min-height: 120px; /* Minimum height */
            padding: 12px;
            border: 1px solid var(--input-border-color); /* Default border */
            border-radius: var(--border-radius-default); /* Rounded corners */
            font-family: monospace; /* Monospaced font for code-like text */
            margin-bottom: 15px; /* Space below textarea */
            resize: vertical; /* Allow vertical resizing */
            font-size: 0.8rem; /* Small font size */
        }

        /* --- Toast Notification --- */
        .toast {
            position: fixed; /* Fixed position */
            bottom: 20px; /* Position at the bottom */
            left: 50%; /* Center horizontally */
            transform: translateX(-50%) translateY(50px); /* Start off-screen below */
            background-color: var(--primary); /* Default primary color */
            color: white; /* White text */
            padding: 12px 20px; /* Padding */
            border-radius: var(--border-radius-default); /* Rounded corners */
            box-shadow: var(--shadow-md); /* Medium shadow */
            opacity: 0; /* Initially invisible */
            transition: opacity var(--transition-fast), transform var(--transition-fast); /* Smooth fade and slide effect */
            z-index: 1000; /* High z-index to be on top */
            font-size: 0.9rem; /* Small font size */
            font-weight: 500; /* Medium weight */
            display: flex; /* Align icon and text */
            align-items: center;
            gap: 8px; /* Space between icon and text */
            pointer-events: none; /* Not interactive */
            max-width: 90%; /* Limit width */
            text-align: center; /* Center text */
        }

        .toast.show {
            opacity: 1; /* Make visible */
            transform: translateX(-50%) translateY(0); /* Slide into view */
        }

        .toast.error {
            background-color: var(--danger); /* Red background for errors */
        }
        .toast.warning {
            background-color: #ffc107; /* Yellow for warnings */
            color: var(--text); /* Dark text for warnings */
        }

        /* --- Export Buttons --- */
        .export-buttons-container {
            margin-top: 15px; /* Space above container */
            display: flex;
            flex-direction: column; /* Stack buttons vertically */
            gap: 10px; /* Spacing between buttons */
        }

        .export-button {
            background-color: var(--secondary); /* Use secondary color for export buttons */
            color: white; /* White text */
            padding: 12px 20px; /* Padding */
        }

        /* --- Message for No Data --- */
        .no-data {
            text-align: center; /* Center text */
            color: var(--dark-gray); /* Dark gray text */
            margin-top: 15px; /* Space above message */
            padding: 20px;
            font-size: 0.9rem; /* Small font size */
            opacity: 0.7; /* Slightly transparent */
            background-color: var(--light-gray); /* Light gray background */
            border-radius: var(--border-radius-default); /* Rounded corners */
            border: 1px dashed var(--medium-gray); /* Dashed border */
        }

        /* --- Debts/Credits Tab Styles --- */
        .debt-list-item {
            background: var(--card-background); /* White background */
            padding: 15px;
            margin-bottom: 10px; /* Space below item */
            border-radius: var(--border-radius-default); /* Rounded corners */
            box-shadow: var(--shadow-sm); /* Small shadow */
            position: relative;
            border: 1px solid var(--medium-gray); /* Light gray border */
        }

        .debt-item-summary {
            display: flex; /* Align items horizontally */
            justify-content: space-between; /* Space out name and amount */
            align-items: center; /* Vertically align */
            width: 100%; /* Full width */
            cursor: pointer; /* Indicate clickable */
            margin-bottom: 10px; /* Space below summary */
        }

        .debt-item-summary.sticky-header { /* Added for sticky header effect */
            position: sticky;
            top: 0; /* Stick to the top of its container */
            z-index: 10; /* Ensure it's above other content */
            background-color: var(--card-background); /* Maintain background */
            padding-top: 15px; /* Adjust padding if needed */
            padding-bottom: 10px; /* Adjust padding */
            margin-bottom: 10px; /* Maintain spacing */
        }

        .debt-item-summary .debt-name {
            font-weight: 600; /* Semi-bold */
            font-size: 1rem; /* Standard font size */
            color: var(--primary); /* Primary color */
        }

        .debt-item-summary .debt-amount {
            font-size: 1.1rem; /* Larger font size */
            font-weight: 600; /* Semi-bold */
        }

        .debt-item-details-expanded {
            display: none; /* Hide details by default */
            flex-direction: column; /* Stack content vertically */
            gap: 10px; /* Spacing between detail elements */
            font-size: 0.9rem; /* Small font size */
            color: var(--dark-gray); /* Dark gray text */
            border-top: 1px solid var(--medium-gray); /* Top border divider */
            padding-top: 10px; /* Padding above details */
        }

        .debt-item-details-expanded.visible {
            display: flex; /* Show details when visible */
        }

        .debt-actions {
            display: flex; /* Arrange actions horizontally */
            justify-content: flex-end; /* Align to the right */
            gap: 8px; /* Spacing between action buttons */
            margin-bottom: 10px; /* Space below actions */
        }

        .debt-details {
            display: flex; /* Arrange details horizontally */
            gap: 10px; /* Spacing between detail elements */
            margin-bottom: 10px; /* Space below details */
            align-items: center; /* Vertically align */
            flex-wrap: wrap; /* Allow wrapping */
        }

        .debt-type {
            font-weight: 500; /* Medium font weight */
            color: var(--text-light); /* Light text color */
            padding: 4px 8px; /* Padding */
            background-color: var(--light-gray); /* Light gray background */
            border-radius: var(--border-radius-default); /* Rounded corners */
            font-size: 0.8rem; /* Small font size */
        }

        .debt-note {
            font-size: 0.8rem; /* Small font size */
            color: var(--text-light); /* Light text color */
        }

        .debt-history-list {
            margin-top: 10px;
            padding-left: 10px; /* Indent history */
            border-left: 2px solid var(--medium-gray); /* Left border for history */
        }

        .debt-history-item {
            display: flex; /* Align items horizontally */
            justify-content: space-between; /* Space out text and actions */
            align-items: center;
            margin-bottom: 8px; /* Space below item */
            font-size: 0.8rem; /* Small font size */
            color: var(--dark-gray); /* Dark gray text */
            padding-bottom: 8px; /* Padding below text */
            border-bottom: 1px dashed var(--medium-gray); /* Dashed bottom border */
            flex-wrap: wrap; /* Allow wrapping for actions */
        }

        .debt-history-item:last-child {
            border-bottom: none; /* No border for the last item */
        }

        .debt-history-item .negative {
            color: var(--negative); /* Red for negative amounts */
        }
        .debt-history-item .positive {
            color: var(--positive); /* Green for positive amounts */
        }

        .debt-history-item .debt-history-actions {
             display: flex; /* Arrange buttons horizontally */
             gap: 6px; /* Spacing between buttons */
             margin-left: 8px; /* Space from the text */
             flex-shrink: 0; /* Prevent shrinking */
        }

        /* --- Debt Summary Totals --- */
        .debt-summary-totals {
            background-color: var(--light-gray); /* Light gray background */
            padding: 15px;
            margin-top: 15px; /* Space above totals */
            border-radius: var(--border-radius-default); /* Rounded corners */
            display: flex;
            flex-direction: column; /* Stack totals vertically */
            gap: 10px; /* Spacing between totals */
            font-weight: 600; /* Semi-bold */
            font-size: 1rem; /* Standard font size */
            border: 1px solid var(--medium-gray); /* Light gray border */
        }

        .debt-summary-totals .total-payable,
        .debt-summary-totals .total-receivable {
            display: flex; /* Align label and amount */
            justify-content: space-between; /* Space them out */
            align-items: center;
        }

        .debt-summary-totals .total-payable .amount {
            color: var(--negative); /* Red for payable amount */
        }

        .debt-summary-totals .total-receivable .amount {
            color: var(--positive); /* Green for receivable amount */
        }

        /* --- Debt Name Suggestions --- */
        #debt-name-suggestions {
            position: absolute; /* Position relative to parent */
            width: calc(100% - 30px); /* Full width minus container padding */
            background-color: white; /* White background */
            border: 1px solid var(--medium-gray); /* Light gray border */
            border-radius: var(--border-radius-default); /* Rounded corners */
            box-shadow: var(--shadow-md); /* Medium shadow */
            z-index: 50; /* Ensure it's above other elements */
            display: none; /* Hidden by default */
            max-height: 200px; /* Limit height */
            overflow-y: auto; /* Add scrollbar if content exceeds height */
        }

        .debt-suggestion-item {
            padding: 10px 15px; /* Padding */
            cursor: pointer; /* Indicate clickable */
            transition: background-color var(--transition-fast); /* Smooth hover effect */
            font-size: 0.9rem; /* Small font size */
        }
        .debt-suggestion-item:hover {
            background-color: var(--light-gray); /* Light gray on hover */
        }

        /* --- Responsive Adjustments --- */
        @media (min-width: 768px) {
            .container {
                max-width: 750px; /* Max width for larger screens */
                padding: 20px;
                margin: 20px auto; /* Center container with margin */
            }

            /* Tab layout adjustments for larger screens */
            .tabs-container, .tabs-container-bottom {
                display: flex; /* Use flexbox for tab layout */
                justify-content: center; /* Center tabs */
                flex-wrap: wrap; /* Allow tabs to wrap if needed */
            }

            .tab {
                padding: 12px 15px; /* Larger padding */
                flex: 0 0 auto; /* Prevent flex shrinking/growing */
            }

            /* Card layout adjustments */
            .card-container {
                grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); /* Wider minimum card width */
            }

            /* Filter section layout */
            .filter-section {
                flex-direction: row; /* Arrange filters horizontally */
                flex-wrap: wrap; /* Allow wrapping */
                align-items: center; /* Align items vertically */
            }

            .filter-section select,
            .filter-section input {
                flex: 1; /* Allow filters to grow */
                min-width: 150px; /* Minimum width for filters */
            }

            .filter-section button {
                width: auto; /* Auto width for buttons */
                flex-shrink: 0; /* Prevent shrinking */
            }

            /* Button group layout */
            .button-group {
                flex-direction: row; /* Arrange buttons horizontally */
            }

            .button-group button {
                width: auto; /* Auto width */
                flex: 1; /* Allow buttons to share space */
            }
        }

        /* --- Animation for smoother transitions --- */
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .tab-content {
            animation: fadeIn 0.3s ease-out; /* Apply fade-in animation to tab content */
        }
    </style>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css"> <!-- Font Awesome for icons -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script> <!-- SheetJS for Excel export -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script> <!-- jsPDF for PDF export -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script> <!-- html2canvas for capturing HTML to image -->
</head>
<body>

    <!-- Lock Screen Overlay -->
    <div id="lock-screen-overlay">
        <div id="lock-screen-content">
            <div id="lock-screen-title">Money Manager</div>
            <div id="lock-screen-message">Your application has been locked due to inactivity.</div>
            <input type="password" id="lock-screen-pin-input" maxlength="4" readonly placeholder="----">
            <div id="lock-screen-error-message"></div>
            <div id="lock-screen-keyboard">
                <div class="key-row">
                    <button onclick="handleLockScreenInput('1')">1</button>
                    <button onclick="handleLockScreenInput('2')">2</button>
                    <button onclick="handleLockScreenInput('3')">3</button>
                </div>
                <div class="key-row">
                    <button onclick="handleLockScreenInput('4')">4</button>
                    <button onclick="handleLockScreenInput('5')">5</button>
                    <button onclick="handleLockScreenInput('6')">6</button>
                </div>
                <div class="key-row">
                    <button onclick="handleLockScreenInput('7')">7</button>
                    <button onclick="handleLockScreenInput('8')">8</button>
                    <button onclick="handleLockScreenInput('9')">9</button>
                </div>
                <div class="key-row">
                    <button onclick="handleLockScreenInput('0')">0</button>
                </div>
                <div class="key-row">
                    <button onclick="handleLockScreenInput('delete')" class="key-delete"><i class="fas fa-backspace"></i></button>
                </div>
            </div>
            <div id="lock-screen-footer">MKT Computer & Mobile Services</div>
        </div>
    </div>

    <div class="container">
        <div class="header">
            <h1>My Money Manager</h1>
            <p>Your trusted companion for seamless financial tracking</p>
        </div>

        <!-- Tab Navigation -->
        <div class="tabs-container">
            <div class="tab" onclick="switchTab('opening')">Opening</div>
            <div class="tab" onclick="switchTab('transaction')">Transactions</div>
            <div class="tab" onclick="switchTab('daily-money')">Daily Money</div>
        </div>

        <div class="tabs-container-bottom">
            <div class="tab" onclick="switchTab('expense')">Expenses</div>
            <div class="tab" onclick="switchTab('debt')">Debts/Credits</div>
        </div>

        <!-- Opening Tab Content -->
        <div id="opening" class="tab-content active"> <!-- Make opening tab active by default -->
            <div class="form-section">
                <h2>Set Opening Balances</h2>
                <div class="form-group">
                    <label for="opening-emoney">E-Money Balance</label>
                    <input type="text" id="opening-emoney" placeholder="Enter E-Money amount" oninput="formatInputAmount(this)">
                </div>
                <div class="form-group">
                    <label for="opening-cash">Cash Balance</label>
                    <input type="text" id="opening-cash" placeholder="Enter Cash amount" oninput="formatInputAmount(this)">
                </div>
                <button onclick="saveOpeningBalances()">Save Opening Balances</button>
            </div>

            <!-- Backup & Restore Section -->
            <div class="backup-section">
                <h2>Data Backup & Restore</h2>
                <textarea class="backup-textarea" id="backup-data" placeholder="Your backup data will appear here..."></textarea>

                <div class="button-group">
                    <button onclick="generateBackup()" class="secondary"><i class="fas fa-download"></i> Generate Backup</button>
                    <button onclick="restoreBackup()" class="secondary"><i class="fas fa-upload"></i> Restore</button>
                </div>

                <div class="button-group" style="margin-top: 15px;">
                    <button onclick="generateBackupFile()" class="secondary"><i class="fas fa-file-export"></i> Export File</button>
                    <button class="secondary" onclick="document.getElementById('backup-file-input').click()"><i class="fas fa-file-import"></i> Import File</button>
                </div>

                <input type="file" id="backup-file-input" accept=".json" style="display: none;" onchange="restoreFromFile(event)">
            </div>

            <!-- Export Data Section -->
            <div class="form-section">
                <h2>Export Your Data</h2>
                <div class="export-buttons-container">
                    <button class="export-button" onclick="exportToExcel()">
                        <i class="fas fa-file-excel"></i> Export to Excel
                    </button>
                    <button class="export-button" onclick="exportToPDF()">
                        <i class="fas fa-file-pdf"></i> Export to PDF
                    </button>
                </div>
            </div>

            <!-- Security Settings Section -->
            <div id="settings-lock-section" class="form-section">
                <h3>Security Settings</h3>
                <div class="form-group">
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <input type="checkbox" id="enable-screen-lock" onchange="saveLockSetting()" style="width: 18px; height: 18px;">
                        <label for="enable-screen-lock" style="margin-bottom: 0;">Enable Screen Lock</label>
                    </div>
                </div>
                <div class="form-group">
                    <label for="current-pin">Current PIN:</label>
                    <input type="password" id="current-pin" placeholder="Enter current PIN" maxlength="4">
                </div>
                <div class="form-group">
                    <label for="new-pin">New PIN:</label>
                    <input type="password" id="new-pin" placeholder="Enter new 4-digit PIN" maxlength="4">
                </div>
                <div class="form-group">
                    <label for="confirm-new-pin">Confirm New PIN:</label>
                    <input type="password" id="confirm-new-pin" placeholder="Confirm new PIN" maxlength="4">
                </div>
                <button onclick="handleChangePIN()">Change PIN</button>
                <div style="margin-top: 15px; font-size: 0.8rem; color: var(--text-light);">
                    <i class="fas fa-info-circle"></i> Note: If you forget your PIN, all application data will be wiped.
                </div>
            </div>
        </div>

        <!-- Transaction Tab Content -->
        <div id="transaction" class="tab-content">
            <div class="card-container">
                <div class="card">
                    <h3>E-Money Balance</h3>
                    <div class="card-amount" id="e-money-balance">0.00</div>
                </div>
                <div class="card">
                    <h3>Cash Balance</h3>
                    <div class="card-amount" id="cash-balance">0.00</div>
                </div>
                <div class="card">
                    <h3>Total Balance</h3>
                    <div class="card-amount" id="total-balance">0.00</div>
                </div>
            </div>

            <div class="form-section">
                <h2>Add New Transaction</h2>
                <div class="form-group">
                    <label for="transaction-id">Transaction ID</label>
                    <input type="text" id="transaction-id" placeholder="Enter unique transaction ID">
                </div>
                <div class="form-group">
                    <label for="transaction-date">Date/Time</label>
                    <input type="datetime-local" id="transaction-date">
                </div>
                <div class="form-group">
                    <label for="transaction-type">Transaction Type</label>
                    <select id="transaction-type" onchange="updateTransactionType(); updateSavedCommissionAndFee();">
                        <option value="Wave Money">Wave Money</option>
                        <option value="Wave Pay">Wave Pay</option>
                        <option value="KBZ Pay">KBZ Pay</option>
                        <option value="Aya Pay">Aya Pay</option>
                        <option value="other">Other (Manual)</option>
                    </select>
                    <input type="text" id="transaction-type-other" style="display: none; margin-top: 10px;" placeholder="Specify other type">
                </div>
                <div class="form-group">
                    <label for="transaction-action">Action</label>
                    <select id="transaction-action" onchange="updateSavedCommissionAndFee();">
                        <option value="Cash In">Cash In</option>
                        <option value="Cash Out">Cash Out</option>
                        <option value="Send Money">Send Money</option>
                        <option value="Received Money">Received Money</option>
                        <option value="Payment">Payment</option>
                        <option value="Phone Bill">Phone Bill</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="transaction-amount">Amount</label>
                    <input type="text" id="transaction-amount" placeholder="Enter amount" oninput="updateSavedCommissionAndFee(); formatInputAmount(this);">
                </div>
                <div class="form-group">
                    <label for="transaction-commission">Commission</label>
                    <input type="text" id="transaction-commission" placeholder="Commission" oninput="saveFeeTemporarily(); formatInputAmount(this);">
                </div>
                <div class="form-group">
                    <label for="transaction-fee">Fee</label>
                    <input type="text" id="transaction-fee" placeholder="Enter fee" oninput="saveFeeTemporarily(); formatInputAmount(this);">
                </div>
                <div class="form-group phone-input">
                    <label for="transaction-phone">Phone Number</label>
                    <input type="text" id="transaction-phone" placeholder="0912345678">
                </div>
                <div class="form-group">
                    <label for="transaction-note">Note</label>
                    <input type="text" id="transaction-note" placeholder="Optional: customer name, details">
                </div>
                <div class="button-group">
                    <button type="button" onclick="addTransaction()"><i class="fas fa-plus-circle"></i> Add Transaction</button>
                    <button onclick="clearTransactionForm()" class="secondary"><i class="fas fa-broom"></i> Clear Form</button>
                </div>
            </div>

            <!-- Transaction Filters -->
            <div class="filter-section">
                <select id="transaction-filter-type">
                    <option value="all">All Types</option>
                    <option value="Wave Money">Wave Money</option>
                    <option value="Wave Pay">Wave Pay</option>
                    <option value="KBZ Pay">KBZ Pay</option>
                    <option value="Aya Pay">Aya Pay</option>
                </select>
                <select id="transaction-filter-action">
                    <option value="all">All Actions</option>
                    <option value="Cash In">Cash In</option>
                    <option value="Cash Out">Cash Out</option>
                    <option value="Send Money">Send Money</option>
                    <option value="Received Money">Received Money</option>
                    <option value="Payment">Payment</option>
                    <option value="Phone Bill">Phone Bill</option>
                </select>
                <input type="date" id="transaction-filter-date" onchange="filterTransactions()">
                <button onclick="filterTransactions()"><i class="fas fa-filter"></i> Filter</button>
                <button onclick="resetTransactionFilters()" class="secondary"><i class="fas fa-times"></i> Reset</button>
            </div>

            <!-- Transaction List -->
            <div class="transaction-list" id="transaction-list">
                <h2 onclick="toggleTransactionList()">Transaction History <span class="arrow"><i class="fas fa-chevron-down"></i></span></h2>
                <div class="transaction-list-items">
                    <!-- Transactions will be added here dynamically -->
                </div>
            </div>

            <!-- Daily Summary for Transactions -->
            <div class="summary-section">
                <h2 onclick="toggleTransactionSummary()">Daily Summary <span class="arrow"><i class="fas fa-chevron-down"></i></span></h2>
                <div class="summary-list">
                    <div class="summary-item">
                        <span class="summary-label">E-Money Balance Change (Today):</span>
                        <span id="daily-e-money" class="positive">0.00</span>
                    </div>
                    <div class="summary-item">
                        <span class="summary-label">Cash Balance Change (Today):</span>
                        <span id="daily-cash" class="positive">0.00</span>
                    </div>
                    <div class="summary-item">
                        <span class="summary-label">Total Commission Earned (Today):</span>
                        <span id="total-commission-summary" class="positive">0.00</span>
                    </div>
                    <div class="summary-item">
                        <span class="summary-label">Total Fees Charged (Today):</span>
                        <span id="total-fee-summary" class="positive">0.00</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Daily Money Tab Content -->
        <div id="daily-money" class="tab-content">
            <div class="form-section">
                <h2>Record Daily Money Flow</h2>
                <div class="form-group">
                    <label for="money-date">Date/Time</label>
                    <input type="datetime-local" id="money-date">
                </div>
                <div class="form-group">
                    <label for="money-amount">Amount</label>
                    <input type="text" id="money-amount" placeholder="Enter amount" oninput="calculateMoneyCommission(); formatInputAmount(this);">
                </div>
                <div class="form-group">
                    <label for="money-action">Action</label>
                    <select id="money-action" onchange="toggleCommissionField(); calculateMoneyCommission()">
                        <option value="Emoney In">E-Money In</option>
                        <option value="Emoney Out">E-Money Out</option>
                        <option value="Cash In">Cash In</option>
                        <option value="Cash Out">Cash Out</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="money-type">Type</label>
                    <select id="money-type" onchange="updateMoneyType()">
                        <option value="Wave Money">Wave Money</option>
                        <option value="KBZ Pay">KBZ Pay</option>
                        <option value="Aya Pay">Aya Pay</option>
                        <option value="other">Other (Manual)</option>
                    </select>
                    <input type="text" id="money-type-other" style="display: none; margin-top: 10px;" placeholder="Specify other type">
                </div>
                <div class="form-group" id="money-commission-group" style="display: none;">
                    <label for="money-commission">Commission (%)</label>
                    <input type="text" id="money-commission" placeholder="Enter commission percentage" oninput="calculateMoneyCommission(); formatInputAmount(this);">
                </div>
                <div class="form-group">
                    <label for="money-note">Note</label>
                    <input type="text" id="money-note" placeholder="Optional: source of funds, purpose">
                </div>
                <div class="button-group">
                    <button onclick="addMoneyRecord()"><i class="fas fa-plus-circle"></i> Add Record</button>
                    <button onclick="clearMoneyForm()" class="secondary"><i class="fas fa-broom"></i> Clear Form</button>
                </div>
            </div>

            <!-- Money Record Filters -->
            <div class="filter-section">
                <select id="money-filter-action">
                    <option value="all">All Actions</option>
                    <option value="Emoney In">E-Money In</option>
                    <option value="Emoney Out">E-Money Out</option>
                    <option value="Cash In">Cash In</option>
                    <option value="Cash Out">Cash Out</option>
                </select>
                <input type="date" id="money-filter-date" onchange="filterMoneyRecords()">
                <button onclick="filterMoneyRecords()"><i class="fas fa-filter"></i> Filter</button>
                <button onclick="resetMoneyFilters()" class="secondary"><i class="fas fa-times"></i> Reset</button>
            </div>

            <!-- Money Records List -->
            <div class="transaction-list" id="money-list">
                <h2 onclick="toggleMoneyList()">Money Records Flow <span class="arrow"><i class="fas fa-chevron-down"></i></span></h2>
                <div class="transaction-list-items">
                    <!-- Records will be added here dynamically -->
                </div>
            </div>

            <!-- Daily Summary for Money Records -->
            <div class="summary-section">
                <h2 onclick="toggleDailyMoneySummary()">Daily Summary <span class="arrow"><i class="fas fa-chevron-down"></i></span></h2>
                <div class="summary-list">
                    <div class="summary-item">
                        <span class="summary-label">E-Money In:</span>
                        <span id="daily-emoney-in" class="positive">0.00</span>
                    </div>
                    <div class="summary-item">
                        <span class="summary-label">E-Money Out:</span>
                        <span id="daily-emoney-out" class="negative">0.00</span>
                    </div>
                    <div class="summary-item">
                        <span class="summary-label">Cash In:</span>
                        <span id="daily-cash-in" class="positive">0.00</span>
                    </div>
                    <div class="summary-item">
                        <span class="summary-label">Cash Out:</span>
                        <span id="daily-cash-out" class="negative">0.00</span>
                    </div>
                    <div class="summary-item">
                        <span class="summary-label">Net Balance Change (Today):</span>
                        <span id="daily-remaining" class="positive">0.00</span>
                    </div>
                    <div class="summary-item" id="daily-money-commission-item" style="display: none;">
                        <span class="summary-label">Commission Earned:</span>
                        <span id="daily-money-commission" class="positive">0.00</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- EXPENSE TAB Content -->
        <div id="expense" class="tab-content">
            <div class="form-section">
                <h2>Add New Expense/Income Entry</h2>
                <div class="form-group">
                    <label for="expense-date">Date/Time</label>
                    <input type="datetime-local" id="expense-date">
                </div>
                <div class="form-group">
                    <label for="expense-type">Type</label>
                    <select id="expense-type" onchange="updateExpenseCategoryVisibility()">
                        <option value="Expense">Expense</option>
                        <option value="Income">Income</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="expense-category">Category</label>
                    <select id="expense-category" onchange="updateExpenseCategoryVisibility()">
                        <option value="Rent">Rent</option>
                        <option value="Sales">Sales</option>
                        <option value="other">Other (Manual)</option>
                    </select>
                    <input type="text" id="expense-category-other" style="display: none; margin-top: 10px;" placeholder="Specify other category">
                </div>
                <div class="form-group">
                    <label for="expense-amount">Amount</label>
                    <input type="text" id="expense-amount" placeholder="Enter amount" oninput="formatInputAmount(this)">
                </div>
                <div class="form-group">
                    <label for="expense-payment-method">Payment Method</label>
                    <select id="expense-payment-method" onchange="updatePaymentMethodVisibility()">
                        <option value="E-Money">E-Money</option>
                        <option value="Cash">Cash</option>
                        <option value="Other">Other</option>
                    </select>
                    <input type="text" id="expense-payment-method-other" style="display: none; margin-top: 10px;" placeholder="Specify other method">
                </div>
                <div class="form-group">
                    <label for="expense-note">Note</label>
                    <input type="text" id="expense-note" placeholder="Optional: purpose of expense, source of income">
                </div>
                <div class="button-group">
                    <button type="button" onclick="addExpenseEntry()"><i class="fas fa-plus-circle"></i> Add Entry</button>
                    <button onclick="clearExpenseForm()" class="secondary"><i class="fas fa-broom"></i> Clear Form</button>
                </div>
            </div>

            <!-- Expense Filters -->
            <div class="filter-section">
                <select id="expense-filter-type">
                    <option value="all">All Types</option>
                    <option value="Expense">Expense</option>
                    <option value="Income">Income</option>
                </select>
                <input type="text" id="expense-filter-category" placeholder="Filter by Category">
                <input type="date" id="expense-filter-date" onchange="filterExpenses()">
                <button onclick="filterExpenses()"><i class="fas fa-filter"></i> Filter</button>
                <button onclick="resetExpenseFilters()" class="secondary"><i class="fas fa-times"></i> Reset</button>
            </div>

            <!-- Expense/Income List -->
            <div class="transaction-list" id="expense-list">
                <h2 onclick="toggleExpand(this.parentElement)">Expense/Income Records <span class="arrow"><i class="fas fa-chevron-down"></i></span></h2>
                <div class="transaction-list-items">
                    <!-- Expense entries will be added here -->
                </div>
            </div>

            <!-- Daily Summary for Expenses -->
            <div class="summary-section">
                <h2 onclick="updateExpenseSummaries(); toggleExpand(this.parentElement)">Daily Summary <span class="arrow"><i class="fas fa-chevron-down"></i></span></h2>
                <div class="summary-list">
                    <div class="summary-item">
                        <span class="summary-label">Total Income (Today):</span>
                        <span id="daily-total-income" class="positive">0.00</span>
                    </div>
                    <div class="summary-item">
                        <span class="summary-label">Total Expenses (Today):</span>
                        <span id="daily-total-expenses" class="negative">0.00</span>
                    </div>
                    <div class="summary-item">
                        <span class="summary-label">Net Balance (Today):</span>
                        <span id="daily-net-balance" class="positive">0.00</span>
                    </div>
                </div>
            </div>

            <!-- Periodical Summary for Expenses -->
            <div class="summary-section">
                <h2 onclick="updatePeriodicalExpenseSummaries(); toggleExpand(this.parentElement)">Periodical Summaries <span class="arrow"><i class="fas fa-chevron-down"></i></span></h2>
                <div class="summary-list">
                    <div class="form-group">
                        <label for="period-type">Select Period:</label>
                        <select id="period-type" onchange="updatePeriodicalExpenseSummaries()">
                            <option value="week">This Week</option>
                            <option value="month">This Month</option>
                            <option value="year">This Year</option>
                        </select>
                    </div>
                    <div class="summary-item">
                        <span class="summary-label">Total Income (Period):</span>
                        <span id="periodical-total-income" class="positive">0.00</span>
                    </div>
                    <div class="summary-item">
                        <span class="summary-label">Total Expenses (Period):</span>
                        <span id="periodical-total-expenses" class="negative">0.00</span>
                    </div>
                    <div class="summary-item">
                        <span class="summary-label">Net Balance (Period):</span>
                        <span id="periodical-net-balance" class="positive">0.00</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Debts/Credits Tab Content -->
        <div id="debt" class="tab-content">
            <div class="form-section debt-form-section">
                <h2>Add New Debt/Credit Entry</h2>
                <div class="form-group" style="position: relative;">
                    <label for="debt-name">Name</label>
                    <input type="text" id="debt-name" placeholder="Enter person's name" oninput="handleDebtNameInput(event)">
                    <!-- Suggestions Dropdown -->
                    <div id="debt-name-suggestions">
                        <!-- Suggestions will be loaded here -->
                    </div>
                </div>
                <div class="form-group">
                    <label for="debt-type">Type</label>
                    <select id="debt-type" onchange="updateDebtFormVisibility()">
                        <option value="payable">You Owe (Payable)</option>
                        <option value="receivable">Others Owe You (Receivable)</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="debt-amount">Amount</label>
                    <input type="text" id="debt-amount" placeholder="Enter amount" oninput="formatInputAmount(this)">
                </div>
                <div class="form-group">
                    <label for="debt-date">Date/Time</label>
                    <input type="datetime-local" id="debt-date">
                </div>
                <div class="form-group">
                    <label for="debt-note">Note</label>
                    <input type="text" id="debt-note" placeholder="Optional: reason for debt, repayment terms">
                </div>
                <div class="button-group">
                    <button id="add-update-debt-button" onclick="addOrUpdateDebtEntry()"><i class="fas fa-save"></i> Add Debt/Credit</button>
                    <button onclick="clearDebtForm()" class="secondary"><i class="fas fa-broom"></i> Clear Form</button>
                </div>
            </div>

            <!-- Debt Filter -->
            <div class="filter-section">
                <input type="text" id="debt-filter-name" placeholder="Search by Name..." style="min-width: 250px; flex-grow: 2;">
                <button onclick="filterDebts()"><i class="fas fa-search"></i> Search</button>
                <button onclick="resetDebtFilters()" class="secondary"><i class="fas fa-times"></i> Reset</button>
            </div>

            <!-- Payable Debts List -->
            <div class="transaction-list" id="payable-debts-list">
                <h2 onclick="toggleExpand(this.parentElement)">Payable Debts <span class="arrow"><i class="fas fa-chevron-down"></i></span></h2>
                <div class="transaction-list-items">
                    <!-- Payable debt items will be added here -->
                </div>
            </div>

            <!-- Receivable Credits List -->
            <div class="transaction-list" id="receivable-debts-list">
                <h2 onclick="toggleExpand(this.parentElement)">Receivable Credits <span class="arrow"><i class="fas fa-chevron-down"></i></span></h2>
                <div class="transaction-list-items">
                    <!-- Receivable debt items will be added here -->
                </div>
            </div>

            <!-- Debt/Credit Summary Totals -->
            <div class="debt-summary-totals">
                <div class="total-payable">
                    <span class="label">Total Payable:</span>
                    <span class="amount" id="total-payable-amount">0.00</span>
                </div>
                <div class="total-receivable">
                    <span class="label">Total Receivable:</span>
                    <span class="amount" id="total-receivable-amount">0.00</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- GLOBAL STATE VARIABLES ---
        let transactions = []; // Stores all transaction objects
        let moneyRecords = []; // Stores all money flow records
        let debts = []; // Stores debt/credit groups. Each group has 'name', 'type', and 'history'.
        let openingBalances = { eMoney: 0, cash: 0 }; // Stores initial balances
        let savedOtherTransactionTypes = {}; // Stores custom transaction types for auto-add
        let savedOtherMoneyTypes = {}; // Stores custom money record types for auto-add
        let tempCommissionData = {}; // Stores commission/fee data temporarily for auto-fill lookup
        let currentFilteredTransactions = []; // Holds transactions filtered by transaction tab filters for summary updates
        let existingDebtNames = []; // Stores unique debt names for autocomplete suggestions
        let editingDebtEntry = null; // Context for debt entry being edited: { id, type, groupType, groupIdx, entryIdx }

        // Expense related variables
        let expenseEntries = []; // Stores all expense/income entries
        let savedExpenseCategories = {}; // Stores custom expense categories from localStorage

        // --- SCREEN LOCK VARIABLES ---
        let isLocked = false; // Global state to track if the screen is locked
        let lockAttempts = 0; // Counter for incorrect PIN attempts
        const MAX_LOCK_ATTEMPTS = 10; // Maximum incorrect attempts before permanent lockout
        let lockScreenTimer = null; // Timer for automatic locking
        const AUTO_LOCK_DELAY = 5 * 60 * 1000; // 5 minutes in milliseconds (5 * 60 * 1000)
        let pinInputBuffer = ''; // Stores the digits entered on the lock screen keyboard
        let settingsPIN = '0000'; // Default initial PIN, loaded/saved from localStorage
        let isScreenLockEnabled = false; // Flag for whether screen lock is enabled in settings
        let permanentlyLocked = false; // Flag for permanent lockout state
        let hideSuggestionsOnClickOutside = null; // Handler for closing debt name suggestions when clicking outside

        // --- INITIALIZATION FUNCTIONS ---

        // Initializes the lock screen state by loading settings from localStorage.
        function initializeLockScreen() {
            const storedPIN = localStorage.getItem('moneyManager_appPIN');
            if (storedPIN) {
                settingsPIN = storedPIN; // Use stored PIN if available
            } else {
                // Set default PIN and store it if none exists
                settingsPIN = '0000'; // Default PIN
                localStorage.setItem('moneyManager_appPIN', settingsPIN);
            }

            // Load screen lock enabled status
            isScreenLockEnabled = localStorage.getItem('moneyManager_isScreenLockEnabled') === 'true';
            document.getElementById('enable-screen-lock').checked = isScreenLockEnabled; // Update checkbox state

            // Load permanent lockout status
            permanentlyLocked = localStorage.getItem('moneyManager_permanentlyLocked') === 'true';

            if (permanentlyLocked) {
                // If permanently locked, show message and disable keyboard
                showLockScreen("This application has been permanently locked due to too many failed attempts. All data has been wiped.");
                document.getElementById('lock-screen-keyboard').style.display = 'none';
            } else if (isScreenLockEnabled) {
                // If lock is enabled and not already visible, show lock screen
                if (!isLocked) {
                    showLockScreen("Your application has been locked. Please enter your PIN to continue.");
                    lockAttempts = 0; // Reset attempts
                    pinInputBuffer = ''; // Clear input buffer
                }
            } else {
                // If lock is not enabled, ensure the lock screen is hidden
                hideLockScreen();
            }
        }

        // Saves the screen lock enable/disable setting to localStorage.
        function saveLockSetting() {
            const checkbox = document.getElementById('enable-screen-lock');
            isScreenLockEnabled = checkbox.checked; // Update state variable
            localStorage.setItem('moneyManager_isScreenLockEnabled', isScreenLockEnabled); // Save to localStorage

            if (isScreenLockEnabled) {
                // If enabled and not already locked, show the lock screen
                if (!isLocked && !permanentlyLocked) {
                    showLockScreen("Screen lock is now enabled. Please enter your PIN to continue.");
                    lockAttempts = 0;
                    pinInputBuffer = '';
                }
            } else {
                // If disabled and currently locked, hide the lock screen
                if (isLocked) {
                    hideLockScreen();
                }
                const overlay = document.getElementById('lock-screen-overlay');
                if (overlay) {
                    overlay.classList.remove('visible'); // Remove visible class
                }
                isLocked = false; // Update state
                clearTimeout(lockScreenTimer); // Clear any pending lock timer
            }
        }

        // Displays the lock screen overlay with an optional message.
        function showLockScreen(message = null) {
            const overlay = document.getElementById('lock-screen-overlay');
            if (overlay) {
                overlay.classList.add('visible'); // Add class to make it visible
            }
            isLocked = true; // Update lock state
            pinInputBuffer = ''; // Clear PIN input buffer
            document.getElementById('lock-screen-pin-input').value = ''; // Clear displayed PIN
            document.getElementById('lock-screen-error-message').textContent = ''; // Clear error messages

            // Set the lock screen message
            if (message) {
                document.getElementById('lock-screen-message').textContent = message;
            } else {
                document.getElementById('lock-screen-message').textContent = "Your application has been locked. Please enter your PIN.";
            }

            // Show/hide keyboard based on permanent lockout status
            const keyboard = document.getElementById('lock-screen-keyboard');
            if (keyboard) {
                keyboard.style.display = permanentlyLocked ? 'none' : 'block';
            }
        }

        // Hides the lock screen overlay and resumes application functionality.
        function hideLockScreen() {
            const overlay = document.getElementById('lock-screen-overlay');
            if (overlay) {
                overlay.classList.remove('visible'); // Remove class to hide overlay
            }
            isLocked = false; // Update lock state
            pinInputBuffer = ''; // Clear PIN input buffer
            document.getElementById('lock-screen-pin-input').value = ''; // Clear displayed PIN
            document.getElementById('lock-screen-error-message').textContent = ''; // Clear error messages

            // If screen lock is enabled and not permanently locked, restart the timer
            if (isScreenLockEnabled && !permanentlyLocked) {
                startLockTimer();
            }
        }

        // Handles input from the lock screen numeric keyboard (digits and delete).
        function handleLockScreenInput(input) {
            if (permanentlyLocked) return; // Do nothing if permanently locked

            const errorDisplay = document.getElementById('lock-screen-error-message');

            if (input === 'delete') {
                pinInputBuffer = pinInputBuffer.slice(0, -1); // Remove last digit
            } else {
                if (pinInputBuffer.length < 4) { // Only allow 4 digits
                    pinInputBuffer += input; // Append digit
                }
            }
            // Update the displayed PIN with asterisks
            document.getElementById('lock-screen-pin-input').value = '*'.repeat(pinInputBuffer.length);

            // If PIN is complete, check it
            if (pinInputBuffer.length === 4) {
                checkPIN(pinInputBuffer);
            }
        }

        // Checks the entered PIN against the stored settings PIN.
        function checkPIN(enteredPIN) {
            if (permanentlyLocked) return; // Do nothing if permanently locked

            const errorDisplay = document.getElementById('lock-screen-error-message');

            if (enteredPIN === settingsPIN) {
                // Correct PIN entered
                errorDisplay.textContent = ''; // Clear error message
                hideLockScreen(); // Hide the lock screen
                return;
            } else {
                // Incorrect PIN entered
                lockAttempts++; // Increment attempt counter
                pinInputBuffer = ''; // Clear input buffer
                document.getElementById('lock-screen-pin-input').value = ''; // Clear displayed PIN

                if (lockAttempts >= MAX_LOCK_ATTEMPTS) {
                    // Too many failed attempts
                    permanentlyLocked = true; // Set permanent lockout state
                    localStorage.setItem('moneyManager_permanentlyLocked', 'true');
                    wipeAllData(); // Wipe all data as a security measure
                    errorDisplay.textContent = `Too many failed attempts. Application permanently locked.`;
                    document.getElementById('lock-screen-message').textContent = "Your application has been permanently locked. All data has been wiped.";
                    document.getElementById('lock-screen-keyboard').style.display = 'none'; // Hide keyboard
                    return;
                } else {
                    // Provide feedback for incorrect PIN and remaining attempts
                    errorDisplay.textContent = `Incorrect PIN. ${MAX_LOCK_ATTEMPTS - lockAttempts} attempts remaining.`;
                    document.getElementById('lock-screen-message').textContent = "Incorrect PIN. Please try again.";
                }
            }
        }

        // Wipes all application data from localStorage and resets global state.
        function wipeAllData() {
            // Remove all application-specific keys from localStorage
            localStorage.removeItem('moneyManager_transactions');
            localStorage.removeItem('moneyManager_moneyRecords');
            localStorage.removeItem('moneyManager_openingBalances');
            localStorage.removeItem('moneyManager_savedOtherTransactionTypes');
            localStorage.removeItem('moneyManager_savedOtherMoneyTypes');
            localStorage.removeItem('moneyManager_tempCommissionData');
            localStorage.removeItem('moneyManager_debts');
            localStorage.removeItem('moneyManager_expenseEntries');
            localStorage.removeItem('moneyManager_savedExpenseCategories');
            localStorage.removeItem('moneyManager_appPIN'); // Clear PIN on wipe
            localStorage.removeItem('moneyManager_isScreenLockEnabled');
            localStorage.removeItem('moneyManager_permanentlyLocked');

            // Reset global variables to their initial empty states
            transactions = []; moneyRecords = []; debts = []; openingBalances = { eMoney: 0, cash: 0 };
            savedOtherTransactionTypes = {}; savedOtherMoneyTypes = {}; tempCommissionData = {};
            expenseEntries = []; savedExpenseCategories = {};

            // Refresh UI elements to reflect cleared data
            updateSummariesBasedOnCurrentView();
            updateTransactionList();
            updateMoneyList();
            renderDebts();
            populateCustomTypes();
            populateExpenseCategories();
            renderExpenseEntries();

            // Clear input fields in the opening balance section
            document.getElementById('opening-emoney').value = '';
            document.getElementById('opening-cash').value = '';

            showToast("All application data has been wiped due to security measures.", "error"); // Notify user
        }

        // Starts the timer for automatic screen locking after a period of inactivity.
        function startLockTimer() {
            clearTimeout(lockScreenTimer); // Clear any existing timer
            lockScreenTimer = setTimeout(() => {
                // If the screen is not already locked, lock is enabled, and not permanently locked, then lock the screen
                if (!isLocked && isScreenLockEnabled && !permanentlyLocked) {
                    showLockScreen("Your session has timed out and the application has been locked.");
                    lockAttempts = 0; // Reset attempts on timeout
                    pinInputBuffer = '';
                }
            }, AUTO_LOCK_DELAY); // Set the delay for locking
        }

        // Resets the inactivity timer when the user performs an action.
        function resetLockTimer() {
            // Only reset if lock is enabled and not permanently locked, and screen is not already locked
            if (!isLocked && isScreenLockEnabled && !permanentlyLocked) {
                startLockTimer();
            }
        }

        // --- SETTINGS: PIN CHANGE FUNCTIONALITY ---
        // Handles the process of changing the application PIN.
        function handleChangePIN() {
            const currentPinInput = document.getElementById('current-pin');
            const newPinInput = document.getElementById('new-pin');
            const confirmNewPinInput = document.getElementById('confirm-new-pin');

            // Get values from input fields
            const currentPin = currentPinInput.value;
            const newPin = newPinInput.value;
            const confirmNewPin = confirmNewPinInput.value;

            // Validation checks
            if (!currentPin || !newPin || !confirmNewPin) {
                showToast("Please fill in all PIN fields.", "error");
                return;
            }
            if (newPin.length !== 4 || !/^\d+$/.test(newPin)) { // New PIN must be 4 digits
                showToast("New PIN must be exactly 4 digits.", "error");
                return;
            }
            if (newPin !== confirmNewPin) { // New PIN and confirmation must match
                showToast("New PIN and Confirm New PIN do not match.", "error");
                return;
            }

            if (currentPin !== settingsPIN) { // Current PIN must be correct
                showToast("Incorrect current PIN.", "error");
                return;
            }

            // Update PIN if all validations pass
            settingsPIN = newPin;
            localStorage.setItem('moneyManager_appPIN', settingsPIN); // Save new PIN

            // Clear input fields after successful change
            currentPinInput.value = '';
            newPinInput.value = '';
            confirmNewPinInput.value = '';

            showToast("PIN changed successfully!"); // Success notification
        }

        // --- UTILITY FUNCTIONS ---

        // Formats a number for display with comma separators and two decimal places.
        function formatNumber(num) {
            if (num === null || num === undefined) return '0.00'; // Handle null/undefined
            const n = parseFloat(num);
            if (isNaN(n)) return '0.00'; // Handle NaN

            // Format integers with commas, and decimals with two places
            if (Number.isInteger(n)) {
                return n.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
            } else {
                let parts = n.toFixed(2).split('.'); // Split into integer and decimal parts
                parts[0] = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, ","); // Add commas to integer part
                return parts.join('.'); // Join back with decimal point
            }
        }

        // Formats an input field value to have comma separators and at most two decimal places
        // as the user types.
        function formatInputAmount(inputElement) {
            let value = inputElement.value.replace(/,/g, ''); // Remove existing commas
            let cleanedValue = '';
            let decimalFound = false;

            // Iterate through characters to build a cleaned numeric string
            for (let i = 0; i < value.length; i++) {
                const char = value[i];
                if (char >= '0' && char <= '9') {
                    cleanedValue += char; // Append digits
                } else if (char === '.' && !decimalFound) {
                    cleanedValue += '.'; // Append decimal point once
                    decimalFound = true;
                }
            }
            // Limit decimal part to two digits
            if (cleanedValue.includes('.')) {
                const decimalPart = cleanedValue.split('.')[1];
                if (decimalPart && decimalPart.length > 2) {
                    cleanedValue = cleanedValue.substring(0, cleanedValue.indexOf('.') + 3); // Truncate decimal part
                }
            }

            // Reformat with commas
            let formattedValue = '';
            let commaIndex = cleanedValue.indexOf('.');
            let integerPart = commaIndex === -1 ? cleanedValue : cleanedValue.substring(0, commaIndex);
            let decimalPart = commaIndex === -1 ? '' : '.' + cleanedValue.substring(commaIndex + 1);

            // Add commas to the integer part
            for (let i = integerPart.length - 1; i >= 0; i--) {
                formattedValue = integerPart[i] + formattedValue;
                if ((integerPart.length - i) % 3 === 0 && i !== 0) { // Add comma every 3 digits from the right
                    formattedValue = ',' + formattedValue;
                }
            }
            inputElement.value = formattedValue + decimalPart; // Set the formatted value back to the input
        }

        // Sets the current date and time to relevant input fields if they are empty.
        function updateDateTimeFields() {
            const now = new Date();
            const year = now.getFullYear();
            const month = (now.getMonth() + 1).toString().padStart(2, '0'); // Month is 0-indexed
            const day = now.getDate().toString().padStart(2, '0');
            const hours = now.getHours().toString().padStart(2, '0');
            const minutes = now.getMinutes().toString().padStart(2, '0');

            const currentDateTime = `${year}-${month}-${day}T${hours}:${minutes}`; // Format for datetime-local input

            // Set value for transaction date if empty
            if (!document.getElementById('transaction-date').value) {
                 document.getElementById('transaction-date').value = currentDateTime;
            }
            // Set value for money record date if empty
            if (!document.getElementById('money-date').value) {
                document.getElementById('money-date').value = currentDateTime;
            }
            // Set value for debt date if empty
            if (!document.getElementById('debt-date').value) {
                 document.getElementById('debt-date').value = currentDateTime;
            }
            // Set value for expense date if empty
            if (!document.getElementById('expense-date').value) {
                document.getElementById('expense-date').value = currentDateTime;
            }
        }

        // Displays a temporary notification message (toast) at the bottom of the screen.
        function showToast(message, type = 'success') {
            const toast = document.createElement('div');
            toast.className = `toast ${type}`; // Assign class for styling
            toast.textContent = message;
            document.body.appendChild(toast); // Add toast to the DOM

            // Trigger reflow to ensure CSS transitions apply
            void toast.offsetWidth;
            toast.classList.add('show'); // Add class to make it visible and animate

            // Remove toast after a delay
            setTimeout(() => {
                toast.classList.remove('show'); // Start fade-out
                setTimeout(() => {
                    toast.remove(); // Remove element from DOM
                }, 300); // Match transition duration
            }, 3000); // Display duration
        }

        // Adds a new option to a specified select element dynamically.
        function addOptionToSelect(selectId, optionValue) {
            const selectElement = document.getElementById(selectId);
            // Check if option already exists (case-insensitive)
            const optionExists = Array.from(selectElement.options).some(option => option.value.toLowerCase() === optionValue.toLowerCase());
            // Add only if it's a valid, new option and not 'other'
            if (!optionExists && optionValue && optionValue.trim() !== '' && optionValue.trim().toLowerCase() !== 'other') {
                const newOption = document.createElement('option');
                newOption.value = optionValue.trim(); // Set value
                newOption.textContent = optionValue.trim(); // Set display text

                const otherOption = selectElement.querySelector('option[value="other"]');
                if (otherOption) {
                    selectElement.insertBefore(newOption, otherOption); // Insert before 'Other' option
                } else {
                    selectElement.appendChild(newOption); // Append if 'Other' is not present
                }
            }
        }

        // --- DATA PERSISTENCE (SAVE/LOAD TO LOCALSTORAGE) ---

        // Saves all application data (transactions, records, etc.) to localStorage.
        function saveData() {
            try {
                // Stringify and save each data array/object
                localStorage.setItem('moneyManager_transactions', JSON.stringify(transactions));
                localStorage.setItem('moneyManager_moneyRecords', JSON.stringify(moneyRecords));
                localStorage.setItem('moneyManager_openingBalances', JSON.stringify(openingBalances));
                localStorage.setItem('moneyManager_savedOtherTransactionTypes', JSON.stringify(savedOtherTransactionTypes));
                localStorage.setItem('moneyManager_savedOtherMoneyTypes', JSON.stringify(savedOtherMoneyTypes));
                localStorage.setItem('moneyManager_tempCommissionData', JSON.stringify(tempCommissionData));
                localStorage.setItem('moneyManager_debts', JSON.stringify(debts));
                localStorage.setItem('moneyManager_expenseEntries', JSON.stringify(expenseEntries));
                localStorage.setItem('moneyManager_savedExpenseCategories', JSON.stringify(savedExpenseCategories));
            } catch (e) {
                // Handle potential errors, e.g., storage quota exceeded
                console.error("Error saving data to localStorage:", e);
                if (e.name === 'QuotaExceededError') {
                    showToast("Local storage is full. Cannot save data.", "error");
                } else {
                    showToast("An error occurred while saving data.", "error");
                }
            }
        }

        // Loads data from localStorage into the application's global variables.
        function loadData() {
            // Retrieve data from localStorage, defaulting to empty arrays/objects if not found
            let savedTransactions = localStorage.getItem('moneyManager_transactions');
            let savedMoneyRecords = localStorage.getItem('moneyManager_moneyRecords');
            let savedOpeningBalances = localStorage.getItem('moneyManager_openingBalances');
            let savedOtherTransactionTypesData = localStorage.getItem('moneyManager_savedOtherTransactionTypes');
            let savedOtherMoneyTypesData = localStorage.getItem('moneyManager_savedOtherMoneyTypes');
            let savedTempCommissionData = localStorage.getItem('moneyManager_tempCommissionData');
            let savedDebts = localStorage.getItem('moneyManager_debts');
            let savedExpenseEntries = localStorage.getItem('moneyManager_expenseEntries');
            let savedExpenseCategoriesData = localStorage.getItem('moneyManager_savedExpenseCategories');

            try {
                // Parse JSON data, providing defaults if parsing fails or data is missing
                transactions = savedTransactions ? JSON.parse(savedTransactions) : [];
                moneyRecords = savedMoneyRecords ? JSON.parse(savedMoneyRecords) : [];
                openingBalances = savedOpeningBalances ? JSON.parse(savedOpeningBalances) : { eMoney: 0, cash: 0 };
                savedOtherTransactionTypes = savedOtherTransactionTypesData ? JSON.parse(savedOtherTransactionTypesData) : {};
                savedOtherMoneyTypes = savedOtherMoneyTypesData ? JSON.parse(savedOtherMoneyTypesData) : {};
                tempCommissionData = savedTempCommissionData ? JSON.parse(savedTempCommissionData) : {};
                debts = savedDebts ? JSON.parse(savedDebts) : [];
                expenseEntries = savedExpenseEntries ? JSON.parse(savedExpenseEntries) : [];
                savedExpenseCategories = savedExpenseCategoriesData ? JSON.parse(savedExpenseCategoriesData) : {};

            } catch (e) {
                // Handle potential JSON parsing errors
                console.error("Error parsing data from localStorage:", e);
                showToast("Error reading data from local storage", "error");
                // Reset all data to defaults on error
                transactions = []; moneyRecords = []; debts = []; openingBalances = { eMoney: 0, cash: 0 };
                savedOtherTransactionTypes = {}; savedOtherMoneyTypes = {}; tempCommissionData = {};
                expenseEntries = []; savedExpenseCategories = {};
                return; // Exit function if parsing failed
            }

            // --- Data Validation and Cleanup ---
            // Ensure arrays are actual arrays and objects are valid
            if (!Array.isArray(transactions)) transactions = [];
            if (!Array.isArray(moneyRecords)) moneyRecords = [];
            if (typeof openingBalances !== 'object' || openingBalances === null) openingBalances = { eMoney: 0, cash: 0 };
            if (typeof openingBalances.eMoney !== 'number' || isNaN(openingBalances.eMoney)) openingBalances.eMoney = 0; // Ensure numbers are valid
            if (typeof openingBalances.cash !== 'number' || isNaN(openingBalances.cash)) openingBalances.cash = 0;
            if (typeof savedOtherTransactionTypes !== 'object' || savedOtherTransactionTypes === null) savedOtherTransactionTypes = {};
            if (typeof savedOtherMoneyTypes !== 'object' || savedOtherMoneyTypes === null) savedOtherMoneyTypes = {};
            if (typeof tempCommissionData !== 'object' || tempCommissionData === null) tempCommissionData = {};
            if (!Array.isArray(debts)) debts = [];
            if (!Array.isArray(expenseEntries)) expenseEntries = [];
            if (typeof savedExpenseCategories !== 'object' || savedExpenseCategories === null) savedExpenseCategories = {};

            // Populate dropdowns with any loaded custom types/categories
            updateExistingDebtNames(); // Update name list for debt autocomplete
            populateCustomTypes(); // Populate transaction and money type selects
            populateExpenseCategories(); // Populate expense category select
        }

        // Populates the custom transaction and money record type select dropdowns from saved data.
        function populateCustomTypes() {
            const transactionTypeSelect = document.getElementById('transaction-type');
            const moneyTypeSelect = document.getElementById('money-type');

            // Get existing types to avoid duplicates
            const existingTransactionTypes = Array.from(transactionTypeSelect.options).map(opt => opt.value.toLowerCase());
            // Add saved custom transaction types
            for (const type in savedOtherTransactionTypes) {
                if (Object.hasOwnProperty.call(savedOtherTransactionTypes, type) && type.trim() !== '' && type.toLowerCase() !== 'other' && !existingTransactionTypes.includes(type.toLowerCase())) {
                    addOptionToSelect('transaction-type', type);
                }
            }

            // Get existing types for money records
            const existingMoneyTypes = Array.from(moneyTypeSelect.options).map(opt => opt.value.toLowerCase());
            // Add saved custom money record types
            for (const type in savedOtherMoneyTypes) {
                if (Object.hasOwnProperty.call(savedOtherMoneyTypes, type) && type.trim() !== '' && type.toLowerCase() !== 'other' && !existingMoneyTypes.includes(type.toLowerCase())) {
                    addOptionToSelect('money-type', type);
                }
            }
        }

        // Populates the expense category select dropdown with saved custom categories.
        function populateExpenseCategories() {
            const expenseCategorySelect = document.getElementById('expense-category');

            // Get existing categories to avoid duplicates
            const existingCategories = Array.from(expenseCategorySelect.options).map(opt => opt.value.toLowerCase());
            // Add saved custom categories
            for (const category in savedExpenseCategories) {
                if (Object.hasOwnProperty.call(savedExpenseCategories, category) && category.trim() !== '' && category.toLowerCase() !== 'other' && !existingCategories.includes(category.toLowerCase())) {
                    addOptionToSelect('expense-category', category);
                }
            }
        }

        // --- MAIN APPLICATION INITIALIZATION ---
        // Runs when the DOM is fully loaded.
        document.addEventListener('DOMContentLoaded', function() {
            initializeLockScreen(); // Initialize lock screen first to set its state
            updateDateTimeFields(); // Set current date/time to input fields
            loadData(); // Load all saved data from localStorage

            // Initial rendering of all lists and summaries
            updateSummariesBasedOnCurrentView();
            updateTransactionList();
            updateMoneyList();
            renderDebts();
            renderExpenseEntries();
            updatePeriodicalExpenseSummaries(); // Ensure periodical summaries are shown on load

            // Add a global click listener for handling interactions like closing suggestions or toggling active states
            document.addEventListener('click', function(e) {
                // Handle active state for transaction items
                const transactionItem = e.target.closest('.transaction-item');
                if (transactionItem) {
                    // Only toggle active state if click is not on action buttons
                    if (!e.target.closest('.transaction-actions')) {
                        transactionItem.classList.toggle('active'); // Toggle active class

                        // Ensure only one item is active within the same group
                        const parentGroupDetails = transactionItem.closest('.group-details');
                        if(parentGroupDetails) {
                            parentGroupDetails.querySelectorAll('.transaction-item').forEach(item => {
                                if (item !== transactionItem) {
                                    item.classList.remove('active'); // Remove active from siblings
                                }
                            });
                        }
                    }
                } else {
                    // If click is outside any transaction item, remove all active classes
                    document.querySelectorAll('.transaction-item').forEach(item => {
                        item.classList.remove('active');
                    });
                }

                // Handle closing debt name suggestions
                const debtNameInput = document.getElementById('debt-name');
                const suggestionsContainer = document.getElementById('debt-name-suggestions');
                if (suggestionsContainer && debtNameInput && !suggestionsContainer.contains(e.target) && !debtNameInput.contains(e.target)) {
                    suggestionsContainer.style.display = 'none'; // Hide suggestions
                    // Remove the global listener if it exists
                    if (hideSuggestionsOnClickOutside) {
                        document.removeEventListener('click', hideSuggestionsOnClickOutside);
                        hideSuggestionsOnClickOutside = null;
                    }
                }
                resetLockTimer(); // Reset the lock timer on any click activity
            });

            // Add event listeners for user activity to reset the lock timer
            document.addEventListener('mousemove', resetLockTimer);
            document.addEventListener('mousedown', resetLockTimer);
            document.addEventListener('keydown', resetLockTimer);
            document.addEventListener('touchstart', resetLockTimer);

            // Initialze visibility of 'Other' input fields and form states
            updateTransactionType();
            updateMoneyType();
            updateExpenseCategoryVisibility(); // Correctly called here
            updatePaymentMethodVisibility();
            updateDebtFormVisibility();
            updateMoneyType(); // Ensure correct visibility for money type other input

            // Initial render and summary updates for the default active tab
            const activeTab = document.querySelector('.tab.active');
            if (activeTab) {
                switchTab(activeTab.getAttribute('onclick').split("'")[1]); // Activate current tab
            } else {
                switchTab('opening'); // Default to opening tab if none is active
            }

            // Ensure the lock screen is displayed correctly on initial load if enabled
            if (isScreenLockEnabled && !permanentlyLocked) {
                showLockScreen("Your application has been locked. Please enter your PIN to continue.");
            } else {
                hideLockScreen(); // Otherwise, ensure it's hidden
            }
        });

        // --- TAB SWITCHING LOGIC ---
        // Switches the active tab and content pane.
        function switchTab(tabId) {
            // Reset active state for all tabs
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
            // Hide all tab content
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));

            // Add 'active' class to the clicked tab and its corresponding content pane
            document.querySelector(`.tab[onclick="switchTab('${tabId}')"]`).classList.add('active');
            document.getElementById(tabId).classList.add('active');

            updateSummariesBasedOnCurrentView(); // Update summaries relevant to the newly active tab
            resetLockTimer(); // Reset the lock timer on tab switch

            // Specifically update UI for the Expenses tab when it becomes active
            if (tabId === 'expense') {
                updateExpenseTabUI(); // Call the dedicated function for Expense tab UI updates
            }
        }

        // --- OPENING BALANCE TAB FUNCTIONS ---
        // Saves the entered opening balances to localStorage.
        function saveOpeningBalances() {
            // Get values, parse them as floats, default to 0 if invalid
            const eMoney = parseFloat(document.getElementById('opening-emoney').value.replace(/,/g, '')) || 0;
            const cash = parseFloat(document.getElementById('opening-cash').value.replace(/,/g, '')) || 0;

            openingBalances = { eMoney, cash }; // Update global state
            try {
                localStorage.setItem('moneyManager_openingBalances', JSON.stringify(openingBalances)); // Save to localStorage
                showToast('Opening balances saved successfully!'); // Success notification
            } catch (e) {
                console.error("Error saving opening balances:", e);
                showToast('Error saving opening balances', 'error');
            }
            updateSummariesBasedOnCurrentView(); // Update the displayed balances
        }

        // --- BACKUP FUNCTIONS ---

        // Generates a backup of all application data into the backup textarea.
        function generateBackup() {
            // Package all relevant data into a single object
            const backupData = {
                transactions: transactions,
                moneyRecords: moneyRecords,
                openingBalances: openingBalances,
                savedOtherTransactionTypes: savedOtherTransactionTypes,
                savedOtherMoneyTypes: savedOtherMoneyTypes,
                tempCommissionData: tempCommissionData,
                debts: debts,
                expenseEntries: expenseEntries,
                savedExpenseCategories: savedExpenseCategories,
                isScreenLockEnabled: isScreenLockEnabled,
                appPIN: settingsPIN,
                permanentlyLocked: permanentlyLocked
            };

            try {
                // Convert object to formatted JSON string and set as textarea value
                document.getElementById('backup-data').value = JSON.stringify(backupData, null, 2);
                showToast('Backup data generated!');
            } catch (e) {
                console.error("Error generating backup data:", e);
                showToast('Error generating backup data', 'error');
            }
        }

        // Restores application data from the backup textarea. Merges data if existing data is present.
        function restoreBackup() {
            // Confirm before proceeding with restoration
            if (!confirm('This action will merge your existing data with the data from the text area. Existing records will be preserved. Continue?')) {
                return; // Cancel if user denies
            }

            try {
                const backupText = document.getElementById('backup-data').value;
                if (!backupText.trim()) {
                    showToast('No backup data found in the text area', 'error');
                    return;
                }

                let backupData;
                try {
                    backupData = JSON.parse(backupText); // Parse the JSON data
                } catch (e) {
                    console.error("Error parsing backup JSON:", e);
                    showToast('Invalid backup data format', 'error');
                    return;
                }

                // Check for essential data fields to ensure valid backup format
                if (backupData.transactions && backupData.moneyRecords && backupData.openingBalances && backupData.debts && backupData.expenseEntries && backupData.savedExpenseCategories) {
                    // --- Merge Data ---
                    // Merge transactions (avoid duplicates by ID)
                    const newTransactions = backupData.transactions.filter(bt => !transactions.some(at => at.id === bt.id));
                    transactions = newTransactions.concat(transactions);

                    // Merge money records (basic check, could be improved with more robust duplicate detection)
                    const newMoneyRecords = backupData.moneyRecords.filter(bmr => !moneyRecords.some(amr => amr.date === bmr.date && amr.amount === bmr.amount && amr.action === bmr.action));
                    moneyRecords = newMoneyRecords.concat(moneyRecords);

                    // Merge opening balances (prioritize backed-up values)
                    if (backupData.openingBalances) {
                        openingBalances = {
                            eMoney: parseFloat(backupData.openingBalances.eMoney) || openingBalances.eMoney,
                            cash: parseFloat(backupData.openingBalances.cash) || openingBalances.cash
                        };
                        // Ensure values are valid numbers
                        if (isNaN(openingBalances.eMoney)) openingBalances.eMoney = 0;
                        if (isNaN(openingBalances.cash)) openingBalances.cash = 0;
                    }

                    // Merge custom types and commission data (prioritize existing, then add new)
                    savedOtherTransactionTypes = { ...backupData.savedOtherTransactionTypes, ...savedOtherTransactionTypes };
                    savedOtherMoneyTypes = { ...backupData.savedOtherMoneyTypes, ...savedOtherMoneyTypes };
                    tempCommissionData = { ...backupData.tempCommissionData, ...tempCommissionData };

                    // Merge debts (avoid duplicates by ID)
                    const newDebts = backupData.debts.filter(bd => !debts.some(ad => ad.id === bd.id));
                    debts = newDebts.concat(debts);

                    // Merge expense entries (avoid duplicates by ID)
                    const newExpenseEntries = backupData.expenseEntries.filter(be => !expenseEntries.some(ae => ae.id === be.id));
                    expenseEntries = newExpenseEntries.concat(expenseEntries);

                    // Merge expense categories
                    savedExpenseCategories = { ...backupData.savedExpenseCategories, ...savedExpenseCategories };

                    // Restore security settings
                    if (backupData.isScreenLockEnabled !== undefined) {
                        isScreenLockEnabled = backupData.isScreenLockEnabled;
                        localStorage.setItem('moneyManager_isScreenLockEnabled', isScreenLockEnabled);
                        document.getElementById('enable-screen-lock').checked = isScreenLockEnabled;
                    }
                    if (backupData.appPIN) {
                        settingsPIN = backupData.appPIN;
                        localStorage.setItem('moneyManager_appPIN', settingsPIN);
                    }
                    if (backupData.permanentlyLocked === true) { // Restore permanent lock only if it was explicitly set to true
                        permanentlyLocked = true;
                        localStorage.setItem('moneyManager_permanentlyLocked', 'true');
                    }


                    try {
                        // Re-save all merged data to localStorage
                        localStorage.setItem('moneyManager_transactions', JSON.stringify(transactions));
                        localStorage.setItem('moneyManager_moneyRecords', JSON.stringify(moneyRecords));
                        localStorage.setItem('moneyManager_openingBalances', JSON.stringify(openingBalances));
                        localStorage.setItem('moneyManager_savedOtherTransactionTypes', JSON.stringify(savedOtherTransactionTypes));
                        localStorage.setItem('moneyManager_savedOtherMoneyTypes', JSON.stringify(savedOtherMoneyTypes));
                        localStorage.setItem('moneyManager_tempCommissionData', JSON.stringify(tempCommissionData));
                        localStorage.setItem('moneyManager_debts', JSON.stringify(debts));
                        localStorage.setItem('moneyManager_expenseEntries', JSON.stringify(expenseEntries));
                        localStorage.setItem('moneyManager_savedExpenseCategories', JSON.stringify(savedExpenseCategories));

                        // Refresh UI elements to reflect merged data
                        updateSummariesBasedOnCurrentView();
                        updateTransactionList();
                        updateMoneyList();
                        renderDebts();
                        populateCustomTypes();
                        populateExpenseCategories();
                        renderExpenseEntries();

                        // Update opening balance input fields
                        document.getElementById('opening-emoney').value = openingBalances.eMoney !== undefined ? formatNumber(openingBalances.eMoney) : '';
                        document.getElementById('opening-cash').value = openingBalances.cash !== undefined ? formatNumber(openingBalances.cash) : '';

                        // Re-initialize lock screen based on restored settings
                        initializeLockScreen();

                        showToast('Data merged successfully from text!'); // Success notification
                    } catch (e) {
                        console.error("Error saving merged data to localStorage:", e);
                        showToast('Error saving merged data', 'error');
                    }
                } else {
                    // Error if backup data is missing essential fields
                    showToast('Invalid backup data format (missing essential fields)', 'error');
                }
            } catch (e) {
                console.error("An unexpected error occurred during text restore:", e);
                showToast('An unexpected error occurred during restore', 'error');
            }
        }

        // Generates a backup of all application data into a JSON file and prompts the user to download it.
        function generateBackupFile() {
            // Package all relevant data into an object
            const backupData = {
                transactions: transactions,
                moneyRecords: moneyRecords,
                openingBalances: openingBalances,
                savedOtherTransactionTypes: savedOtherTransactionTypes,
                savedOtherMoneyTypes: savedOtherMoneyTypes,
                tempCommissionData: tempCommissionData,
                debts: debts,
                expenseEntries: expenseEntries,
                savedExpenseCategories: savedExpenseCategories,
                isScreenLockEnabled: isScreenLockEnabled,
                appPIN: settingsPIN,
                permanentlyLocked: permanentlyLocked
            };

            const dataStr = JSON.stringify(backupData, null, 2); // Format as JSON string
            const blob = new Blob([dataStr], { type: 'application/json' }); // Create a Blob object
            const url = URL.createObjectURL(blob); // Create a URL for the Blob

            // Create a temporary link element to trigger the download
            const link = document.createElement('a');
            link.href = url;
            link.download = `MoneyManager_Backup_${new Date().toISOString().split('T')[0]}.json`; // Set filename
            document.body.appendChild(link);
            link.click(); // Programmatically click the link to start download

            URL.revokeObjectURL(url); // Clean up the object URL
            link.remove(); // Remove the temporary link element
            showToast('Backup file generated!');
        }

        // Restores application data from a selected JSON file uploaded by the user.
        function restoreFromFile(event) {
            const file = event.target.files[0]; // Get the uploaded file
            if (!file) {
                return; // Exit if no file selected
            }

            // Validate file type
            if (file.type !== 'application/json' && !file.name.toLowerCase().endsWith('.json')) {
                showToast('Invalid file type. Please select a .json file.', 'error');
                event.target.value = ''; // Clear the file input
                return;
            }

            // Confirm restoration before proceeding
            if (!confirm(`This action will merge your existing data with the data from "${file.name}". Existing records will be preserved. Continue?`)) {
                event.target.value = ''; // Clear input if user cancels
                return;
            }

            const reader = new FileReader(); // Create a FileReader to read the file content
            reader.onload = function(e) { // Callback when file is successfully read
                try {
                    const backupData = JSON.parse(e.target.result); // Parse the file content as JSON

                    // Check for essential data fields
                    if (backupData.transactions && backupData.moneyRecords && backupData.openingBalances && backupData.debts && backupData.expenseEntries && backupData.savedExpenseCategories) {
                        // --- Merge Data ---
                        // Merge transactions
                        const newTransactions = backupData.transactions.filter(bt => !transactions.some(at => at.id === bt.id));
                        transactions = newTransactions.concat(transactions);

                        // Merge money records
                        const newMoneyRecords = backupData.moneyRecords.filter(bmr => !moneyRecords.some(amr => amr.date === bmr.date && amr.amount === bmr.amount && amr.action === bmr.action));
                        moneyRecords = newMoneyRecords.concat(moneyRecords);

                        // Merge opening balances
                        if (backupData.openingBalances) {
                            openingBalances = {
                                eMoney: parseFloat(backupData.openingBalances.eMoney) || openingBalances.eMoney,
                                cash: parseFloat(backupData.openingBalances.cash) || openingBalances.cash
                            };
                            if (isNaN(openingBalances.eMoney)) openingBalances.eMoney = 0;
                            if (isNaN(openingBalances.cash)) openingBalances.cash = 0;
                        }

                        // Merge custom types and commission data
                        savedOtherTransactionTypes = { ...backupData.savedOtherTransactionTypes, ...savedOtherTransactionTypes };
                        savedOtherMoneyTypes = { ...backupData.savedOtherMoneyTypes, ...savedOtherMoneyTypes };
                        tempCommissionData = { ...backupData.tempCommissionData, ...tempCommissionData };

                        // Merge debts
                        const newDebts = backupData.debts.filter(bd => !debts.some(ad => ad.id === bd.id));
                        debts = newDebts.concat(debts);

                        // Merge expense entries
                        const newExpenseEntries = backupData.expenseEntries.filter(be => !expenseEntries.some(ae => ae.id === be.id));
                        expenseEntries = newExpenseEntries.concat(expenseEntries);

                        // Merge expense categories
                        savedExpenseCategories = { ...backupData.savedExpenseCategories, ...savedExpenseCategories };

                        // Restore security settings
                        if (backupData.isScreenLockEnabled !== undefined) {
                            isScreenLockEnabled = backupData.isScreenLockEnabled;
                            localStorage.setItem('moneyManager_isScreenLockEnabled', isScreenLockEnabled);
                            document.getElementById('enable-screen-lock').checked = isScreenLockEnabled;
                        }
                        if (backupData.appPIN) {
                            settingsPIN = backupData.appPIN;
                            localStorage.setItem('moneyManager_appPIN', settingsPIN);
                        }
                        if (backupData.permanentlyLocked === true) {
                            permanentlyLocked = true;
                            localStorage.setItem('moneyManager_permanentlyLocked', 'true');
                        }


                        try {
                            // Re-save all merged data
                            localStorage.setItem('moneyManager_transactions', JSON.stringify(transactions));
                            localStorage.setItem('moneyManager_moneyRecords', JSON.stringify(moneyRecords));
                            localStorage.setItem('moneyManager_openingBalances', JSON.stringify(openingBalances));
                            localStorage.setItem('moneyManager_savedOtherTransactionTypes', JSON.stringify(savedOtherTransactionTypes));
                            localStorage.setItem('moneyManager_savedOtherMoneyTypes', JSON.stringify(savedOtherMoneyTypes));
                            localStorage.setItem('moneyManager_tempCommissionData', JSON.stringify(tempCommissionData));
                            localStorage.setItem('moneyManager_debts', JSON.stringify(debts));
                            localStorage.setItem('moneyManager_expenseEntries', JSON.stringify(expenseEntries));
                            localStorage.setItem('moneyManager_savedExpenseCategories', JSON.stringify(savedExpenseCategories));

                            // Refresh UI
                            updateSummariesBasedOnCurrentView();
                            updateTransactionList();
                            updateMoneyList();
                            renderDebts();
                            populateCustomTypes();
                            populateExpenseCategories();
                            renderExpenseEntries();

                            // Update opening balance fields
                            document.getElementById('opening-emoney').value = openingBalances.eMoney !== undefined ? formatNumber(openingBalances.eMoney) : '';
                            document.getElementById('opening-cash').value = openingBalances.cash !== undefined ? formatNumber(openingBalances.cash) : '';

                            // Re-initialize lock screen based on restored settings
                            initializeLockScreen();

                            showToast('Data merged successfully from file!');
                        } catch (e) {
                            console.error("Error saving merged data from file to localStorage:", e);
                            showToast('Error saving merged data from file', 'error');
                        }
                    } else {
                        showToast('Invalid backup file format (missing essential fields)', 'error');
                    }
                } catch (e) {
                    console.error("Error parsing backup file:", e);
                    showToast('Error reading or parsing backup file', 'error');
                } finally {
                    event.target.value = ''; // Clear the file input value
                }
            };

            reader.onerror = function() { // Handle file reading errors
                console.error("Error reading file:", reader.error);
                showToast('Error reading file', 'error');
                event.target.value = ''; // Clear the file input
            };

            reader.readAsText(file); // Start reading the file as text
        }


        // --- TRANSACTION TAB FUNCTIONS ---

        // Updates the visibility of the 'Other (Manual)' input for transaction types based on the select value.
        function updateTransactionType() {
            const typeSelect = document.getElementById('transaction-type');
            const otherInput = document.getElementById('transaction-type-other');

            if (typeSelect.value === 'other') {
                otherInput.style.display = 'block'; // Show input
                // Only focus if the input is currently hidden
                if (otherInput.style.display === 'block' && document.activeElement !== otherInput) {
                    otherInput.focus(); // Focus on the input field
                }
            } else {
                otherInput.style.display = 'none'; // Hide input
                otherInput.value = ''; // Clear its value
            }
            updateSavedCommissionAndFee(); // Recalculate potential auto-filled commission/fee
        }

        // Attempts to auto-fill commission and fee fields based on previously saved data
        // tied to specific transaction types, actions, and amounts.
        function updateSavedCommissionAndFee() {
            const type = document.getElementById('transaction-type').value;
            const typeOtherInput = document.getElementById('transaction-type-other');
            const typeOther = typeOtherInput.value.trim();
            // Determine the effective type for lookup (custom type or selected type)
            const effectiveType = (type === 'other' && typeOther) ? typeOther : type;

            const action = document.getElementById('transaction-action').value;
            const amountInput = document.getElementById('transaction-amount');
            const amount = parseFloat(amountInput.value.replace(/,/g, '')) || 0; // Get amount, default to 0

            // Check if the necessary fields are filled for a valid lookup
            if (effectiveType && action && amount > 0) {
                const key = `${effectiveType}-${action}-${amount}`; // Create lookup key
                const savedData = tempCommissionData[key]; // Get saved data for this key

                if (savedData) {
                    // Auto-fill commission if the field is empty or currently zero
                    if (document.getElementById('transaction-commission').value === '' || parseFloat(document.getElementById('transaction-commission').value.replace(/,/g, '')) === 0) {
                        document.getElementById('transaction-commission').value = savedData.commission !== undefined && savedData.commission !== null ? formatNumber(savedData.commission) : '';
                    }
                    // Auto-fill fee if the field is empty or currently zero
                    if (document.getElementById('transaction-fee').value === '' || parseFloat(document.getElementById('transaction-fee').value.replace(/,/g, '')) === 0) {
                         document.getElementById('transaction-fee').value = savedData.fee !== undefined && savedData.fee !== null ? formatNumber(savedData.fee) : '';
                    }
                } else {
                    // Clear fields if no matching saved data is found and they are currently empty
                    if (document.getElementById('transaction-commission').value === '') document.getElementById('transaction-commission').value = '';
                    if (document.getElementById('transaction-fee').value === '') document.getElementById('transaction-fee').value = '';
                }
            } else {
                // Clear fields if basic requirements (type, action, amount) are not met
                if (document.getElementById('transaction-commission').value === '') document.getElementById('transaction-commission').value = '';
                if (document.getElementById('transaction-fee').value === '') document.getElementById('transaction-fee').value = '';
            }
        }

        // Saves commission and fee data associated with a specific transaction type, action, and amount
        // This data is stored temporarily for auto-filling later.
        function saveCommissionAndFee(type, action, amount, commission, fee) {
            // Only save if type, action, amount, commission, and fee are valid
            if (type && action && !isNaN(amount) && amount > 0 && !isNaN(commission) && !isNaN(fee)) {
                const key = `${type}-${action}-${amount}`; // Create a unique key
                // Save only if the data is new or has changed
                if (!tempCommissionData[key] || tempCommissionData[key].commission !== commission || tempCommissionData[key].fee !== fee) {
                    tempCommissionData[key] = { commission, fee }; // Store commission and fee
                    try {
                        localStorage.setItem('moneyManager_tempCommissionData', JSON.stringify(tempCommissionData)); // Save to localStorage
                    } catch (e) { console.error("Error saving tempCommissionData:", e); }
                }
            }
        }

        // Captures current values from the transaction form (amount, commission, fee)
        // to potentially save them for future auto-filling via `saveCommissionAndFee`.
        function saveFeeTemporarily() {
            const type = document.getElementById('transaction-type').value;
            const typeOtherInput = document.getElementById('transaction-type-other');
            const typeOther = typeOtherInput.value.trim();
            const effectiveType = (type === 'other' && typeOther) ? typeOther : type; // Get effective type

            const action = document.getElementById('transaction-action').value;
            const amountStr = document.getElementById('transaction-amount').value;
            const amount = parseFloat(amountStr.replace(/,/g, '')); // Parse amount

            const commissionStr = document.getElementById('transaction-commission').value;
            const commission = commissionStr ? parseFloat(commissionStr.replace(/,/g, '')) : 0; // Parse commission, default to 0

            const feeStr = document.getElementById('transaction-fee').value;
            const fee = feeStr ? parseFloat(feeStr.replace(/,/g, '')) : 0; // Parse fee, default to 0

            // Call saveCommissionAndFee if the data is valid
            if (effectiveType && action && !isNaN(amount) && amount > 0 && !isNaN(commission) && !isNaN(fee)) {
                saveCommissionAndFee(effectiveType, action, amount, commission, fee);
            }
        }

        // Adds a new transaction to the `transactions` array based on the form input.
        function addTransaction() {
            const id = document.getElementById('transaction-id').value.trim(); // Get Transaction ID
            const date = document.getElementById('transaction-date').value; // Get Date/Time
            let type = document.getElementById('transaction-type').value; // Get Transaction Type
            const otherInput = document.getElementById('transaction-type-other'); // Get 'Other' input element

            let effectiveType = type;
            let finalType = type;
            // Handle 'Other' transaction type
            if (type === 'other') {
                const customType = otherInput.value.trim();
                if (!customType) { // Validate custom type input
                    showToast('Please specify the other transaction type', 'error');
                    return;
                }
                finalType = customType; // Use custom type for the record
                effectiveType = customType; // Use custom type for saving commission data
                // Save the custom type if it's new
                if (!savedOtherTransactionTypes[finalType]) {
                    savedOtherTransactionTypes[finalType] = finalType;
                    try {
                        localStorage.setItem('moneyManager_savedOtherTransactionTypes', JSON.stringify(savedOtherTransactionTypes));
                    } catch (e) { console.error("Error saving custom transaction type:", e); }
                    addOptionToSelect('transaction-type', finalType); // Add it to the dropdown
                }
            }

            const action = document.getElementById('transaction-action').value; // Get Action
            const amount = parseFloat(document.getElementById('transaction-amount').value.replace(/,/g, '')); // Get and parse Amount
            const commissionInput = document.getElementById('transaction-commission');
            const commission = commissionInput.value ? parseFloat(commissionInput.value.replace(/,/g, '')) : 0; // Get and parse Commission
            const feeInput = document.getElementById('transaction-fee');
            const fee = feeInput.value ? parseFloat(feeInput.value.replace(/,/g, '')) : 0; // Get and parse Fee

            let phone = document.getElementById('transaction-phone').value.trim();
            if (phone) phone = '09' + phone; // Prefix phone number with '09' if missing
            const note = document.getElementById('transaction-note').value.trim();

            // --- Input Validation ---
            if (!id) { showToast('Transaction ID is required.', 'error'); return; }
            if (!date) { showToast('Date/Time is required.', 'error'); return; }
            if (!finalType) { showToast('Transaction Type is required.', 'error'); return; }
            if (!action) { showToast('Action is required.', 'error'); return; }
            if (isNaN(amount) || amount <= 0) { showToast('Amount must be a positive number.', 'error'); return; }
            if (isNaN(commission) || commission < 0) { showToast('Commission must be a non-negative number.', 'error'); return; }
            if (isNaN(fee) || fee < 0) { showToast('Fee must be a non-negative number.', 'error'); return; }

            // Check for duplicate Transaction IDs
            if (transactions.some(t => t.id === id)) {
                showToast('Transaction ID already exists. Please use a unique ID.', 'error');
                return;
            }
            // --- End Validation ---

            // Save commission/fee data for potential future auto-filling
            saveCommissionAndFee(effectiveType, action, amount, commission, fee);

            // Create the transaction object
            const transaction = {
                id, date, type: finalType, action, amount, commission, fee, phone, note
            };

            transactions.unshift(transaction); // Add new transaction to the beginning of the array (most recent)

            try {
                localStorage.setItem('moneyManager_transactions', JSON.stringify(transactions)); // Save updated transactions
                showToast('Transaction added successfully!');
            } catch (e) {
                console.error("Error saving transactions:", e);
                showToast('Error saving transaction', 'error');
            }

            updateSummariesBasedOnCurrentView(); // Update daily and overall summaries
            updateTransactionList(); // Re-render the transaction list
            clearTransactionForm(); // Clear the form for the next entry
        }

        // Clears and resets all fields in the transaction form to their default states.
        function clearTransactionForm() {
            document.getElementById('transaction-id').value = ''; // Clear ID
            updateDateTimeFields(); // Reset date/time to current
            document.getElementById('transaction-type').value = 'Wave Money'; // Reset type to default
            document.getElementById('transaction-type-other').value = ''; // Clear 'Other' input
            document.getElementById('transaction-type-other').style.display = 'none'; // Hide 'Other' input
            document.getElementById('transaction-action').value = 'Cash In'; // Reset action to default
            document.getElementById('transaction-amount').value = ''; // Clear amount
            document.getElementById('transaction-commission').value = ''; // Clear commission
            document.getElementById('transaction-fee').value = ''; // Clear fee
            document.getElementById('transaction-phone').value = ''; // Clear phone
            document.getElementById('transaction-note').value = ''; // Clear note

            updateSavedCommissionAndFee(); // Clear any potentially auto-filled commission/fee
        }

        // Updates the displayed balance figures (E-Money, Cash, Total) on the transaction tab.
        // These are running balances calculated from opening balances and all transactions.
        function updateTransactionTabBalances() {
    let currentEMoney = parseFloat(openingBalances.eMoney) || 0;
    let currentCash = parseFloat(openingBalances.cash) || 0;
    let totalCommission = 0;
    let totalFee = 0;

    transactions.forEach(t => {
        const amount = parseFloat(t.amount);
        const commission = parseFloat(t.commission) || 0;
        const fee = parseFloat(t.fee) || 0;

        // Accumulate total commission and fee
        totalCommission += commission;
        totalFee += fee;

        if (t.action === 'Cash In') {
            currentEMoney -= amount;
            currentCash += amount;
        } else if (t.action === 'Cash Out') {
            currentEMoney += amount;
            currentCash -= amount;
        } else if (
            t.action === 'Send Money' ||
            t.action === 'Payment' ||
            t.action === 'Phone Bill'
        ) {
            currentEMoney -= amount;
            currentCash += amount;
        } else if (t.action === 'Received Money') {
            currentEMoney += amount;
            currentCash -= amount;
        }
    });

    // Add commissions to E-Money balance and fees to Cash balance
    currentEMoney += totalCommission;
    currentCash += totalFee;

    document.getElementById('e-money-balance').textContent = formatNumber(currentEMoney);
    document.getElementById('cash-balance').textContent = formatNumber(currentCash);
    document.getElementById('total-balance').textContent = formatNumber(currentEMoney + currentCash);
}

        // Renders the transaction list, grouping transactions by date.
        // Accepts an optional filteredTransactions array to render a subset.
        function updateTransactionList(filteredTransactions = null) {
            const listContainer = document.querySelector('#transaction-list .transaction-list-items');
            const transactionsToShow = filteredTransactions !== null ? filteredTransactions : transactions; // Use filtered or all transactions

            listContainer.innerHTML = ''; // Clear the current list

            if (transactionsToShow.length === 0) {
                // Display 'no data' message if list is empty
                listContainer.innerHTML += '<p class="no-data">No transactions found.</p>';
                return;
            }

            // Group transactions by date for better organization
            const groupedTransactions = {};
            transactionsToShow.forEach((transaction) => { // Iterate through transactions to show
                // Find the index in the original `transactions` array for accurate editing/deleting operations
                const originalIndex = transactions.findIndex(t => t.id === transaction.id && t.date === transaction.date);

                const dateKey = new Date(transaction.date).toISOString().split('T')[0]; // Get date part as YYYY-MM-DD

                // Initialize group if it doesn't exist
                if (!groupedTransactions[dateKey]) {
                    groupedTransactions[dateKey] = {
                        items: [], // Array of transactions for this date
                        details: { emoneyChange: 0, cashChange: 0, totalCommission: 0, totalFee: 0 } // Summary details for the group
                    };
                }
                // Add transaction to its group
                groupedTransactions[dateKey].items.push({ ...transaction, originalIndex: originalIndex });

                // Accumulate summary details for the date group
                const amount = parseFloat(transaction.amount);
                const commission = parseFloat(transaction.commission);
                const fee = parseFloat(transaction.fee);

                // Calculate daily balance changes based on transaction action
                if (transaction.action === 'Cash In') {
                    groupedTransactions[dateKey].details.emoneyChange -= amount; groupedTransactions[dateKey].details.cashChange += amount;
                } else if (transaction.action === 'Cash Out') {
                    groupedTransactions[dateKey].details.emoneyChange += amount; groupedTransactions[dateKey].details.cashChange -= amount;
                } else if (
                    transaction.action === 'Send Money' ||
                    transaction.action === 'Payment' ||
                    transaction.action === 'Phone Bill'
                ) {
                    groupedTransactions[dateKey].details.emoneyChange -= amount;
                    groupedTransactions[dateKey].details.cashChange += amount;
                } else if (transaction.action === 'Received Money') {
                    groupedTransactions[dateKey].details.emoneyChange += amount;
                    groupedTransactions[dateKey].details.cashChange -= amount;
                }
                // Accumulate commission and fee earned today
                groupedTransactions[dateKey].details.totalCommission += commission;
                groupedTransactions[dateKey].details.totalFee += fee;
            });

            const sortedDates = Object.keys(groupedTransactions).sort().reverse(); // Sort dates from newest to oldest

            // Loop through sorted dates and create grouped HTML elements
            for (const dateKey of sortedDates) {
                const groupData = groupedTransactions[dateKey];
                const displayDate = new Date(dateKey).toDateString(); // Format date for display
                const summary = groupData.details;

                const groupElement = document.createElement('div');
                groupElement.className = 'grouped-transaction'; // CSS class for date group

                // Construct the HTML for the group header and details
                groupElement.innerHTML = `
                    <div class="group-header" onclick="toggleGroup(this.parentElement)">
                        <span>${displayDate}</span>
                        <span>E-Chg: ${formatNumber(summary.emoneyChange)} | C-Chg: ${formatNumber(summary.cashChange)} | Comm: ${formatNumber(summary.totalCommission)} | Fee: ${formatNumber(summary.totalFee)}</span>
                    </div>
                    <div class="group-details">
                        ${groupData.items.map(item => {
                            // Determine CSS class for amount color based on action
                            const amountClass = (item.action === 'Cash In' || item.action === 'Received Money') ? 'positive' : 'negative';
                            // Build details HTML (commission, fee, phone, truncated note)
                            let detailsHtml = '';
                            if (item.commission > 0) detailsHtml += `<span class="transaction-info-item"><strong>Comm:</strong> ${formatNumber(item.commission)}</span>`;
                            if (item.fee > 0) detailsHtml += `<span class="transaction-info-item"><strong>Fee:</strong> ${formatNumber(item.fee)}</span>`;
                            if (item.phone) detailsHtml += `<span class="transaction-info-item"><strong>Phone:</strong> ${item.phone}</span>`;
                            if (item.note) {
                                const truncatedNote = item.note.length > 50 ? item.note.substring(0, 50) + '...' : item.note;
                                detailsHtml += `<span class="transaction-info-item"><strong>Note:</strong> ${truncatedNote}</span>`;
                            }

                            return `
                                <div class="transaction-item">
                                    <div class="transaction-header">
                                        <span class="transaction-type">${item.type} - ${item.action}</span>
                                        <span class="transaction-amount ${amountClass}">${formatNumber(item.amount)}</span>
                                    </div>
                                    <div class="transaction-details-mobile">
                                        <span class="transaction-date">${new Date(item.date).toLocaleTimeString()}</span>
                                        <span class="transaction-info-item"><strong>ID:</strong> ${item.id}</span>
                                        ${detailsHtml}
                                    </div>
                                    <div class="transaction-actions">
                                        <button class="action-button-text edit" onclick="editTransaction(${item.originalIndex})"><i class="fas fa-edit"></i></button>
                                        <button class="action-button-text delete" onclick="deleteTransaction(${item.originalIndex})"><i class="fas fa-trash-alt"></i></button>
                                    </div>
                                </div>
                            `;
                        }).join('')}
                    </div>
                `;
                listContainer.appendChild(groupElement); // Add the completed group element to the list
            }
        }

        // Loads a specific transaction into the form fields for editing.
        function editTransaction(index) {
            if (index < 0 || index >= transactions.length) {
                console.error("Invalid index for editTransaction:", index);
                showToast("Error loading transaction for editing.", "error");
                return;
            }
            const transaction = transactions[index]; // Get the transaction object

            // Populate form fields with transaction data
            document.getElementById('transaction-id').value = transaction.id;
            document.getElementById('transaction-date').value = transaction.date;

            const typeSelect = document.getElementById('transaction-type');
            const otherInput = document.getElementById('transaction-type-other');

            // Check if the transaction type is custom or not a predefined option
            if (transaction.type && transaction.type.trim() !== '' && savedOtherTransactionTypes[transaction.type] || !Array.from(typeSelect.options).some(opt => opt.value === transaction.type)) {
                typeSelect.value = 'other'; // Set select to 'Other'
                otherInput.value = transaction.type; // Set 'Other' input to the custom type
                otherInput.style.display = 'block'; // Show the 'Other' input
                // Save the custom type if it's new
                if (!savedOtherTransactionTypes[transaction.type]) {
                    savedOtherTransactionTypes[transaction.type] = transaction.type;
                    try {
                        localStorage.setItem('moneyManager_savedOtherTransactionTypes', JSON.stringify(savedOtherTransactionTypes));
                    } catch (e) { console.error("Error saving custom transaction type during edit:", e); }
                    addOptionToSelect('transaction-type', transaction.type); // Add to dropdown
                }
            } else if (transaction.type) {
                // If it's a predefined type, set it directly
                typeSelect.value = transaction.type;
                otherInput.style.display = 'none'; // Hide 'Other' input
                otherInput.value = '';
            } else { // Fallback if type is missing
                typeSelect.value = 'Wave Money'; // Default to a common type
                otherInput.style.display = 'none';
                otherInput.value = '';
            }

            document.getElementById('transaction-action').value = transaction.action;
            document.getElementById('transaction-amount').value = formatNumber(transaction.amount);
            document.getElementById('transaction-commission').value = transaction.commission ? formatNumber(transaction.commission) : '';
            document.getElementById('transaction-fee').value = transaction.fee ? formatNumber(transaction.fee) : '';

            // Format phone number for input (remove '09' prefix if present)
            if (transaction.phone && transaction.phone.startsWith('09')) {
                document.getElementById('transaction-phone').value = transaction.phone.substring(2);
            } else {
                document.getElementById('transaction-phone').value = transaction.phone || '';
            }

            document.getElementById('transaction-note').value = transaction.note || '';

            // Remove the transaction from the array to prevent duplication before editing
            transactions.splice(index, 1);
            updateSummariesBasedOnCurrentView(); // Update summaries after removal
            updateTransactionList(); // Re-render the list without the item being edited
            showToast('Transaction loaded for editing');
            window.scrollTo(0, 0); // Scroll to top to focus on the form
        }

        // Deletes a transaction at the specified index from the `transactions` array.
        function deleteTransaction(index) {
            if (index < 0 || index >= transactions.length) {
                console.error("Invalid index for deleteTransaction:", index);
                showToast("Error deleting transaction.", "error");
                return;
            }

            // Confirm deletion with the user
            if (confirm('Are you sure you want to delete this transaction? This action cannot be undone.')) {
                transactions.splice(index, 1); // Remove the transaction from the array

                try {
                    localStorage.setItem('moneyManager_transactions', JSON.stringify(transactions)); // Save changes
                    showToast('Transaction deleted successfully');
                } catch (e) {
                    console.error("Error saving transactions after delete:", e);
                    showToast('Error saving changes after deletion', 'error');
                }

                updateSummariesBasedOnCurrentView(); // Update summaries
                updateTransactionList(); // Re-render the list
            }
        }

        // Filters the transaction list based on the selected criteria in the filter section.
        function filterTransactions() {
            const typeFilter = document.getElementById('transaction-filter-type').value; // Get selected type
            const actionFilter = document.getElementById('transaction-filter-action').value; // Get selected action
            const dateFilterValue = document.getElementById('transaction-filter-date').value; // Get selected date

            let filtered = transactions; // Start with all transactions

            // Apply type filter if not 'all'
            if (typeFilter !== 'all') {
                filtered = filtered.filter(t => t.type === typeFilter);
            }

            // Apply action filter if not 'all'
            if (actionFilter !== 'all') {
                filtered = filtered.filter(t => t.action === actionFilter);
            }

            // Apply date filter
            if (dateFilterValue) {
                try {
                    const filterDate = new Date(dateFilterValue);
                    filterDate.setHours(0, 0, 0, 0); // Normalize date to start of day

                    filtered = filtered.filter(t => {
                        const transactionDateTime = new Date(t.date);
                        if (isNaN(transactionDateTime.getTime())) return false; // Skip invalid dates
                        // Compare year, month, and day
                        return transactionDateTime.getFullYear() === filterDate.getFullYear() &&
                               transactionDateTime.getMonth() === filterDate.getMonth() &&
                               transactionDateTime.getDate() === filterDate.getDate();
                    });
                } catch (e) {
                    console.error("Error applying date filter:", e);
                    showToast("Error applying date filter.", "error");
                    filtered = []; // Clear filtered list on error
                }
            }

            currentFilteredTransactions = filtered; // Store filtered list for summary updates
            updateTransactionList(filtered); // Render the filtered list
            updateSummariesBasedOnCurrentView(); // Update summaries based on the filtered view
        }

        // Resets all transaction filters to their default values and re-renders the full list.
        function resetTransactionFilters() {
            document.getElementById('transaction-filter-type').value = 'all';
            document.getElementById('transaction-filter-action').value = 'all';
            document.getElementById('transaction-filter-date').value = '';
            currentFilteredTransactions = []; // Clear the stored filtered list
            updateTransactionList(); // Show all transactions
            updateSummariesBasedOnCurrentView(); // Update summaries based on all data
        }

        // --- DAILY MONEY TAB FUNCTIONS ---

        // Toggles the visibility of the commission percentage input field based on the 'Action'.
        function toggleCommissionField() {
            const action = document.getElementById('money-action').value;
            const commissionGroup = document.getElementById('money-commission-group');

            if (action === 'Emoney In') {
                commissionGroup.style.display = 'block'; // Show commission field
            } else {
                commissionGroup.style.display = 'none'; // Hide commission field
                document.getElementById('money-commission').value = ''; // Clear its value
            }
        }

        // Calculates and formats the commission percentage input field.
        function calculateMoneyCommission() {
            const action = document.getElementById('money-action').value;
            const commissionPercentInput = document.getElementById('money-commission');
            const commissionGroup = document.getElementById('money-commission-group');

            if (action === 'Emoney In') {
                commissionGroup.style.display = 'block'; // Show field if action is 'Emoney In'
                let currentValue = commissionPercentInput.value;
                let cleanedValue = '';
                let dotFound = false;
                // Clean the input to allow only digits and one decimal point
                for (let i = 0; i < currentValue.length; i++) {
                    const char = currentValue[i];
                    if (char >= '0' && char <= '9') {
                        cleanedValue += char;
                    } else if (char === '.' && !dotFound) {
                        cleanedValue += '.';
                        dotFound = true;
                    }
                }
                commissionPercentInput.value = cleanedValue; // Apply cleaned value
            } else {
                 commissionPercentInput.value = ''; // Clear value if not 'Emoney In'
                 commissionGroup.style.display = 'none'; // Hide field
            }
        }

        // Updates the visibility of the 'Other (Manual)' input for money record types.
        function updateMoneyType() {
            const typeSelect = document.getElementById('money-type');
            const otherInput = document.getElementById('money-type-other');

            if (typeSelect.value === 'other') {
                otherInput.style.display = 'block'; // Show input
                // Only focus if the input is currently hidden
                if (otherInput.style.display === 'block' && document.activeElement !== otherInput) {
                    otherInput.focus(); // Focus on the input
                }
            } else {
                otherInput.style.display = 'none'; // Hide input
                otherInput.value = ''; // Clear value
            }
        }

        // Adds a new money record to the `moneyRecords` array based on the form input.
        function addMoneyRecord() {
            const date = document.getElementById('money-date').value; // Get Date/Time
            const amount = parseFloat(document.getElementById('money-amount').value.replace(/,/g, '')); // Get and parse Amount
            const action = document.getElementById('money-action').value; // Get Action
            let type = document.getElementById('money-type').value; // Get Type
            const otherInput = document.getElementById('money-type-other'); // Get 'Other' input element

            let finalType = type;
            // Handle 'Other' type input
            if (type === 'other') {
                const customType = otherInput.value.trim();
                if (!customType) { // Validate custom type
                    showToast('Please specify the other money record type', 'error');
                    return;
                }
                finalType = customType; // Use custom type for the record
                // Save the custom type if it's new
                if (!savedOtherMoneyTypes[finalType]) {
                    savedOtherMoneyTypes[finalType] = finalType;
                    try {
                        localStorage.setItem('moneyManager_savedOtherMoneyTypes', JSON.stringify(savedOtherMoneyTypes));
                    } catch (e) { console.error("Error saving custom money type:", e); }
                    addOptionToSelect('money-type', finalType); // Add to dropdown
                }
            }

            // Calculate actual commission if applicable (only for 'Emoney In')
            const commissionPercentage = parseFloat(document.getElementById('money-commission').value.replace(/,/g, ''));
            let actualCommission = 0;
            if (action === 'Emoney In' && !isNaN(amount) && amount > 0 && !isNaN(commissionPercentage) && commissionPercentage >= 0) {
                actualCommission = (amount * commissionPercentage) / 100; // Calculate commission amount
            }

            const note = document.getElementById('money-note').value.trim(); // Get Note

            // --- Input Validation ---
            if (!date) { showToast('Date/Time is required.', 'error'); return; }
            if (!finalType) { showToast('Type is required.', 'error'); return; }
            if (isNaN(amount) || amount <= 0) { showToast('Amount must be a positive number.', 'error'); return; }
            // --- End Validation ---

            // Create the money record object
            const record = {
                date, amount, action, type: finalType, commission: actualCommission, note
            };

            moneyRecords.unshift(record); // Add to the beginning of the array (most recent)
            // Optional: Limit the number of records to maintain performance
            // if (moneyRecords.length > 1000) {
            //     moneyRecords.length = 1000;
            // }

            try {
                localStorage.setItem('moneyManager_moneyRecords', JSON.stringify(moneyRecords)); // Save updated records
                showToast('Money record added successfully!');
            } catch (e) {
                console.error("Error saving money records:", e);
                showToast('Error saving money record', 'error');
            }

            updateSummariesBasedOnCurrentView(); // Update summaries
            updateMoneyList(); // Re-render the money records list
            clearMoneyForm(); // Clear the form
        }

        // Clears and resets all fields in the money record form to their default states.
        function clearMoneyForm() {
            document.getElementById('money-amount').value = ''; // Clear amount
            document.getElementById('money-action').value = 'Emoney In'; // Reset action to default
            document.getElementById('money-type').value = 'Wave Money'; // Reset type to default
            document.getElementById('money-type-other').value = ''; // Clear 'Other' input
            document.getElementById('money-type-other').style.display = 'none'; // Hide 'Other' input
            document.getElementById('money-commission').value = ''; // Clear commission
            document.getElementById('money-commission-group').style.display = 'none'; // Hide commission field
            document.getElementById('money-note').value = ''; // Clear note
            updateDateTimeFields(); // Reset date/time to current
        }

        // Renders the money records list, grouping them by date.
        // Accepts an optional filteredRecords array to render a subset.
        function updateMoneyList(filteredRecords = null) {
            const listContainer = document.querySelector('#money-list .transaction-list-items');
            const recordsToShow = filteredRecords !== null ? filteredRecords : moneyRecords; // Use filtered or all records

            listContainer.innerHTML = ''; // Clear the current list

            if (recordsToShow.length === 0) {
                // Display 'no data' message if the list is empty
                listContainer.innerHTML += '<p class="no-data">No money records found.</p>';
                return;
            }

            // Group records by date for organization
            const groupedRecords = {};
            recordsToShow.forEach((record) => { // Iterate through records to show
                const dateKey = new Date(record.date).toISOString().split('T')[0]; // Group by date
                // Find the original index in the `moneyRecords` array for accurate editing/deleting
                const originalIndex = moneyRecords.findIndex(r => r.date === record.date && r.amount === record.amount && r.action === record.action); // Use multiple fields for finding index
                if (!groupedRecords[dateKey]) {
                    // Initialize group if it doesn't exist
                    groupedRecords[dateKey] = {
                        items: [], // Array of records for this date
                        details: { emoneyIn: 0, emoneyOut: 0, cashIn: 0, cashOut: 0, commission: 0 } // Summary details for the group
                    };
                }
                groupedRecords[dateKey].items.push({ ...record, originalIndex: originalIndex }); // Add record with original index
                // Accumulate summary details for the date group
                const recordAmount = parseFloat(record.amount);
                if (record.action === 'Emoney In') {
                    groupedRecords[dateKey].details.emoneyIn += recordAmount;
                    groupedRecords[dateKey].details.commission += parseFloat(record.commission); // Sum commission
                } else if (record.action === 'Emoney Out') {
                    groupedRecords[dateKey].details.emoneyOut += recordAmount;
                } else if (record.action === 'Cash In') {
                    groupedRecords[dateKey].details.cashIn += recordAmount;
                } else if (record.action === 'Cash Out') {
                    groupedRecords[dateKey].details.cashOut += recordAmount;
                }
            });

            const sortedDates = Object.keys(groupedRecords).sort().reverse(); // Sort dates newest first

            // Loop through sorted dates and create grouped HTML elements
            for (const dateKey of sortedDates) {
                const groupData = groupedRecords[dateKey];
                const displayDate = new Date(dateKey).toDateString(); // Format date for display
                const summary = groupData.details;

                const groupElement = document.createElement('div');
                groupElement.className = 'grouped-transaction'; // CSS class for date group

                // Construct the HTML for the group header and details
                groupElement.innerHTML = `
                    <div class="group-header" onclick="toggleGroup(this.parentElement)">
                        <span>${displayDate}</span>
                        <span>E-In: ${formatNumber(summary.emoneyIn)} | E-Out: ${formatNumber(summary.emoneyOut)} | C-In: ${formatNumber(summary.cashIn)} | C-Out: ${formatNumber(summary.cashOut)}</span>
                    </div>
                    <div class="group-details">
                        ${groupData.items.map(item => {
                            // Build details HTML (commission, note)
                            let detailsHtml = '';
                            if (item.commission > 0) detailsHtml += `<span class="transaction-info-item"><strong>Comm:</strong> ${formatNumber(item.commission)}</span>`;
                            if (item.note) {
                                const truncatedNote = item.note.length > 50 ? item.note.substring(0, 50) + '...' : item.note;
                                detailsHtml += `<span class="transaction-info-item"><strong>Note:</strong> ${truncatedNote}</span>`;
                            }
                            return `
                                <div class="transaction-item">
                                    <div class="transaction-header">
                                        <span class="transaction-type">${item.type}</span>
                                        <span class="transaction-amount">${formatNumber(item.amount)}</span>
                                    </div>
                                    <div class="transaction-details-mobile">
                                        <span class="transaction-date">${new Date(item.date).toLocaleTimeString()}</span>
                                        <span class="transaction-info-item"><strong>Action:</strong> ${item.action}</span>
                                        ${detailsHtml}
                                    </div>
                                    <div class="transaction-actions">
                                        <button class="action-button-text edit" onclick="editMoneyRecord(${item.originalIndex})"><i class="fas fa-edit"></i></button>
                                        <button class="action-button-text delete" onclick="deleteMoneyRecord(${item.originalIndex})"><i class="fas fa-trash-alt"></i></button>
                                    </div>
                                </div>
                            `;
                        }).join('')}
                    </div>
                `;
                listContainer.appendChild(groupElement); // Add the completed group element to the list
            }
        }

        // Loads a specific money record into the form fields for editing.
        function editMoneyRecord(index) {
            if (index < 0 || index >= moneyRecords.length) {
                console.error("Invalid index for editMoneyRecord:", index);
                showToast("Error loading money record for editing.", "error");
                return;
            }
            const record = moneyRecords[index]; // Get the record object

            // Populate form fields
            document.getElementById('money-date').value = record.date;
            document.getElementById('money-amount').value = formatNumber(record.amount);
            document.getElementById('money-action').value = record.action;

            const typeSelect = document.getElementById('money-type');
            const otherInput = document.getElementById('money-type-other');

            // Check if the type is custom or not a predefined option
            if (record.type && record.type.trim() !== '' && savedOtherMoneyTypes[record.type] || !Array.from(typeSelect.options).some(opt => opt.value === record.type)) {
                typeSelect.value = 'other'; // Set select to 'Other'
                otherInput.value = record.type; // Set 'Other' input to the custom type
                otherInput.style.display = 'block'; // Show 'Other' input
                // Save the custom type if it's new
                if (!savedOtherMoneyTypes[record.type]) {
                    savedOtherMoneyTypes[record.type] = record.type;
                    try {
                        localStorage.setItem('moneyManager_savedOtherMoneyTypes', JSON.stringify(savedOtherMoneyTypes));
                    } catch (e) { console.error("Error saving custom money type during edit:", e); }
                    addOptionToSelect('money-type', record.type); // Add to dropdown
                }
            } else if (record.type) {
                // If it's a predefined type, set it directly
                typeSelect.value = record.type;
                otherInput.style.display = 'none';
                otherInput.value = '';
            } else { // Fallback if type is missing
                typeSelect.value = 'Wave Money';
                otherInput.style.display = 'none';
                otherInput.value = '';
            }

            toggleCommissionField(); // Show/hide commission field based on action
            if (record.action === 'Emoney In') {
                document.getElementById('money-commission').value = record.commission ? formatNumber(record.commission) : '';
            } else {
                document.getElementById('money-commission').value = '';
            }

            document.getElementById('money-note').value = record.note || ''; // Populate note

            // Remove the record from the array to avoid duplication before editing
            moneyRecords.splice(index, 1);
            updateSummariesBasedOnCurrentView(); // Update summaries
            updateMoneyList(); // Re-render the list
            showToast('Money record loaded for editing');
            window.scrollTo(0, 0); // Scroll to top to focus on the form
        }

        // Deletes a money record at the specified index from the `moneyRecords` array.
        function deleteMoneyRecord(index) {
            if (index < 0 || index >= moneyRecords.length) {
                console.error("Invalid index for deleteMoneyRecord:", index);
                showToast("Error deleting money record.", "error");
                return;
            }

            // Confirm deletion with the user
            if (confirm('Are you sure you want to delete this record? This action cannot be undone.')) {
                moneyRecords.splice(index, 1); // Remove the record

                try {
                    localStorage.setItem('moneyManager_moneyRecords', JSON.stringify(moneyRecords)); // Save changes
                    showToast('Money record deleted successfully');
                } catch (e) {
                    console.error("Error saving money records after delete:", e);
                    showToast('Error saving changes after deletion', 'error');
                }

                updateSummariesBasedOnCurrentView(); // Update summaries
                updateMoneyList(); // Re-render the list
            }
        }

        // Filters the money records list based on the selected criteria in the filter section.
        function filterMoneyRecords() {
            const moneyActionFilter = document.getElementById('money-filter-action').value; // Get selected action filter
            const dateFilterValue = document.getElementById('money-filter-date').value; // Get selected date filter

            let filtered = moneyRecords; // Start with all records

            // Apply action filter if not 'all'
            if (moneyActionFilter !== 'all') {
                filtered = filtered.filter(r => r.action === moneyActionFilter);
            }

            // Apply date filter
            if (dateFilterValue) {
                try {
                    const filterDate = new Date(dateFilterValue);
                    filterDate.setHours(0, 0, 0, 0); // Normalize to start of day

                    filtered = filtered.filter(r => {
                        const recordDateTime = new Date(r.date);
                        if (isNaN(recordDateTime.getTime())) return false; // Skip invalid dates
                        // Compare year, month, and day
                        return recordDateTime.getFullYear() === filterDate.getFullYear() &&
                               recordDateTime.getMonth() === filterDate.getMonth() &&
                               recordDateTime.getDate() === filterDate.getDate();
                    });
                } catch (e) {
                    console.error("Error applying date filter for money records:", e);
                    showToast("Error applying date filter.", "error");
                    filtered = []; // Clear filtered list on error
                }
            }

            updateMoneyList(filtered); // Render the filtered list
            updateSummariesBasedOnCurrentView(); // Update summaries based on the filtered view
        }

        // Resets all money record filters to their default values and re-renders the full list.
        function resetMoneyFilters() {
            document.getElementById('money-filter-action').value = 'all';
            document.getElementById('money-filter-date').value = '';
            updateMoneyList(); // Show all records
            updateSummariesBasedOnCurrentView(); // Update summaries based on all data
        }

        // --- UPDATE DAILY SUMMARIES ---

        // Updates various daily summary calculations for both Transaction and Daily Money tabs.
        // It considers the date filters applied in each tab.
        function updateDailySummaries(transactionsToProcess = null, recordsToSummarize = null) {
            const transactionFilterDateValue = document.getElementById('transaction-filter-date').value;
            const moneyFilterDateValue = document.getElementById('money-filter-date').value;

            let summaryStartDate = null;
            let summaryEndDate = null;

            // Determine the date range for summary calculation.
            // If a date filter is applied in either tab, use that date; otherwise, use today.
            let relevantDateFilterValue = moneyFilterDateValue || transactionFilterDateValue;

            if (relevantDateFilterValue) {
                const filterDate = new Date(relevantDateFilterValue);
                summaryStartDate = new Date(filterDate);
                summaryStartDate.setHours(0, 0, 0, 0); // Start of the day
                summaryEndDate = new Date(filterDate);
                summaryEndDate.setHours(23, 59, 59, 999); // End of the day
            } else {
                // If no date filter is applied, use the current day
                const today = new Date();
                summaryStartDate = new Date(today);
                summaryStartDate.setHours(0, 0, 0, 0);
                summaryEndDate = new Date(today);
                summaryEndDate.setHours(23, 59, 59, 999);
            }

            // --- Transaction Tab Daily Changes Calculation ---
            let dailyEMoneyChangeFromTransactions = 0;
            let dailyCashChangeFromTransactions = 0;
            let totalDailyCommissionFromTransactions = 0;
            let totalDailyFeeFromTransactions = 0;

            // Use the provided transactions data or fall back to the global `transactions` array
            const transactionsData = transactionsToProcess !== null ? transactionsToProcess : transactions;

            // Iterate through transactions to calculate daily changes
            transactionsData.forEach(t => {
                const transactionDateTime = new Date(t.date);
                // Check if the transaction falls within the determined date range
                if (transactionDateTime >= summaryStartDate && transactionDateTime <= summaryEndDate) {
                    const amount = parseFloat(t.amount);
                    const commission = parseFloat(t.commission) || 0; // Ensure commission is a number
                    const fee = parseFloat(t.fee) || 0;           // Ensure fee is a number

                    // Accumulate total commission and fee earned today
                    totalDailyCommissionFromTransactions += commission;
                    totalDailyFeeFromTransactions += fee;

                    // Adjust E-Money and Cash balances based on transaction action
                    if (t.action === 'Cash In') {
                        dailyEMoneyChangeFromTransactions -= amount; // E-Money decreases as cash comes in
                        dailyCashChangeFromTransactions += amount;   // Cash increases
                    } else if (t.action === 'Cash Out') {
                        dailyEMoneyChangeFromTransactions += amount; // E-Money increases as cash goes out
                        dailyCashChangeFromTransactions -= amount;   // Cash decreases
                    } else if (
                        t.action === 'Send Money' ||
                        t.action === 'Payment' ||
                        t.action === 'Phone Bill'
                    ) {
                        dailyEMoneyChangeFromTransactions -= amount; // Deduct amount from E-Money
                        dailyCashChangeFromTransactions += amount;   // Add cash received from E-Money
                    } else if (t.action === 'Received Money') {
                        dailyEMoneyChangeFromTransactions += amount; // Add amount to E-Money
                        dailyCashChangeFromTransactions -= amount;   // Deduct cash that was received via E-Money
                    }
                }
            });

            // Update the transaction tab's daily summary elements
            document.getElementById('daily-e-money').textContent = formatNumber(dailyEMoneyChangeFromTransactions);
            document.getElementById('daily-cash').textContent = formatNumber(dailyCashChangeFromTransactions);
            document.getElementById('total-commission-summary').textContent = formatNumber(totalDailyCommissionFromTransactions);
            document.getElementById('total-fee-summary').textContent = formatNumber(totalDailyFeeFromTransactions);

            // --- Daily Money Tab Specific Summaries Calculation ---
            const dailySummaryForMoneyRecords = {
                emoneyIn: 0, emoneyOut: 0, cashIn: 0, cashOut: 0, commission: 0
            };

            // Use the provided money records data or fall back to the global array
            const moneyRecordsData = recordsToSummarize !== null ? recordsToSummarize : moneyRecords;

            // Iterate through money records to calculate daily summaries
            moneyRecordsData.forEach(r => {
                const recordDateTime = new Date(r.date);
                // Check if the record falls within the determined date range
                if (recordDateTime >= summaryStartDate && recordDateTime <= summaryEndDate) {
                    const recordAmount = parseFloat(r.amount);
                    if (r.action === 'Emoney In') {
                        dailySummaryForMoneyRecords.emoneyIn += recordAmount;
                        dailySummaryForMoneyRecords.commission += parseFloat(r.commission); // Sum commission
                    } else if (r.action === 'Emoney Out') {
                        dailySummaryForMoneyRecords.emoneyOut += recordAmount;
                    } else if (r.action === 'Cash In') {
                        dailySummaryForMoneyRecords.cashIn += recordAmount;
                    } else if (r.action === 'Cash Out') {
                        dailySummaryForMoneyRecords.cashOut += recordAmount;
                    }
                }
            });

            // Update the Daily Money tab's summary elements
            document.getElementById('daily-emoney-in').textContent = formatNumber(dailySummaryForMoneyRecords.emoneyIn);
            document.getElementById('daily-emoney-out').textContent = formatNumber(dailySummaryForMoneyRecords.emoneyOut);
            document.getElementById('daily-cash-in').textContent = formatNumber(dailySummaryForMoneyRecords.cashIn);
            document.getElementById('daily-cash-out').textContent = formatNumber(dailySummaryForMoneyRecords.cashOut);

            // Calculate the net balance change from money records for the day
            let dailyEMoneyBalanceChangeFromMoneyRecords = 0;
            let dailyCashBalanceChangeFromMoneyRecords = 0;

            moneyRecordsData.forEach(r => {
                const recordDateTime = new Date(r.date);
                if (recordDateTime >= summaryStartDate && recordDateTime <= summaryEndDate) {
                    const recordAmount = parseFloat(r.amount);
                    if (r.action === 'Emoney In') {
                        dailyEMoneyBalanceChangeFromMoneyRecords += recordAmount;
                    } else if (r.action === 'Emoney Out') {
                        dailyEMoneyBalanceChangeFromMoneyRecords -= recordAmount;
                    } else if (r.action === 'Cash In') {
                        dailyCashBalanceChangeFromMoneyRecords += recordAmount;
                    } else if (r.action === 'Cash Out') {
                        dailyCashBalanceChangeFromMoneyRecords -= recordAmount;
                    }
                }
            });

            // Calculate and update the net balance change
            const totalDailyRemainingBalance = dailyEMoneyBalanceChangeFromMoneyRecords + dailyCashBalanceChangeFromMoneyRecords;
            document.getElementById('daily-remaining').textContent = formatNumber(totalDailyRemainingBalance);

            // Show/hide the commission summary item based on whether commission exists
            if (dailySummaryForMoneyRecords.commission > 0) {
                document.getElementById('daily-money-commission-item').style.display = 'flex';
                document.getElementById('daily-money-commission').textContent = formatNumber(dailySummaryForMoneyRecords.commission);
            } else {
                document.getElementById('daily-money-commission-item').style.display = 'none';
            }

            // --- Auto-expand summary sections if they contain relevant data ---
            // Transaction Summary Auto-Expand
            const transactionSummarySection = document.getElementById('transaction').querySelector('.summary-section');
            if (transactionSummarySection) {
                const hasTransactionData = (transactionsData.length > 0 || dailyEMoneyChangeFromTransactions !== 0 || dailyCashChangeFromTransactions !== 0 || totalDailyCommissionFromTransactions !== 0 || totalDailyFeeFromTransactions !== 0);
                if (hasTransactionData && !transactionSummarySection.classList.contains('expanded')) {
                     toggleExpand(transactionSummarySection); // Expand if data exists and section is collapsed
                } else if (!hasTransactionData && transactionSummarySection.classList.contains('expanded')) {
                    toggleExpand(transactionSummarySection); // Collapse if no data and section is expanded
                }
            }

            // Daily Money Summary Auto-Expand
            const dailyMoneySummarySection = document.querySelector('#daily-money .summary-section');
            if (dailyMoneySummarySection) {
                const hasMoneyRecordData = (moneyRecordsData.length > 0 || dailySummaryForMoneyRecords.emoneyIn !== 0 || dailySummaryForMoneyRecords.emoneyOut !== 0 || dailySummaryForMoneyRecords.cashIn !== 0 || dailySummaryForMoneyRecords.cashOut !== 0 || dailySummaryForMoneyRecords.commission !== 0);
                if (hasMoneyRecordData && !dailyMoneySummarySection.classList.contains('expanded')) {
                    toggleExpand(dailyMoneySummarySection); // Expand if data exists and section is collapsed
                } else if (!hasMoneyRecordData && dailyMoneySummarySection.classList.contains('expanded')) {
                    toggleExpand(dailyMoneySummarySection); // Collapse if no data and section is expanded
                }
            }
        }

        // Helper function to toggle the expanded/collapsed state of collapsible sections (like summaries).
        function toggleExpand(element) {
            element.classList.toggle('expanded'); // Toggle the 'expanded' class
            const summaryList = element.querySelector('.summary-list');
            if (summaryList) {
                // Control display based on 'expanded' class for smooth transition
                summaryList.style.display = element.classList.contains('expanded') ? 'block' : 'none';
            }
            // Update the arrow icon to indicate the current state
            const arrow = element.querySelector('h2 .arrow');
            if (arrow) {
                arrow.style.transform = element.classList.contains('expanded') ? 'rotate(180deg)' : 'rotate(0deg)';
            }
        }

        // Helper function to ensure summaries are updated correctly, considering current filters applied in the tabs.
        function updateSummariesBasedOnCurrentView() {
            let filteredTransactionsForSummary = transactions;
            const transactionFilterDateValue = document.getElementById('transaction-filter-date').value;
            // If a date filter is active in the Transactions tab, apply it for summary calculations
            if (transactionFilterDateValue) {
                try {
                    const filterDate = new Date(transactionFilterDateValue);
                    filterDate.setHours(0, 0, 0, 0);

                    filteredTransactionsForSummary = transactions.filter(t => {
                        const transactionDateTime = new Date(t.date);
                        if (isNaN(transactionDateTime.getTime())) return false;
                        return transactionDateTime.getFullYear() === filterDate.getFullYear() &&
                               transactionDateTime.getMonth() === filterDate.getMonth() &&
                               transactionDateTime.getDate() === filterDate.getDate();
                    });
                } catch (e) {
                    console.error("Error during transaction filtering for summary update:", e);
                    filteredTransactionsForSummary = [];
                }
            }

            let filteredMoneyRecordsForSummary = moneyRecords;
            const moneyActionFilterValue = document.getElementById('money-filter-action').value;
            const moneyDateFilterValue = document.getElementById('money-filter-date').value;

            // Apply filters active in the Daily Money tab for its summaries
            if (moneyActionFilterValue !== 'all') {
                filteredMoneyRecordsForSummary = filteredMoneyRecordsForSummary.filter(r => r.action === moneyActionFilterValue);
            }
            if (moneyDateFilterValue) {
                try {
                    const filterDate = new Date(moneyDateFilterValue);
                    filterDate.setHours(0, 0, 0, 0);

                    filteredMoneyRecordsForSummary = filteredMoneyRecordsForSummary.filter(r => {
                        const recordDateTime = new Date(r.date);
                        if (isNaN(recordDateTime.getTime())) return false;
                        return recordDateTime.getFullYear() === filterDate.getFullYear() &&
                               recordDateTime.getMonth() === filterDate.getMonth() &&
                               recordDateTime.getDate() === filterDate.getDate();
                    });
                } catch (e) {
                    console.error("Error during money record filtering for summary update:", e);
                    filteredMoneyRecordsForSummary = [];
                }
            }

            // Re-render lists if they are visible and filtered, to ensure the list view matches the summary view
            if (document.getElementById('daily-money').classList.contains('active') && document.getElementById('money-list').classList.contains('expanded')) {
                updateMoneyList(filteredMoneyRecordsForSummary); // Update money list with its filters
            }
            if (document.getElementById('transaction').classList.contains('active') && document.getElementById('transaction-list').classList.contains('expanded')) {
                updateTransactionList(currentFilteredTransactions); // Update transaction list with its filters
            }

            // Update the summary calculations with the appropriately filtered data
            updateDailySummaries(filteredTransactionsForSummary, filteredMoneyRecordsForSummary);
            updateTransactionTabBalances(); // Update overall running balances
        }

        // --- EXPORT FUNCTIONS (EXCEL & PDF) ---

        // Exports the transaction data to an Excel file (.xlsx) using SheetJS library.
        function exportToExcel() {
            if (transactions.length === 0) {
                showToast('No transactions to export', 'error');
                return;
            }

            // Prepare data in a format suitable for Excel export
            const dataForExcel = transactions.map(t => ({
                'Transaction ID': t.id,
                'Date': new Date(t.date).toLocaleString(), // Format date and time for readability
                'Type': t.type,
                'Action': t.action,
                'Amount': t.amount, // Keep as number for Excel to format
                'Commission': t.commission || 0,
                'Fee': t.fee || 0,
                'Phone': t.phone,
                'Note': t.note
            }));

            // Create worksheet and workbook using SheetJS
            const ws = XLSX.utils.json_to_sheet(dataForExcel);
            const wb = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(wb, ws, "Transactions"); // Append sheet with data

            try {
                XLSX.writeFile(wb, "MoneyManager_Transactions.xlsx"); // Trigger file download
                showToast('Transactions exported to Excel!');
            } catch (e) {
                console.error("Error during Excel export:", e);
                showToast("Error exporting to Excel", "error");
            }
        }

        // Exports the transaction list to a PDF document using jsPDF and html2canvas.
        function exportToPDF() {
            if (transactions.length === 0) {
                showToast('No transactions to export', 'error');
                return;
            }

            const transactionListSection = document.getElementById('transaction-list');
            if (!transactionListSection) {
                showToast('Transaction list section not found', 'error');
                return;
            }

            // Ensure the transaction list is expanded and rendered before capturing
            if (transactionListSection.classList.contains('expanded') === false) {
                 toggleTransactionList(); // Expand if collapsed
            }
            // If list is expanded but empty, re-render it to ensure content is present
            if (transactionListSection.querySelector('.grouped-transaction') === null || transactionListSection.querySelector('.no-data')) {
                 if (transactions.length > 0) {
                    updateTransactionList(); // Render if currently empty
                 }
            }

            // Use a slight delay to ensure rendering is complete before capturing
            setTimeout(() => {
                const captureTargetElement = document.getElementById('transaction'); // Element to capture for PDF
                if (!captureTargetElement) {
                    showToast('Transaction tab content not found for capture', 'error');
                    return;
                }

                // Create a temporary, hidden wrapper to clone and capture content without affecting the main DOM
                const tempWrapper = document.createElement('div');
                tempWrapper.style.cssText = `
                    position: absolute;
                    left: -9999px; /* Position off-screen */
                    top: 0;
                    opacity: 1;
                    width: auto;
                    height: auto;
                    visibility: visible;
                    padding: 20px;
                    background-color: #ffffff; /* White background for the PDF page */
                    z-index: 10000;
                    font-family: 'Segoe UI', 'Inter', Arial, sans-serif; /* Consistent font */
                    color: #212529;
                    font-size: 14px;
                    line-height: 1.6;
                    box-sizing: border-box;
                `;

                // Clone the transaction list items, hide action buttons, and remove active states
                const clonedListItems = transactionListSection.querySelector('.transaction-list-items').cloneNode(true);
                const actionButtons = clonedListItems.querySelectorAll('.transaction-actions');
                actionButtons.forEach(el => el.style.display = 'none'); // Hide edit/delete buttons

                const activeItems = clonedListItems.querySelectorAll('.transaction-item.active');
                activeItems.forEach(item => item.classList.remove('active')); // Remove active styling

                // Structure the content for the PDF page, including a title
                tempWrapper.innerHTML = `
                    <h2 style="text-align: center; margin-bottom: 30px; color: #007bff; font-size: 2em; border-bottom: 2px solid #007bff; padding-bottom: 15px;">Transaction History</h2>
                    <div style="margin-bottom: 25px;">
                        ${clonedListItems.innerHTML}
                    </div>
                `;
                document.body.appendChild(tempWrapper); // Add temporary wrapper to DOM

                // Use html2canvas to capture the cloned content as an image
                html2canvas(tempWrapper, {
                    useCORS: true, // Handle cross-origin resources if necessary
                    logging: false, // Disable logging
                    letterRendering: true, // Improve text rendering
                    scale: 2, // Increase scale for higher resolution
                    backgroundColor: '#ffffff' // Ensure white background
                })
                .then(canvas => {
                    if (tempWrapper.parentNode) {
                        document.body.removeChild(tempWrapper); // Clean up the temporary wrapper
                    }

                    const imgData = canvas.toDataURL('image/png'); // Get image data URL

                    // Initialize jsPDF instance
                    let pdf;
                    try {
                        if (typeof jspdf === 'undefined' || typeof jspdf.jsPDF === 'undefined') {
                            throw new Error("jsPDF library is not loaded or accessible.");
                        }
                        pdf = new jspdf.jsPDF('p', 'mm', 'a4'); // Portrait, millimeters, A4 size
                    } catch (e) {
                        console.error("PDF initialization error:", e);
                        showToast("Error initializing PDF generator. Ensure jsPDF is loaded correctly.", "error");
                        return;
                    }

                    const imgProps = canvas; // Canvas dimensions
                    const pdfWidth = pdf.internal.pageSize.getWidth(); // PDF page width
                    const pdfHeight = pdf.internal.pageSize.getHeight(); // PDF page height

                    // Calculate scaled height to maintain aspect ratio and fit within PDF page margins
                    const aspectRatio = imgProps.height / imgProps.width;
                    let scaledHeight = pdfWidth * aspectRatio;

                    const pageMargin = 15; // Margin for the PDF page

                    // Adjust scaled height if it exceeds page height minus margins
                    if (scaledHeight > pdfHeight - (2 * pageMargin)) {
                        scaledHeight = pdfHeight - (2 * pageMargin);
                    }

                    // Add the captured image to the PDF document
                    pdf.addImage(imgData, 'PNG', 0, pageMargin, pdfWidth, scaledHeight); // Position: x=0, y=margin, width=pdfWidth, height=scaledHeight

                    try {
                        pdf.save("MoneyManager_Transactions.pdf"); // Save the PDF file
                        showToast('Transactions exported to PDF!');
                    } catch (e) {
                        console.error("Error saving PDF:", e);
                        showToast("Error saving PDF", "error");
                    }
                })
                .catch(error => {
                    // Handle errors during html2canvas capture
                    if (tempWrapper.parentNode) {
                        document.body.removeChild(tempWrapper); // Clean up on error
                    }
                    console.error("Error capturing transactions for PDF: ", error);
                    showToast('Failed to export transactions to PDF: ' + error.message, 'error');
                });
            }, 300); // Small delay to ensure rendering is complete before capture
        }

        // --- TOGGLE VISIBILITY OF COLLAPSIBLE LISTS ---

        // Toggles the expanded/collapsed state of the transaction list.
        function toggleTransactionList() {
            const listContainer = document.getElementById('transaction-list');
            listContainer.classList.toggle('expanded'); // Toggle the 'expanded' class
            // If expanding and the list is currently empty or showing 'no-data', re-render it
            if (listContainer.classList.contains('expanded') && (listContainer.querySelector('.grouped-transaction') === null || listContainer.querySelector('.no-data'))) {
                 if (transactions.length > 0) {
                    updateTransactionList(); // Render if currently empty
                 }
            }
        }

        // Toggles the expanded/collapsed state of the money records list.
        function toggleMoneyList() {
            const listContainer = document.getElementById('money-list');
            listContainer.classList.toggle('expanded'); // Toggle the 'expanded' class
            // If expanding and the list is currently empty or showing 'no-data', re-render it
            if (listContainer.classList.contains('expanded') && (listContainer.querySelector('.grouped-transaction') === null || listContainer.querySelector('.no-data'))) {
                 if (moneyRecords.length > 0) {
                    updateMoneyList(); // Render if currently empty
                 }
            }
        }

        // Toggles the expanded/collapsed state of the daily transaction summaries.
        function toggleTransactionSummary() {
            const summarySection = document.getElementById('transaction').querySelector('.summary-section');
            toggleExpand(summarySection); // Use the generic toggleExpand function
        }

        // Toggles the expanded/collapsed state of the daily money record summaries.
        function toggleDailyMoneySummary() {
            const summarySection = document.getElementById('daily-money').querySelector('.summary-section');
            toggleExpand(summarySection); // Use the generic toggleExpand function
        }

        // Toggles the expanded/collapsed state of a grouped list item (e.g., transactions by date).
        function toggleGroup(groupElement) {
            groupElement.classList.toggle('expanded'); // Toggle the 'expanded' class
        }

        // --- DEBT/CREDIT TAB FUNCTIONS ---

        // Updates the `existingDebtNames` array with unique names from the current `debts` data.
        // This is used for the autocomplete suggestions in the debt name input.
        function updateExistingDebtNames() {
            const nameSet = new Set();
            debts.forEach(debtGroup => {
                nameSet.add(debtGroup.name.toLowerCase()); // Store names in lowercase for case-insensitive matching
            });
            existingDebtNames = Array.from(nameSet); // Convert Set to Array
        }

        // Handles input in the debt name field to show autocomplete suggestions.
        function handleDebtNameInput(event) {
            const inputField = event.target;
            const name = inputField.value.trim();
            const suggestionsContainer = document.getElementById('debt-name-suggestions');

            // Clear previous suggestions and hide the container
            if (suggestionsContainer) {
                suggestionsContainer.innerHTML = '';
                suggestionsContainer.style.display = 'none';
            }

            if (name.length < 2) return; // Don't show suggestions for very short inputs

            // Filter existing names that contain the typed input (case-insensitive)
            const matchingNames = existingDebtNames
                .filter(existingName => existingName.includes(name.toLowerCase()))
                .slice(0, 5); // Limit to the top 5 suggestions

            if (matchingNames.length > 0 && suggestionsContainer) {
                suggestionsContainer.style.display = 'block'; // Show the suggestions container
                matchingNames.forEach(match => {
                    const suggestionItem = document.createElement('div');
                    suggestionItem.className = 'debt-suggestion-item';
                    // Capitalize the first letter of the suggestion for better display
                    suggestionItem.textContent = match.charAt(0).toUpperCase() + match.slice(1);
                    // Add click handler to select a suggestion
                    suggestionItem.onclick = () => {
                        inputField.value = suggestionItem.textContent; // Set input value
                        if (suggestionsContainer) suggestionsContainer.style.display = 'none'; // Hide suggestions
                        // Remove the global click listener for suggestions if it exists
                        if (hideSuggestionsOnClickOutside) {
                            document.removeEventListener('click', hideSuggestionsOnClickOutside);
                            hideSuggestionsOnClickOutside = null;
                        }
                    };
                    suggestionsContainer.appendChild(suggestionItem);
                });

                // Add a global click listener to hide suggestions when clicking outside
                if (!hideSuggestionsOnClickOutside) {
                    hideSuggestionsOnClickOutside = (e) => {
                        // Hide if click is outside the suggestions container AND outside the input field
                        if (suggestionsContainer && !suggestionsContainer.contains(e.target) && !inputField.contains(e.target)) {
                            suggestionsContainer.style.display = 'none';
                            document.removeEventListener('click', hideSuggestionsOnClickOutside); // Remove listener
                            hideSuggestionsOnClickOutside = null;
                        }
                    };
                    document.addEventListener('click', hideSuggestionsOnClickOutside);
                }
            }
        }

        // Handles adding a new debt/credit entry or updating an existing one.
        function addOrUpdateDebtEntry() {
            const nameInput = document.getElementById('debt-name');
            const name = nameInput.value.trim();

            const type = document.getElementById('debt-type').value; // 'payable' or 'receivable'
            const amountStr = document.getElementById('debt-amount').value;
            const amount = parseFloat(amountStr.replace(/,/g, '')); // Parse amount
            const date = document.getElementById('debt-date').value;
            const note = document.getElementById('debt-note').value.trim();

            // --- Input Validation ---
            if (!name) { showToast("Name is required.", "error"); return; }
            if (isNaN(amount) || amount <= 0) { showToast("Amount must be a positive number.", "error"); return; }
            if (!date) { showToast("Date/Time is required.", "error"); return; }
            // --- End Validation ---

            let historyEntryType; // Type for the specific history entry (e.g., initial_payable, payment_out)
            // Determine the type for the new/updated history entry
            if (editingDebtEntry) {
                historyEntryType = editingDebtEntry.type; // Maintain original type if editing
            } else {
                // If it's a new entry, determine type based on the selected debt type (payable/receivable)
                historyEntryType = type === 'payable' ? 'initial_payable' : 'initial_receivable';
            }

            // Create the history entry object
            const newOrUpdatedEntry = {
                id: editingDebtEntry ? editingDebtEntry.id : Date.now().toString(), // Use existing ID if editing, generate new one otherwise
                date: date,
                amount: amount,
                type: historyEntryType,
                note: note
            };

            // Find the index of the debt group for this name and type
            let debtGroupIndex = debts.findIndex(debt => debt.name === name && debt.type === type);
            let targetGroupType = type;

            // If no existing group for this name and type, create a new one
            if (debtGroupIndex === -1) {
                // Ensure the name exists in existingDebtNames before creating a new group
                // (This is primarily for cases where the name might have been typed directly without selection)
                if (!existingDebtNames.includes(name.toLowerCase())) {
                     existingDebtNames.push(name.toLowerCase()); // Add to the list for future suggestions
                     // No need to update localStorage for existingDebtNames here, it's derived from debts.
                }
                debts.push({ name: name, type: targetGroupType, history: [], id: `debtGroup_${Date.now()}` }); // Add new group
                debtGroupIndex = debts.length - 1; // Get the index of the newly added group
            }

            let needsReconciliation = false; // Flag to check if the debt type changed during editing
            if (editingDebtEntry && editingDebtEntry.groupType !== targetGroupType) {
                needsReconciliation = true; // Mark for reconciliation if type changed
            }

            // Handle updating or adding entry, potentially across different debt types if group type changed
            if (editingDebtEntry && needsReconciliation) {
                // If type changed, remove the entry from its original group first
                const originalGroupIndex = debts.findIndex(debt => debt.name === name && debt.type === editingDebtEntry.groupType);
                if (originalGroupIndex !== -1) {
                    // Find and remove the entry from the original group's history
                    const originalEntryIndex = debts[originalGroupIndex].history.findIndex(entry => entry.id.toString() === editingDebtEntry.id.toString());
                    if (originalEntryIndex !== -1) {
                        debts[originalGroupIndex].history.splice(originalEntryIndex, 1);
                        // If the original group becomes empty, remove the group itself
                        if (debts[originalGroupIndex].history.length === 0) {
                            debts.splice(originalGroupIndex, 1);
                        }
                    }
                }
                // Add the updated entry to the new group
                debts[debtGroupIndex].history.push(newOrUpdatedEntry);
            } else if (editingDebtEntry) {
                // If editing within the same group, find and update the existing entry
                const entryIndexInGroup = debts[debtGroupIndex].history.findIndex(entry => entry.id.toString() === editingDebtEntry.id.toString());
                if (entryIndexInGroup !== -1) {
                    debts[debtGroupIndex].history[entryIndexInGroup] = newOrUpdatedEntry; // Update entry
                } else {
                    // If entry not found (should not happen), just add it
                    debts[debtGroupIndex].history.push(newOrUpdatedEntry);
                }
            } else {
                // If it's a new entry, simply add it to the relevant group's history
                debts[debtGroupIndex].history.push(newOrUpdatedEntry);
            }

            updateExistingDebtNames(); // Update the list of names for autocomplete suggestions
            saveData(); // Save the updated debts array
            renderDebts(); // Re-render the debt lists to reflect changes
            clearDebtForm(); // Clear the form fields
            showToast(editingDebtEntry ? 'Debt/Credit entry updated successfully!' : 'Debt/Credit added successfully!');
            editingDebtEntry = null; // Reset the editing state
            updateAddUpdateButtonText(); // Update the button text back to 'Add'
        }

        // Updates the text and icon of the "Add/Update" button in the debt form based on editing state.
        function updateAddUpdateButtonText() {
            const button = document.getElementById('add-update-debt-button');
            if (editingDebtEntry) {
                button.innerHTML = '<i class="fas fa-sync-alt"></i> Update Entry'; // Change to Update
            } else {
                button.innerHTML = '<i class="fas fa-save"></i> Add Debt/Credit'; // Change back to Add
            }
        }

        // Clears and resets all fields in the debt/credit form to their default states.
        function clearDebtForm() {
            document.getElementById('debt-name').value = ''; // Clear name input
            const suggestionsContainer = document.getElementById('debt-name-suggestions');
            // Clear and hide suggestions container
            if (suggestionsContainer) {
                suggestionsContainer.innerHTML = '';
                suggestionsContainer.style.display = 'none';
            }
            // Remove the global click listener for suggestions if it exists
            if (hideSuggestionsOnClickOutside) {
                document.removeEventListener('click', hideSuggestionsOnClickOutside);
                hideSuggestionsOnClickOutside = null;
            }

            document.getElementById('debt-type').value = 'payable'; // Reset type to default
            document.getElementById('debt-amount').value = ''; // Clear amount
            updateDateTimeFields(); // Reset date/time to current
            document.getElementById('debt-note').value = ''; // Clear note
            updateDebtFormVisibility(); // Reset any specific visibility changes

            editingDebtEntry = null; // Clear the editing state
            updateAddUpdateButtonText(); // Reset button text to 'Add'
        }

        // Renders the debts and credits lists, organizing them by name and type, and calculating summary totals.
        function renderDebts() {
            const payableList = document.querySelector('#payable-debts-list .transaction-list-items');
            const receivableList = document.querySelector('#receivable-debts-list .transaction-list-items');
            payableList.innerHTML = ''; // Clear existing lists
            receivableList.innerHTML = '';

            let totalPayable = 0; // Initialize total payable amount
            let totalReceivable = 0; // Initialize total receivable amount

            // Aggregate history entries by person's name and debt type (payable/receivable)
            const aggregatedDebts = {};

            // Process all debt groups to aggregate history
            debts.forEach(debtGroup => {
                const { name, type, history, id } = debtGroup; // Destructure group details
                // Initialize entry for this name if it doesn't exist in aggregatedDebts
                if (!aggregatedDebts[name]) {
                    aggregatedDebts[name] = {
                        payableHistory: [], // History for 'payable' type
                        receivableHistory: [], // History for 'receivable' type
                    };
                }
                // Add history entries to the appropriate list based on group type
                if (type === 'payable') {
                    aggregatedDebts[name].payableHistory.push(...history.map(h => ({...h, groupId: id}))); // Map history entries with group ID
                } else {
                    aggregatedDebts[name].receivableHistory.push(...history.map(h => ({...h, groupId: id})));
                }
            });

            const sortedNames = Object.keys(aggregatedDebts).sort(); // Sort names alphabetically

            // Process aggregated debts to calculate current balances and render list items
            sortedNames.forEach(name => {
                const debtAggregation = aggregatedDebts[name]; // Get aggregated history for this name

                // Process Payable Debts
                if (debtAggregation.payableHistory.length > 0) {
                    let currentPayableTotal = 0;
                    // Sort history chronologically for accurate balance calculation
                    debtAggregation.payableHistory.sort((a, b) => new Date(a.date) - new Date(b.date));
                    debtAggregation.payableHistory.forEach(entry => {
                        // Calculate balance based on entry type
                        if (entry.type === 'initial_payable' || entry.type === 'payment_out') {
                            currentPayableTotal += entry.amount; // Increase payable amount
                        } else if (entry.type === 'initial_receivable' || entry.type === 'payment_in') {
                            currentPayableTotal -= entry.amount; // Decrease payable amount
                        }
                    });
                    currentPayableTotal = Math.max(0, currentPayableTotal); // Ensure total doesn't go below zero

                    // Only display if there's a positive payable amount remaining
                    if (currentPayableTotal > 0) {
                        totalPayable += currentPayableTotal; // Add to overall payable total
                        const payableDiv = createDebtListItem(name, 'payable', currentPayableTotal, debtAggregation.payableHistory); // Create list item HTML
                        payableList.appendChild(payableDiv); // Add to payable list
                    }
                }

                // Process Receivable Credits
                if (debtAggregation.receivableHistory.length > 0) {
                    let currentReceivableTotal = 0;
                    // Sort history chronologically
                    debtAggregation.receivableHistory.sort((a, b) => new Date(a.date) - new Date(b.date));
                    debtAggregation.receivableHistory.forEach(entry => {
                        // Calculate balance based on entry type
                        if (entry.type === 'initial_receivable' || entry.type === 'payment_in') {
                            currentReceivableTotal += entry.amount; // Increase receivable amount
                        } else if (entry.type === 'initial_payable' || entry.type === 'payment_out') {
                            currentReceivableTotal -= entry.amount; // Decrease receivable amount
                        }
                    });
                    currentReceivableTotal = Math.max(0, currentReceivableTotal); // Ensure total doesn't go below zero

                    // Only display if there's a positive receivable amount remaining
                    if (currentReceivableTotal > 0) {
                        totalReceivable += currentReceivableTotal; // Add to overall receivable total
                        const receivableDiv = createDebtListItem(name, 'receivable', currentReceivableTotal, debtAggregation.receivableHistory); // Create list item HTML
                        receivableList.appendChild(divDiv); // Add to receivable list
                    }
                }
            });

            // Update the total summary displays
            document.getElementById('total-payable-amount').textContent = formatNumber(totalPayable);
            document.getElementById('total-receivable-amount').textContent = formatNumber(totalReceivable);

            // Display 'no data' message if lists are empty
            if (payableList.children.length === 0) {
                payableList.innerHTML = '<p class="no-data">No payable debts found.</p>';
            }
            if (receivableList.children.length === 0) {
                receivableList.innerHTML = '<p class="no-data">No receivable credits found.</p>';
            }
        }

        // Helper function to create the HTML structure for a debt list item (group)
        function createDebtListItem(name, type, amount, history) {
            const debtDiv = document.createElement('div');
            debtDiv.className = 'debt-list-item';
            debtDiv.dataset.name = name; // Store name for potential editing
            debtDiv.dataset.type = type; // Store type for potential editing

            const amountClass = type === 'payable' ? 'negative' : 'positive'; // Class for amount color
            const formattedAmount = formatNumber(amount); // Format amount for display

            const historyHtml = generateHistoryHtml(history); // Generate HTML for history entries

            // Construct the inner HTML for the debt list item
            debtDiv.innerHTML = `
                <div class="debt-item-summary sticky-header" onclick="toggleDebtDetails(event, '${name.replace(/'/g, "\\'")}', '${type}')">
                    <div class="debt-name">${name}</div>
                    <span class="debt-amount ${amountClass}">${formattedAmount}</span>
                </div>
                <div class="debt-item-details-expanded" id="debt-details-${name.replace(/'/g, "\\'")}-${type}">
                    <div class="debt-actions">
                        <button class="action-button-text delete" onclick="deleteDebtGroup('${name.replace(/'/g, "\\'")}','${type}')"><i class="fas fa-trash-alt"></i> Delete Group</button>
                        <button class="action-button-text secondary" onclick="toggleDetailsButtonAction('${name.replace(/'/g, "\\'")}', '${type}')"><i class="fas fa-ellipsis-h"></i> Details</button>
                    </div>
                    <div class="debt-details">
                        <span class="debt-type">${type === 'payable' ? 'You owe' : 'Owed to you'}</span>
                        ${historyHtml ? `<span class="debt-note">${history.length} entries</span>` : ''}
                    </div>
                    ${historyHtml}
                </div>
            `;
            return debtDiv;
        }

        // Toggles the visibility of the detailed history for a debt entry.
        function toggleDebtDetails(event, name, type) {
            // Prevent toggling if the click was on an action button (edit/delete)
            if (event.target.closest('.debt-actions') || event.target.closest('button')) {
                return;
            }

            const detailsDiv = document.getElementById(`debt-details-${name.replace(/'/g, "\\'")}-${type}`); // Get the specific details div
            if (detailsDiv) {
                detailsDiv.classList.toggle('visible'); // Toggle the 'visible' class
                updateToggleButtonIconAndText(name, type); // Update the appearance of the 'Details' button
            }
        }

        // Handles the click event for the 'Details' button within a debt item to toggle visibility.
        function toggleDetailsButtonAction(name, type) {
            const detailsDiv = document.getElementById(`debt-details-${name.replace(/'/g, "\\'")}-${type}`);
            const toggleButton = detailsDiv ? detailsDiv.querySelector('.debt-actions button[onclick*="toggleDetailsButtonAction"]') : null; // Find the button itself

            if (toggleButton && detailsDiv) {
                detailsDiv.classList.toggle('visible'); // Toggle visibility of details
                updateToggleButtonIconAndText(name, type); // Update the button's icon and text
            }
        }

        // Updates the icon and text of the 'Details' button based on the visibility state of the details section.
        function updateToggleButtonIconAndText(name, type) {
            const detailsDiv = document.getElementById(`debt-details-${name.replace(/'/g, "\\'")}-${type}`);
            const toggleButton = detailsDiv ? detailsDiv.querySelector('.debt-actions button[onclick*="toggleDetailsButtonAction"]') : null;

            if (toggleButton && detailsDiv) {
                const iconElement = toggleButton.querySelector('.fa-ellipsis-h, .fa-times'); // Find the icon element (either ellipsis or times)
                if (detailsDiv.classList.contains('visible')) {
                    // If details are visible, change to 'Hide Details' state
                    if (iconElement) iconElement.classList.replace('fa-ellipsis-h', 'fa-times'); // Change icon to 'times'
                    toggleButton.innerHTML = '<i class="fas fa-times"></i> Hide Details'; // Update button text
                } else {
                    // If details are hidden, change back to 'Show Details' state
                    if (iconElement) iconElement.classList.replace('fa-times', 'fa-ellipsis-h'); // Change icon back to ellipsis
                    toggleButton.innerHTML = '<i class="fas fa-ellipsis-h"></i> Details'; // Update button text
                }
            }
        }

        // Loads a specific history entry into the form fields for editing.
        function editDebtHistoryEntry(entryId) {
            // Iterate through all debt groups to find the entry by its ID
            for (let i = 0; i < debts.length; i++) {
                const debtGroup = debts[i];
                const historyEntryIndex = debtGroup.history.findIndex(entry => entry.id.toString() === entryId.toString()); // Find entry by ID

                if (historyEntryIndex !== -1) {
                    const entryToEdit = debtGroup.history[historyEntryIndex]; // Get the entry object

                    // Populate the form with the entry's data
                    document.getElementById('debt-name').value = debtGroup.name;
                    document.getElementById('debt-type').value = debtGroup.type;
                    document.getElementById('debt-amount').value = formatNumber(entryToEdit.amount);
                    document.getElementById('debt-date').value = entryToEdit.date;
                    document.getElementById('debt-note').value = entryToEdit.note || '';
                    updateDebtFormVisibility(); // Update UI based on selected type

                    // Store editing context (entry ID, types, group/entry indices)
                    editingDebtEntry = {
                        id: entryToEdit.id,
                        type: entryToEdit.type,
                        groupType: debtGroup.type, // Original group type
                        groupIdx: i, // Index of the debt group
                        entryIdx: historyEntryIndex // Index of the entry within the group
                    };
                    updateAddUpdateButtonText(); // Change button text to 'Update'

                    // Remove the entry from its original location before editing to prevent duplication
                    debtGroup.history.splice(historyEntryIndex, 1);

                    // If the group becomes empty after removing the entry, delete the group
                    if (debtGroup.history.length === 0) {
                        debts.splice(i, 1);
                    }

                    saveData(); // Save the changes (removal of old entry)
                    renderDebts(); // Re-render lists to reflect the removal
                    showToast('Entry loaded for editing. Update form and click Update.');
                    window.scrollTo(0, 0); // Scroll to top to focus on the form
                    return; // Exit loop after finding and processing the entry
                }
            }
            showToast("Entry not found for editing.", "error");
        }

        // Deletes a specific history entry from a debt group.
        function deleteDebtHistoryEntry(entryId) {
            if (!confirm('Are you sure you want to delete this history entry? This action cannot be undone.')) {
                return; // Cancel if user confirms no
            }

            // Iterate through all debt groups to find the entry by ID
            for (let i = 0; i < debts.length; i++) {
                const debtGroup = debts[i];
                const historyEntryIndex = debtGroup.history.findIndex(entry => entry.id.toString() === entryId.toString());

                if (historyEntryIndex !== -1) {
                    debtGroup.history.splice(historyEntryIndex, 1); // Remove the entry

                    // If the group becomes empty after removal, delete the group itself
                    if (debtGroup.history.length === 0) {
                        debts.splice(i, 1);
                    }

                    updateExistingDebtNames(); // Update name list
                    saveData(); // Save changes
                    renderDebts(); // Re-render lists
                    showToast('History entry deleted successfully.');
                    return; // Exit after deletion
                }
            }
            showToast("Entry not found for deletion.", "error");
        }

        // Deletes an entire debt group (all history entries for a person and type).
        function deleteDebtGroup(name, type) {
             // Confirm deletion of the entire group
             if (!confirm(`Are you sure you want to delete the entire group for "${name}" (${type})? This action cannot be undone.`)) {
                return; // Cancel if user denies
            }

            // Find the index of the group to delete
            const groupIndexToDelete = debts.findIndex(debt => debt.name === name && debt.type === type);

            if (groupIndexToDelete !== -1) {
                debts.splice(groupIndexToDelete, 1); // Remove the group
                updateExistingDebtNames(); // Update name list
                saveData(); // Save changes
                renderDebts(); // Re-render lists
                showToast('Debt group deleted successfully.');
            } else {
                showToast('Group not found for deletion.', 'error');
            }
        }

        // Placeholder function for UI changes based on debt type selection (if needed in the future).
        function updateDebtFormVisibility() {
            // Currently, no specific UI changes are needed based on debt type selection.
        }

        // Filters the debt/credit lists based on a name search input.
        function filterDebts() {
            const nameFilter = document.getElementById('debt-filter-name').value.toLowerCase(); // Get search term (lowercase)
            let filteredDebts = debts; // Start with all debt groups

            // Apply filter if a search term is entered
            if (nameFilter) {
                filteredDebts = filteredDebts.filter(debtGroup => debtGroup.name.toLowerCase().includes(nameFilter));
            }

            renderDebtsFiltered(filteredDebts); // Render the filtered results
        }

        // Resets the debt/credit filters and shows all debts.
        function resetDebtFilters() {
            document.getElementById('debt-filter-name').value = ''; // Clear search input
            renderDebts(); // Render all debts by calling renderDebts without filters
        }

        // Generates the HTML for the history entries of a debt group.
        function generateHistoryHtml(history) {
            if (!history || history.length === 0) return ''; // Return empty string if no history

            let historyHtml = '<div class="debt-history-list">';
            // Sort history entries chronologically for display
            const sortedHistory = [...history].sort((a, b) => new Date(a.date) - new Date(b.date));

            sortedHistory.forEach(entry => {
                const entryDateTime = new Date(entry.date);
                const entryDisplay = entryDateTime.toLocaleString(); // Format date and time

                let amountClass = ''; // CSS class for amount color (positive/negative)
                let entryTypeLabel = ''; // Label for the type of history entry

                // Determine label and class based on entry type
                switch (entry.type) {
                    case 'initial_payable': amountClass = 'negative'; entryTypeLabel = 'Initial Debt'; break;
                    case 'initial_receivable': amountClass = 'positive'; entryTypeLabel = 'Initial Credit'; break;
                    case 'payment_out': amountClass = 'negative'; entryTypeLabel = 'Paid'; break; // Payment made by you
                    case 'payment_in': amountClass = 'positive'; entryTypeLabel = 'Received'; break; // Payment received by you
                    default:
                        // For any other custom types, format them nicely
                        amountClass = ''; // Default class
                        entryTypeLabel = entry.type.charAt(0).toUpperCase() + entry.type.slice(1).replace('_', ' ');
                        break;
                }

                const noteDisplay = entry.note ? ` - ${entry.note}` : ''; // Add note if available

                // Construct HTML for each history item, including edit/delete buttons
                historyHtml += `
                    <div class="debt-history-item">
                        <span>${entryDisplay} - ${entryTypeLabel}${noteDisplay}</span>
                        <span class="${amountClass}">${formatNumber(entry.amount)}</span>
                        <div class="debt-history-actions">
                            <button class="action-button-text edit" onclick="editDebtHistoryEntry('${entry.id}')"><i class="fas fa-edit"></i></button>
                            <button class="action-button-text delete" onclick="deleteDebtHistoryEntry('${entry.id}')"><i class="fas fa-trash-alt"></i></button>
                        </div>
                    </div>
                `;
            });
            historyHtml += '</div>'; // Close the history list div
            return historyHtml;
        }

        // Helper function to render the debt/credit lists, potentially filtered.
        function renderDebtsFiltered(filteredDebts) {
            const payableList = document.querySelector('#payable-debts-list .transaction-list-items');
            const receivableList = document.querySelector('#receivable-debts-list .transaction-list-items');
            payableList.innerHTML = ''; // Clear existing lists
            receivableList.innerHTML = '';

            let totalPayable = 0; // Initialize total payable amount
            let totalReceivable = 0; // Initialize total receivable amount

            // Aggregate history entries by person's name and debt type
            const aggregatedDebts = {};

            filteredDebts.forEach(debtGroup => { // Iterate over the filtered list
                const { name, type, history, id } = debtGroup;
                if (!aggregatedDebts[name]) {
                    aggregatedDebts[name] = { payableHistory: [], receivableHistory: [] };
                }
                if (type === 'payable') {
                    aggregatedDebts[name].payableHistory.push(...history.map(h => ({...h, groupId: id}))); // Add group ID
                } else {
                    aggregatedDebts[name].receivableHistory.push(...history.map(h => ({...h, groupId: id})));
                }
            });

            const sortedNames = Object.keys(aggregatedDebts).sort(); // Sort names alphabetically

            // Process aggregated debts to calculate current balances and render list items
            sortedNames.forEach(name => {
                const debtAggregation = aggregatedDebts[name];

                // Process Payable Debts
                if (debtAggregation.payableHistory.length > 0) {
                    let currentPayableTotal = 0;
                    debtAggregation.payableHistory.sort((a, b) => new Date(a.date) - new Date(b.date)); // Sort chronologically
                    debtAggregation.payableHistory.forEach(entry => {
                        if (entry.type === 'initial_payable' || entry.type === 'payment_out') {
                            currentPayableTotal += entry.amount; // Add to payable
                        } else if (entry.type === 'initial_receivable' || entry.type === 'payment_in') {
                            currentPayableTotal -= entry.amount; // Subtract from payable
                        }
                    });
                    currentPayableTotal = Math.max(0, currentPayableTotal); // Ensure non-negative

                    if (currentPayableTotal > 0) {
                        totalPayable += currentPayableTotal; // Add to overall total
                        const payableDiv = createDebtListItem(name, 'payable', currentPayableTotal, debtAggregation.payableHistory); // Create list item HTML
                        payableList.appendChild(payableDiv); // Add to payable list
                    }
                }

                // Process Receivable Credits
                if (debtAggregation.receivableHistory.length > 0) {
                    let currentReceivableTotal = 0;
                    debtAggregation.receivableHistory.sort((a, b) => new Date(a.date) - new Date(b.date)); // Sort chronologically
                    debtAggregation.receivableHistory.forEach(entry => {
                        if (entry.type === 'initial_receivable' || entry.type === 'payment_in') {
                            currentReceivableTotal += entry.amount; // Add to receivable
                        } else if (entry.type === 'initial_payable' || entry.type === 'payment_out') {
                            currentReceivableTotal -= entry.amount; // Subtract from receivable
                        }
                    });
                    currentReceivableTotal = Math.max(0, currentReceivableTotal); // Ensure non-negative

                    if (currentReceivableTotal > 0) {
                        totalReceivable += currentReceivableTotal; // Add to overall total
                        const receivableDiv = createDebtListItem(name, 'receivable', currentReceivableTotal, debtAggregation.receivableHistory); // Create list item HTML
                        receivableList.appendChild(divDiv); // Add to receivable list
                    }
                }
            });

            // Update the total summary displays
            document.getElementById('total-payable-amount').textContent = formatNumber(totalPayable);
            document.getElementById('total-receivable-amount').textContent = formatNumber(totalReceivable);

            // Display 'no data' message if lists are empty
            if (payableList.children.length === 0) {
                payableList.innerHTML = '<p class="no-data">No payable debts found.</p>';
            }
            if (receivableList.children.length === 0) {
                receivableList.innerHTML = '<p class="no-data">No receivable credits found.</p>';
            }
        }

        // --- EXPENSE TAB SPECIFIC FUNCTIONS ---

        // Updates the visibility of the 'Other (Manual)' input for expense categories based on the selected type and category.
        function updateExpenseCategoryVisibility() {
            const expenseTypeSelect = document.getElementById('expense-type');
            const expenseCategorySelect = document.getElementById('expense-category');
            const expenseCategoryOtherInput = document.getElementById('expense-category-other');

            const type = expenseTypeSelect.value;
            const category = expenseCategorySelect.value;

            // Show/hide the 'Other' input field based on the selected category
            if (category === 'other') {
                expenseCategoryOtherInput.style.display = 'block'; // Show input
                if (expenseCategoryOtherInput.style.display === 'block' && document.activeElement !== expenseCategoryOtherInput) {
                    expenseCategoryOtherInput.focus(); // Focus on the input field
                }
            } else {
                expenseCategoryOtherInput.style.display = 'none'; // Hide input
                expenseCategoryOtherInput.value = ''; // Clear its value
            }
        }

        // Updates the visibility of the 'Other' input for payment methods.
        function updatePaymentMethodVisibility() {
            const paymentMethodSelect = document.getElementById('expense-payment-method');
            const paymentMethodOtherInput = document.getElementById('expense-payment-method-other');

            if (paymentMethodSelect.value === 'Other') {
                paymentMethodOtherInput.style.display = 'block'; // Show input
                if (paymentMethodOtherInput.style.display === 'block' && document.activeElement !== paymentMethodOtherInput) {
                    paymentMethodOtherInput.focus(); // Focus on the input field
                }
            } else {
                paymentMethodOtherInput.style.display = 'none'; // Hide input
                paymentMethodOtherInput.value = ''; // Clear its value
            }
        }

        // Adds a new expense or income entry to the `expenseEntries` array.
        function addExpenseEntry() {
            const date = document.getElementById('expense-date').value;
            const type = document.getElementById('expense-type').value; // 'Expense' or 'Income'
            const categorySelect = document.getElementById('expense-category');
            const categoryOtherInput = document.getElementById('expense-category-other');
            let category = categorySelect.value;
            let finalCategory = category;

            // Handle 'Other' category
            if (category === 'other') {
                const customCategory = categoryOtherInput.value.trim();
                if (!customCategory) { // Validate custom category input
                    showToast('Please specify the other category', 'error');
                    return;
                }
                finalCategory = customCategory;
                // Save the custom category if it's new
                if (!savedExpenseCategories[finalCategory]) {
                    savedExpenseCategories[finalCategory] = finalCategory;
                    try {
                        localStorage.setItem('moneyManager_savedExpenseCategories', JSON.stringify(savedExpenseCategories));
                    } catch (e) { console.error("Error saving custom expense category:", e); }
                    addOptionToSelect('expense-category', finalCategory); // Add to dropdown
                }
            }

            const amount = parseFloat(document.getElementById('expense-amount').value.replace(/,/g, ''));
            const paymentMethod = document.getElementById('expense-payment-method').value;
            const paymentMethodOtherInput = document.getElementById('expense-payment-method-other');
            let finalPaymentMethod = paymentMethod;
            if (paymentMethod === 'Other') {
                const customPaymentMethod = paymentMethodOtherInput.value.trim();
                if (!customPaymentMethod) {
                    showToast('Please specify the other payment method', 'error');
                    return;
                }
                finalPaymentMethod = customPaymentMethod;
            }
            const note = document.getElementById('expense-note').value.trim();

            // --- Input Validation ---
            if (!date) { showToast('Date/Time is required.', 'error'); return; }
            if (!finalCategory) { showToast('Category is required.', 'error'); return; }
            if (isNaN(amount) || amount <= 0) { showToast('Amount must be a positive number.', 'error'); return; }
            if (!finalPaymentMethod) { showToast('Payment Method is required.', 'error'); return; }
            // --- End Validation ---

            const newEntry = {
                id: Date.now().toString(), // Simple ID for uniqueness
                date, type, category: finalCategory, amount, paymentMethod: finalPaymentMethod, note
            };

            expenseEntries.unshift(newEntry); // Add to the beginning of the array

            try {
                localStorage.setItem('moneyManager_expenseEntries', JSON.stringify(expenseEntries));
                showToast('Expense/Income entry added successfully!');
            } catch (e) {
                console.error("Error saving expense entries:", e);
                showToast('Error saving expense entry', 'error');
            }

            updateExpenseSummaries(); // Update summaries
            renderExpenseEntries(); // Re-render the list
            clearExpenseForm(); // Clear the form
        }

        // Clears and resets all fields in the expense form.
        function clearExpenseForm() {
            document.getElementById('expense-date').value = '';
            updateDateTimeFields(); // Reset date/time
            document.getElementById('expense-type').value = 'Expense'; // Reset type
            document.getElementById('expense-category').value = 'Rent'; // Reset category to default
            document.getElementById('expense-category-other').value = ''; // Clear 'Other' category input
            document.getElementById('expense-category-other').style.display = 'none'; // Hide 'Other' category input
            document.getElementById('expense-amount').value = ''; // Clear amount
            document.getElementById('expense-payment-method').value = 'E-Money'; // Reset payment method
            document.getElementById('expense-payment-method-other').value = ''; // Clear 'Other' payment method input
            document.getElementById('expense-payment-method-other').style.display = 'none'; // Hide 'Other' payment method input
            document.getElementById('expense-note').value = ''; // Clear note
        }

        // Renders the expense/income entries list.
        function renderExpenseEntries(filteredEntries = null) {
            const listContainer = document.querySelector('#expense-list .transaction-list-items');
            const entriesToShow = filteredEntries !== null ? filteredEntries : expenseEntries;

            listContainer.innerHTML = ''; // Clear current list

            if (entriesToShow.length === 0) {
                listContainer.innerHTML += '<p class="no-data">No expense/income records found.</p>';
                return;
            }

            // Group entries by date
            const groupedEntries = {};
            entriesToShow.forEach((entry, index) => {
                const dateKey = new Date(entry.date).toISOString().split('T')[0];
                const originalIndex = expenseEntries.findIndex(e => e.id === entry.id); // Find index in original array

                if (!groupedEntries[dateKey]) {
                    groupedEntries[dateKey] = {
                        items: [],
                        typeSummary: { income: 0, expense: 0 }
                    };
                }
                groupedEntries[dateKey].items.push({ ...entry, originalIndex });

                // Accumulate summaries
                const amount = parseFloat(entry.amount);
                if (entry.type === 'Income') {
                    groupedEntries[dateKey].typeSummary.income += amount;
                } else {
                    groupedEntries[dateKey].typeSummary.expense += amount;
                }
            });

            const sortedDates = Object.keys(groupedEntries).sort().reverse(); // Sort dates newest first

            for (const dateKey of sortedDates) {
                const groupData = groupedEntries[dateKey];
                const displayDate = new Date(dateKey).toDateString();
                const summaries = groupData.typeSummary;

                const groupElement = document.createElement('div');
                groupElement.className = 'grouped-transaction';

                groupElement.innerHTML = `
                    <div class="group-header" onclick="toggleGroup(this.parentElement)">
                        <span>${displayDate}</span>
                        <span>Income: ${formatNumber(summaries.income)} | Expense: ${formatNumber(summaries.expense)}</span>
                    </div>
                    <div class="group-details">
                        ${groupData.items.map(item => {
                            const amountClass = item.type === 'Income' ? 'positive' : 'negative';
                            return `
                                <div class="transaction-item">
                                    <div class="transaction-header">
                                        <span class="transaction-type">${item.category}</span>
                                        <span class="transaction-amount ${amountClass}">${formatNumber(item.amount)}</span>
                                    </div>
                                    <div class="transaction-details-mobile">
                                        <span class="transaction-date">${new Date(item.date).toLocaleTimeString()}</span>
                                        <span class="transaction-info-item"><strong>Type:</strong> ${item.type}</span>
                                        <span class="transaction-info-item"><strong>Method:</strong> ${item.paymentMethod}</span>
                                        ${item.note ? `<span class="transaction-info-item"><strong>Note:</strong> ${item.note.length > 50 ? item.note.substring(0, 50) + '...' : item.note}</span>` : ''}
                                    </div>
                                    <div class="transaction-actions">
                                        <button class="action-button-text edit" onclick="editExpenseEntry(${item.originalIndex})"><i class="fas fa-edit"></i></button>
                                        <button class="action-button-text delete" onclick="deleteExpenseEntry(${item.originalIndex})"><i class="fas fa-trash-alt"></i></button>
                                    </div>
                                </div>
                            `;
                        }).join('')}
                    </div>
                `;
                listContainer.appendChild(groupElement);
            }
        }

        // Loads an expense entry into the form for editing.
        function editExpenseEntry(index) {
            if (index < 0 || index >= expenseEntries.length) {
                showToast("Error loading expense entry for editing.", "error");
                return;
            }
            const entry = expenseEntries[index];

            document.getElementById('expense-date').value = entry.date;
            document.getElementById('expense-type').value = entry.type;

            const categorySelect = document.getElementById('expense-category');
            const categoryOtherInput = document.getElementById('expense-category-other');

            // Check if the category is custom or not a predefined option
            if (entry.category && entry.category.trim() !== '' && savedExpenseCategories[entry.category] || !Array.from(categorySelect.options).some(opt => opt.value === entry.category)) {
                categorySelect.value = 'other';
                categoryOtherInput.value = entry.category;
                categoryOtherInput.style.display = 'block';
                if (!savedExpenseCategories[entry.category]) {
                    savedExpenseCategories[entry.category] = entry.category;
                    try { localStorage.setItem('moneyManager_savedExpenseCategories', JSON.stringify(savedExpenseCategories)); } catch (e) { console.error("Error saving custom expense category during edit:", e); }
                    addOptionToSelect('expense-category', entry.category);
                }
            } else if (entry.category) {
                categorySelect.value = entry.category;
                categoryOtherInput.style.display = 'none';
                categoryOtherInput.value = '';
            } else {
                categorySelect.value = 'Rent';
                categoryOtherInput.style.display = 'none';
                categoryOtherInput.value = '';
            }

            document.getElementById('expense-amount').value = formatNumber(entry.amount);

            const paymentMethodSelect = document.getElementById('expense-payment-method');
            const paymentMethodOtherInput = document.getElementById('expense-payment-method-other');
            if (entry.paymentMethod && entry.paymentMethod.trim() !== '' && entry.paymentMethod !== 'E-Money' && entry.paymentMethod !== 'Cash' && entry.paymentMethod !== 'Other' || !['E-Money', 'Cash', 'Other'].includes(entry.paymentMethod)) {
                 paymentMethodSelect.value = 'Other';
                 paymentMethodOtherInput.value = entry.paymentMethod;
                 paymentMethodOtherInput.style.display = 'block';
            } else if (entry.paymentMethod) {
                 paymentMethodSelect.value = entry.paymentMethod;
                 paymentMethodOtherInput.style.display = 'none';
                 paymentMethodOtherInput.value = '';
            } else {
                 paymentMethodSelect.value = 'E-Money';
                 paymentMethodOtherInput.style.display = 'none';
                 paymentMethodOtherInput.value = '';
            }

            document.getElementById('expense-note').value = entry.note || '';

            updateExpenseCategoryVisibility(); // Update visibility after setting values

            // Remove entry from array for editing
            expenseEntries.splice(index, 1);
            updateExpenseSummaries(); // Update summaries
            renderExpenseEntries(); // Re-render list

            showToast('Expense/Income entry loaded for editing');
            window.scrollTo(0, 0);
        }

        // Deletes an expense entry from the `expenseEntries` array.
        function deleteExpenseEntry(index) {
            if (index < 0 || index >= expenseEntries.length) {
                showToast("Error deleting expense entry.", "error");
                return;
            }
            if (confirm('Are you sure you want to delete this entry?')) {
                expenseEntries.splice(index, 1);
                try {
                    localStorage.setItem('moneyManager_expenseEntries', JSON.stringify(expenseEntries));
                    showToast('Entry deleted successfully.');
                } catch (e) {
                    console.error("Error saving expense entries after delete:", e);
                    showToast('Error saving changes after deletion', 'error');
                }
                updateExpenseSummaries();
                renderExpenseEntries();
            }
        }

        // Filters expense entries based on selected criteria.
        function filterExpenses() {
            const typeFilter = document.getElementById('expense-filter-type').value;
            const categoryFilter = document.getElementById('expense-filter-category').value.toLowerCase();
            const dateFilterValue = document.getElementById('expense-filter-date').value;

            let filtered = expenseEntries;

            if (typeFilter !== 'all') {
                filtered = filtered.filter(entry => entry.type === typeFilter);
            }
            if (categoryFilter) {
                filtered = filtered.filter(entry => entry.category.toLowerCase().includes(categoryFilter));
            }
            if (dateFilterValue) {
                try {
                    const filterDate = new Date(dateFilterValue);
                    filterDate.setHours(0, 0, 0, 0);
                    filtered = filtered.filter(entry => {
                        const entryDateTime = new Date(entry.date);
                        if (isNaN(entryDateTime.getTime())) return false;
                        return entryDateTime.getFullYear() === filterDate.getFullYear() &&
                               entryDateTime.getMonth() === filterDate.getMonth() &&
                               entryDateTime.getDate() === filterDate.getDate();
                    });
                } catch (e) {
                    console.error("Error applying date filter for expenses:", e);
                    showToast("Error applying date filter.", "error");
                    filtered = [];
                }
            }

            renderExpenseEntries(filtered); // Render filtered entries
            updateExpenseSummaries(); // Update summaries based on filtered data
        }

        // Resets expense filters and re-renders the full list.
        function resetExpenseFilters() {
            document.getElementById('expense-filter-type').value = 'all';
            document.getElementById('expense-filter-category').value = '';
            document.getElementById('expense-filter-date').value = '';
            renderExpenseEntries(); // Show all entries
            updateExpenseSummaries(); // Update summaries with all data
        }

        // Updates the daily income, expense, and net balance summaries.
        function updateExpenseSummaries() {
    // Get the selected date filter value
    const dateFilterValue = document.getElementById('expense-filter-date').value;
    let startDate, endDate;

    if (dateFilterValue) {
        // If date filter is applied, use the filtered date
        const filterDate = new Date(dateFilterValue);
        startDate = new Date(filterDate);
        startDate.setHours(0, 0, 0, 0);
        endDate = new Date(filterDate);
        endDate.setHours(23, 59, 59, 999);
    } else {
        // If no date filter, use today's date
        const today = new Date();
        startDate = new Date(today);
        startDate.setHours(0, 0, 0, 0);
        endDate = new Date(today);
        endDate.setHours(23, 59, 59, 999);
    }

    let dailyIncome = 0;
    let dailyExpenses = 0;

    // Calculate daily totals from expenseEntries
    expenseEntries.forEach(entry => {
        const entryDate = new Date(entry.date);
        // Check if the entry falls within the date range
        if (entryDate >= startDate && entryDate <= endDate) {
            const amount = parseFloat(entry.amount);
            if (entry.type === 'Income') {
                dailyIncome += amount;
            } else {
                dailyExpenses += amount;
            }
        }
    });

    const netBalance = dailyIncome - dailyExpenses;

    // Update summary display elements
    document.getElementById('daily-total-income').textContent = formatNumber(dailyIncome);
    document.getElementById('daily-total-expenses').textContent = formatNumber(dailyExpenses);
    document.getElementById('daily-net-balance').textContent = formatNumber(netBalance);
    // Apply positive/negative styling to net balance
    const netBalanceElement = document.getElementById('daily-net-balance');
    netBalanceElement.className = netBalance >= 0 ? 'positive' : 'negative';
}

        // Updates the periodical income, expense, and net balance summaries based on selected period.
        function updatePeriodicalExpenseSummaries() {
            const periodType = document.getElementById('period-type').value; // 'week', 'month', 'year'
            const now = new Date();

            let startDate = new Date();
            let endDate = new Date();

            // Determine start and end dates based on the selected period type
            if (periodType === 'week') {
                startDate.setDate(now.getDate() - now.getDay()); // Start of the week (Sunday)
                startDate.setHours(0, 0, 0, 0);
                endDate.setDate(now.getDate() + (6 - now.getDay())); // End of the week (Saturday)
                endDate.setHours(23, 59, 59, 999);
            } else if (periodType === 'month') {
                startDate.setDate(1); // Start of the month
                startDate.setHours(0, 0, 0, 0);
                endDate.setMonth(now.getMonth() + 1); // Go to next month
                endDate.setDate(0); // Go to the last day of the current month
                endDate.setHours(23, 59, 59, 999);
            } else if (periodType === 'year') {
                startDate.setMonth(0); // Start of the year (January)
                startDate.setDate(1);
                startDate.setHours(0, 0, 0, 0);
                endDate.setFullYear(now.getFullYear() + 1); // Go to next year
                endDate.setMonth(0); // Go to January
                endDate.setDate(0); // Go to the last day of the current year
                endDate.setHours(23, 59, 59, 999);
            }

            let periodicalIncome = 0;
            let periodicalExpenses = 0;

            // Calculate periodical totals from expenseEntries
            expenseEntries.forEach(entry => {
                const entryDate = new Date(entry.date);
                // Check if the entry falls within the calculated period
                if (entryDate >= startDate && entryDate <= endDate) {
                    const amount = parseFloat(entry.amount);
                    if (entry.type === 'Income') {
                        periodicalIncome += amount;
                    } else {
                        periodicalExpenses += amount;
                    }
                }
            });

            const periodicalNetBalance = periodicalIncome - periodicalExpenses;

            // Update periodical summary display elements
            document.getElementById('periodical-total-income').textContent = formatNumber(periodicalIncome);
            document.getElementById('periodical-total-expenses').textContent = formatNumber(periodicalExpenses);
            document.getElementById('periodical-net-balance').textContent = formatNumber(periodicalNetBalance);
            // Apply positive/negative styling
            const periodicalNetBalanceElement = document.getElementById('periodical-net-balance');
            periodicalNetBalanceElement.className = periodicalNetBalance >= 0 ? 'positive' : 'negative';
        }

        // Triggers a UI update specifically for the Expenses tab, ensuring summaries and lists are refreshed.
        function updateExpenseTabUI() {
            // Update daily summaries
            updateExpenseSummaries();
            // Update periodical summaries based on the current selection
            updatePeriodicalExpenseSummaries();
            // Re-render the expense entries list to ensure it's up-to-date
            renderExpenseEntries();
            // Ensure collapsed sections are correctly displayed based on data
            updateSummariesBasedOnCurrentView();
        }

        // --- SAVE DATA ON PAGE UNLOAD ---
        // Ensure data is saved when the user navigates away or closes the page.
        window.addEventListener('beforeunload', saveData);
    </script>
</body>
</html>
